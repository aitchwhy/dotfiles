# Custom checks - AI CLI configuration validation with coverage reporting
# All tests are blocking - failures prevent builds
{ ... }:
{
  perSystem =
    { pkgs, ... }:
    {
      checks = {
        # ═══════════════════════════════════════════════════════════════════════════
        # Quality System TypeScript Validation
        # Validates the Quality System TypeScript code compiles correctly
        # ═══════════════════════════════════════════════════════════════════════════
        quality-typecheck =
          pkgs.runCommand "quality-typecheck"
            {
              nativeBuildInputs = [ pkgs.bun ];
              src = ../.;
            }
            ''
              # Copy source to writable directory
              cp -r $src/config/quality $TMPDIR/quality
              chmod -R u+w $TMPDIR/quality
              cd $TMPDIR/quality

              # Bun needs writable directories
              export HOME="$TMPDIR/home"
              mkdir -p "$HOME"

              echo "═══════════════════════════════════════════════════════════════"
              echo "Quality System TypeCheck"
              echo "═══════════════════════════════════════════════════════════════"

              # Install dependencies
              ${pkgs.bun}/bin/bun install --frozen-lockfile 2>&1 || true

              # Run typecheck
              ${pkgs.bun}/bin/bun x tsc --noEmit

              echo ""
              echo "✓ Quality System TypeScript validation passed"
              touch $out
            '';

        # ═══════════════════════════════════════════════════════════════════════════
        # Port Conflict Detection
        # Validates lib/config/ports.nix has no duplicate port assignments
        # ═══════════════════════════════════════════════════════════════════════════
        port-conflicts =
          let
            cfg = import ../lib/config { inherit (pkgs) lib; };
            failed = builtins.filter (a: !a.assertion) cfg.assertions;
          in
          if failed == [ ] then
            pkgs.runCommand "port-conflicts-check" { } ''
              echo "═══════════════════════════════════════════════════════════════"
              echo "Port Conflict Check - PASSED"
              echo "═══════════════════════════════════════════════════════════════"
              echo ""
              echo "Total ports defined: ${toString (builtins.length cfg.flatPorts)}"
              echo "No duplicate port assignments detected."
              echo ""
              echo "✓ All port assignments are unique"
              touch $out
            ''
          else
            throw (builtins.concatStringsSep "\n" (map (a: a.message) failed));

        # ═══════════════════════════════════════════════════════════════════════════
        # Comprehensive AI CLI Configuration Validation
        # All assertions are BLOCKING - failures exit non-zero
        # ═══════════════════════════════════════════════════════════════════════════
        ai-cli-config =
          pkgs.runCommand "ai-cli-config-check"
            {
              nativeBuildInputs = [
                pkgs.jq
                pkgs.gnused
                pkgs.gawk
                pkgs.coreutils
                pkgs.ripgrep
                pkgs.fd
                pkgs.eza
              ];
              src = ../.;
            }
            ''
              cd $src
              TESTS_PASSED=0
              TESTS_TOTAL=0

              # Helper functions (POSIX-compatible)
              assert_pass() {
                TESTS_PASSED=$((TESTS_PASSED + 1))
                TESTS_TOTAL=$((TESTS_TOTAL + 1))
                echo "✓ $1"
              }
              assert_fail() {
                TESTS_TOTAL=$((TESTS_TOTAL + 1))
                echo "✗ ERROR: $1"
                exit 1
              }

              echo "═══════════════════════════════════════════════════════════════"
              echo "AI CLI Configuration Tests - BLOCKING MODE"
              echo "═══════════════════════════════════════════════════════════════"

              # ─────────────────────────────────────────────────────────────────────
              # Test 1: Generated Skills Validation
              # Skills are generated by Quality System into config/quality/generated/skills/
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 1: Generated Skills Validation ───"

              SKILLS_DIR="config/quality/generated/skills"

              # Assertion: Skills directory exists
              if [ ! -d "$SKILLS_DIR" ]; then
                assert_fail "Generated skills directory missing: $SKILLS_DIR"
              fi
              assert_pass "Generated skills directory exists"

              # Get skills count
              SKILLS_COUNT=$(${pkgs.eza}/bin/eza --oneline "$SKILLS_DIR" | wc -l | tr -d ' ')

              # Assertion: At least 5 skills exist
              if [ "$SKILLS_COUNT" -lt 5 ]; then
                assert_fail "Too few generated skills: $SKILLS_COUNT (expected >= 5)"
              fi
              assert_pass "Generated skills count: $SKILLS_COUNT"

              # Assertion: Each skill has SKILL.md
              for skill in "$SKILLS_DIR"/*/; do
                skill_name=$(basename "$skill")
                if [ ! -f "$skill/SKILL.md" ]; then
                  assert_fail "Missing SKILL.md in generated skill: $skill_name"
                fi
                assert_pass "Generated skill $skill_name has SKILL.md"
              done

              # ─────────────────────────────────────────────────────────────────────
              # Test 2: MCP Servers Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 2: MCP Servers Validation ───"

              # Extract MCP server names (portable)
              MCP_SERVERS=$(awk '/mcpServerDefs = \{/,/^  \};/' modules/home/apps/claude.nix | \
                sed -n '/^    [a-z].*= {$/p' | sed -E 's/^    ([a-z0-9-]+) =.*/\1/' | sort)
              MCP_COUNT=$(echo "$MCP_SERVERS" | wc -l | tr -d ' ')

              # Assertion: Required servers exist
              for server in context7 fetch repomix github; do
                if echo "$MCP_SERVERS" | ${pkgs.ripgrep}/bin/rg -q "^$server$"; then
                  assert_pass "Required MCP server: $server"
                else
                  assert_fail "Required MCP server MISSING: $server"
                fi
              done

              # Assertion: MCP count is reasonable (at least 5)
              if [ "$MCP_COUNT" -lt 5 ]; then
                assert_fail "Too few MCP servers: $MCP_COUNT (expected >= 5)"
              fi
              assert_pass "MCP server count: $MCP_COUNT"

              # ─────────────────────────────────────────────────────────────────────
              # Test 3: Settings JSON Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 3: Settings JSON Validation ───"

              SETTINGS="config/quality/generated/settings.json"

              # Assertion: JSON is valid
              if ! ${pkgs.jq}/bin/jq empty "$SETTINGS" 2>/dev/null; then
                assert_fail "Invalid JSON syntax in $SETTINGS"
              fi
              assert_pass "claude-code.json is valid JSON"

              # Assertion: hooks field exists
              if ! ${pkgs.jq}/bin/jq -e '.hooks' "$SETTINGS" >/dev/null 2>&1; then
                assert_fail "Missing 'hooks' field in settings"
              fi
              assert_pass "hooks field present"

              # Assertion: permissions field exists
              if ! ${pkgs.jq}/bin/jq -e '.permissions' "$SETTINGS" >/dev/null 2>&1; then
                assert_fail "Missing 'permissions' field in settings"
              fi
              assert_pass "permissions field present"

              # Assertion: permissions.allow is non-empty array
              ALLOW_COUNT=$(${pkgs.jq}/bin/jq '.permissions.allow | length' "$SETTINGS" 2>/dev/null)
              if [ "$ALLOW_COUNT" -lt 5 ]; then
                assert_fail "permissions.allow too small: $ALLOW_COUNT (expected >= 5)"
              fi
              assert_pass "permissions.allow has $ALLOW_COUNT entries"

              # Assertion: permissions.deny exists
              DENY_COUNT=$(${pkgs.jq}/bin/jq '.permissions.deny | length' "$SETTINGS" 2>/dev/null)
              if [ "$DENY_COUNT" -lt 3 ]; then
                assert_fail "permissions.deny too small: $DENY_COUNT (expected >= 3)"
              fi
              assert_pass "permissions.deny has $DENY_COUNT entries"

              # Assertion: All hook types defined
              for hook_type in PreToolUse PostToolUse SessionStart Stop; do
                if ${pkgs.jq}/bin/jq -e ".hooks.$hook_type" "$SETTINGS" >/dev/null 2>&1; then
                  assert_pass "Hook type defined: $hook_type"
                else
                  assert_fail "Missing hook type: $hook_type"
                fi
              done

              # ─────────────────────────────────────────────────────────────────────
              # Test 4: Hook Files Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 4: Hook Files Validation ───"

              # Extract hook files referenced in settings (modern: rg)
              REFERENCED_HOOKS=$(${pkgs.jq}/bin/jq -r '.. | .command? // empty' "$SETTINGS" 2>/dev/null | \
                ${pkgs.ripgrep}/bin/rg 'hooks/' | sed -E 's/.*hooks\/([a-zA-Z0-9_-]+\.(ts|sh)).*/\1/' | sort | uniq)

              for hook in $REFERENCED_HOOKS; do
                if [ -f "config/quality/src/hooks/$hook" ]; then
                  assert_pass "Hook exists: $hook"
                else
                  assert_fail "Hook MISSING: $hook"
                fi

                # Assertion: Hook is not empty
                if [ ! -s "config/quality/src/hooks/$hook" ]; then
                  assert_fail "Hook is empty: $hook"
                fi
                assert_pass "Hook not empty: $hook"
              done

              # ─────────────────────────────────────────────────────────────────────
              # Test 5: Agent Definitions Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 5: Agent Definitions Validation ───"

              AGENT_COUNT=0
              for agent in config/agents/agents/*.md; do
                if [ -f "$agent" ]; then
                  agent_name=$(basename "$agent")
                  AGENT_COUNT=$((AGENT_COUNT + 1))

                  # Assertion: name field exists
                  if ! ${pkgs.ripgrep}/bin/rg -q "^name:" "$agent"; then
                    assert_fail "$agent_name missing 'name:' field"
                  fi
                  assert_pass "$agent_name has 'name:' field"

                  # Assertion: description field exists
                  if ! ${pkgs.ripgrep}/bin/rg -q "^description:" "$agent"; then
                    assert_fail "$agent_name missing 'description:' field"
                  fi
                  assert_pass "$agent_name has 'description:' field"
                fi
              done

              # Assertion: At least some agents exist
              if [ "$AGENT_COUNT" -lt 3 ]; then
                assert_fail "Too few agents: $AGENT_COUNT (expected >= 3)"
              fi
              assert_pass "Agent count: $AGENT_COUNT"

              # ─────────────────────────────────────────────────────────────────────
              # Test 6: Commands Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 6: Commands Validation ───"

              CMD_COUNT=0
              for cmd in config/agents/commands/*.md; do
                if [ -f "$cmd" ]; then
                  cmd_name=$(basename "$cmd")
                  CMD_COUNT=$((CMD_COUNT + 1))

                  # Assertion: Command is not empty
                  if [ ! -s "$cmd" ]; then
                    assert_fail "Empty command file: $cmd_name"
                  fi
                  assert_pass "$cmd_name is not empty"
                fi
              done

              # Assertion: At least some commands exist
              if [ "$CMD_COUNT" -lt 3 ]; then
                assert_fail "Too few commands: $CMD_COUNT (expected >= 3)"
              fi
              assert_pass "Command count: $CMD_COUNT"

              # ─────────────────────────────────────────────────────────────────────
              # Test 7: Nix Module Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 7: Nix Module Validation ───"

              # Assertion: agents.nix exists
              if [ ! -f "config/agents/nix/agents.nix" ]; then
                assert_fail "Missing config/agents/nix/agents.nix"
              fi
              assert_pass "agents.nix exists"

              # Assertion: claude.nix exists
              if [ ! -f "modules/home/apps/claude.nix" ]; then
                assert_fail "Missing modules/home/apps/claude.nix"
              fi
              assert_pass "claude.nix exists"

              # Assertion: secrets.nix exists
              if [ ! -f "modules/darwin/secrets.nix" ]; then
                assert_fail "Missing modules/darwin/secrets.nix"
              fi
              assert_pass "secrets.nix exists"

              # ─────────────────────────────────────────────────────────────────────
              # Coverage Report
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              echo "Coverage Report"
              echo "═══════════════════════════════════════════════════════════════"

              # Calculate coverage
              COVERAGE=$((TESTS_PASSED * 100 / TESTS_TOTAL))

              echo ""
              echo "Tests passed: $TESTS_PASSED / $TESTS_TOTAL"
              echo "Coverage: $COVERAGE%"
              echo ""

              # ─────────────────────────────────────────────────────────────────────
              # Summary
              # ─────────────────────────────────────────────────────────────────────
              echo "─── Inventory ───"
              echo "Skills:   $SKILLS_COUNT generated"
              echo "MCP:      $MCP_COUNT servers"
              echo "Agents:   $AGENT_COUNT definitions"
              echo "Commands: $CMD_COUNT commands"
              echo "Hooks:    $(echo "$REFERENCED_HOOKS" | wc -w | tr -d ' ') referenced"
              echo ""

              # Block if coverage drops below 90%
              if [ "$COVERAGE" -lt 90 ]; then
                echo "ERROR: Coverage $COVERAGE% is below 90% threshold"
                exit 1
              fi

              echo "✓ All AI CLI config checks passed ($COVERAGE% coverage)"
              touch $out
            '';
      };
    };
}

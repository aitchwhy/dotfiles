# Custom checks - AI CLI configuration validation with coverage reporting
# All tests are blocking - failures prevent builds
{ ... }:
{
  perSystem =
    { pkgs, ... }:
    {
      checks = {
        # ═══════════════════════════════════════════════════════════════════════════
        # Quality System TypeScript Validation
        # Validates the Quality System TypeScript code compiles correctly
        # ═══════════════════════════════════════════════════════════════════════════
        quality-typecheck =
          pkgs.runCommand "quality-typecheck"
            {
              nativeBuildInputs = [ pkgs.bun ];
              src = ../.;
            }
            ''
              # Copy source to writable directory
              cp -r $src/config/quality $TMPDIR/quality
              chmod -R u+w $TMPDIR/quality
              cd $TMPDIR/quality

              # Bun needs writable directories
              export HOME="$TMPDIR/home"
              mkdir -p "$HOME"

              echo "═══════════════════════════════════════════════════════════════"
              echo "Quality System TypeCheck"
              echo "═══════════════════════════════════════════════════════════════"

              # Install dependencies (frozen lockfile ensures reproducibility)
              ${pkgs.bun}/bin/bun install --frozen-lockfile

              # Run typecheck
              ${pkgs.bun}/bin/bun x tsc --noEmit

              echo ""
              echo "✓ Quality System TypeScript validation passed"
              touch $out
            '';

        # ═══════════════════════════════════════════════════════════════════════════
        # Port Conflict Detection
        # Validates lib/config/ports.nix has no duplicate port assignments
        # ═══════════════════════════════════════════════════════════════════════════
        port-conflicts =
          let
            cfg = import ../lib/config { inherit (pkgs) lib; };
            failed = builtins.filter (a: !a.assertion) cfg.assertions;
          in
          if failed == [ ] then
            pkgs.runCommand "port-conflicts-check" { } ''
              echo "═══════════════════════════════════════════════════════════════"
              echo "Port Conflict Check - PASSED"
              echo "═══════════════════════════════════════════════════════════════"
              echo ""
              echo "Total ports defined: ${toString (builtins.length cfg.flatPorts)}"
              echo "No duplicate port assignments detected."
              echo ""
              echo "✓ All port assignments are unique"
              touch $out
            ''
          else
            throw (builtins.concatStringsSep "\n" (map (a: a.message) failed));

        # ═══════════════════════════════════════════════════════════════════════════
        # Comprehensive AI CLI Configuration Validation
        # All assertions are BLOCKING - failures exit non-zero
        # ═══════════════════════════════════════════════════════════════════════════
        ai-cli-config =
          pkgs.runCommand "ai-cli-config-check"
            {
              nativeBuildInputs = [
                pkgs.jq
                pkgs.gnused
                pkgs.gawk
                pkgs.coreutils
                pkgs.ripgrep
                pkgs.fd
                pkgs.eza
              ];
              src = ../.;
            }
            ''
              cd $src
              TESTS_PASSED=0
              TESTS_TOTAL=0

              # Helper functions (POSIX-compatible)
              assert_pass() {
                TESTS_PASSED=$((TESTS_PASSED + 1))
                TESTS_TOTAL=$((TESTS_TOTAL + 1))
                echo "✓ $1"
              }
              assert_fail() {
                TESTS_TOTAL=$((TESTS_TOTAL + 1))
                echo "✗ ERROR: $1"
                exit 1
              }

              echo "═══════════════════════════════════════════════════════════════"
              echo "AI CLI Configuration Tests - BLOCKING MODE"
              echo "═══════════════════════════════════════════════════════════════"

              # ─────────────────────────────────────────────────────────────────────
              # Test 1: Generated Skills Validation
              # Skills are generated by Quality System into config/quality/generated/skills/
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 1: Generated Skills Validation ───"

              SKILLS_DIR="config/quality/generated/skills"

              # Assertion: Skills directory exists
              if [ ! -d "$SKILLS_DIR" ]; then
                assert_fail "Generated skills directory missing: $SKILLS_DIR"
              fi
              assert_pass "Generated skills directory exists"

              # Get skills count
              SKILLS_COUNT=$(${pkgs.eza}/bin/eza --oneline "$SKILLS_DIR" | wc -l | tr -d ' ')

              # Assertion: At least 5 skills exist
              if [ "$SKILLS_COUNT" -lt 5 ]; then
                assert_fail "Too few generated skills: $SKILLS_COUNT (expected >= 5)"
              fi
              assert_pass "Generated skills count: $SKILLS_COUNT"

              # Assertion: Each skill has SKILL.md
              for skill in "$SKILLS_DIR"/*/; do
                skill_name=$(basename "$skill")
                if [ ! -f "$skill/SKILL.md" ]; then
                  assert_fail "Missing SKILL.md in generated skill: $skill_name"
                fi
                assert_pass "Generated skill $skill_name has SKILL.md"
              done

              # ─────────────────────────────────────────────────────────────────────
              # Test 2: MCP Servers Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 2: MCP Servers Validation ───"

              # Extract MCP server names (portable)
              MCP_SERVERS=$(awk '/mcpServerDefs = \{/,/^  \};/' modules/home/apps/claude.nix | \
                sed -n '/^    [a-z].*= {$/p' | sed -E 's/^    ([a-z0-9-]+) =.*/\1/' | sort)
              MCP_COUNT=$(echo "$MCP_SERVERS" | wc -l | tr -d ' ')

              # Assertion: Required servers exist
              for server in context7 fetch repomix github; do
                if echo "$MCP_SERVERS" | ${pkgs.ripgrep}/bin/rg -q "^$server$"; then
                  assert_pass "Required MCP server: $server"
                else
                  assert_fail "Required MCP server MISSING: $server"
                fi
              done

              # Assertion: MCP count is reasonable (at least 5)
              if [ "$MCP_COUNT" -lt 5 ]; then
                assert_fail "Too few MCP servers: $MCP_COUNT (expected >= 5)"
              fi
              assert_pass "MCP server count: $MCP_COUNT"

              # ─────────────────────────────────────────────────────────────────────
              # Test 3: Settings JSON Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 3: Settings JSON Validation ───"

              SETTINGS="config/quality/generated/settings.json"

              # Assertion: JSON is valid
              if ! ${pkgs.jq}/bin/jq empty "$SETTINGS"; then
                assert_fail "Invalid JSON syntax in $SETTINGS"
              fi
              assert_pass "claude-code.json is valid JSON"

              # Assertion: hooks field exists
              if ! ${pkgs.jq}/bin/jq -e '.hooks' "$SETTINGS" >/dev/null; then
                assert_fail "Missing 'hooks' field in settings"
              fi
              assert_pass "hooks field present"

              # Assertion: permissions field exists
              if ! ${pkgs.jq}/bin/jq -e '.permissions' "$SETTINGS" >/dev/null; then
                assert_fail "Missing 'permissions' field in settings"
              fi
              assert_pass "permissions field present"

              # Assertion: permissions.allow is non-empty array
              ALLOW_COUNT=$(${pkgs.jq}/bin/jq '.permissions.allow | length' "$SETTINGS")
              if [ "$ALLOW_COUNT" -lt 5 ]; then
                assert_fail "permissions.allow too small: $ALLOW_COUNT (expected >= 5)"
              fi
              assert_pass "permissions.allow has $ALLOW_COUNT entries"

              # Assertion: permissions.deny exists
              DENY_COUNT=$(${pkgs.jq}/bin/jq '.permissions.deny | length' "$SETTINGS")
              if [ "$DENY_COUNT" -lt 3 ]; then
                assert_fail "permissions.deny too small: $DENY_COUNT (expected >= 3)"
              fi
              assert_pass "permissions.deny has $DENY_COUNT entries"

              # Assertion: All hook types defined
              for hook_type in PreToolUse PostToolUse SessionStart Stop; do
                if ${pkgs.jq}/bin/jq -e ".hooks.$hook_type" "$SETTINGS" >/dev/null; then
                  assert_pass "Hook type defined: $hook_type"
                else
                  assert_fail "Missing hook type: $hook_type"
                fi
              done

              # ─────────────────────────────────────────────────────────────────────
              # Test 4: Hook Files Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 4: Hook Files Validation ───"

              # Extract hook files referenced in settings (modern: rg)
              REFERENCED_HOOKS=$(${pkgs.jq}/bin/jq -r '.. | .command? // empty' "$SETTINGS" | \
                ${pkgs.ripgrep}/bin/rg 'hooks/' | sed -E 's/.*hooks\/([a-zA-Z0-9_-]+\.(ts|sh)).*/\1/' | sort | uniq)

              for hook in $REFERENCED_HOOKS; do
                if [ -f "config/quality/src/hooks/$hook" ]; then
                  assert_pass "Hook exists: $hook"
                else
                  assert_fail "Hook MISSING: $hook"
                fi

                # Assertion: Hook is not empty
                if [ ! -s "config/quality/src/hooks/$hook" ]; then
                  assert_fail "Hook is empty: $hook"
                fi
                assert_pass "Hook not empty: $hook"
              done

              # ─────────────────────────────────────────────────────────────────────
              # Test 5: Agent Definitions Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 5: Agent Definitions Validation ───"

              AGENT_COUNT=0
              for agent in config/agents/agents/*.md; do
                if [ -f "$agent" ]; then
                  agent_name=$(basename "$agent")
                  AGENT_COUNT=$((AGENT_COUNT + 1))

                  # Assertion: name field exists
                  if ! ${pkgs.ripgrep}/bin/rg -q "^name:" "$agent"; then
                    assert_fail "$agent_name missing 'name:' field"
                  fi
                  assert_pass "$agent_name has 'name:' field"

                  # Assertion: description field exists
                  if ! ${pkgs.ripgrep}/bin/rg -q "^description:" "$agent"; then
                    assert_fail "$agent_name missing 'description:' field"
                  fi
                  assert_pass "$agent_name has 'description:' field"
                fi
              done

              # Assertion: At least some agents exist
              if [ "$AGENT_COUNT" -lt 3 ]; then
                assert_fail "Too few agents: $AGENT_COUNT (expected >= 3)"
              fi
              assert_pass "Agent count: $AGENT_COUNT"

              # ─────────────────────────────────────────────────────────────────────
              # Test 6: Commands Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 6: Commands Validation ───"

              CMD_COUNT=0
              for cmd in config/agents/commands/*.md; do
                if [ -f "$cmd" ]; then
                  cmd_name=$(basename "$cmd")
                  CMD_COUNT=$((CMD_COUNT + 1))

                  # Assertion: Command is not empty
                  if [ ! -s "$cmd" ]; then
                    assert_fail "Empty command file: $cmd_name"
                  fi
                  assert_pass "$cmd_name is not empty"
                fi
              done

              # Assertion: At least some commands exist
              if [ "$CMD_COUNT" -lt 3 ]; then
                assert_fail "Too few commands: $CMD_COUNT (expected >= 3)"
              fi
              assert_pass "Command count: $CMD_COUNT"

              # ─────────────────────────────────────────────────────────────────────
              # Test 7: Nix Module Validation
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "─── Test 7: Nix Module Validation ───"

              # Assertion: agents.nix exists
              if [ ! -f "config/agents/nix/agents.nix" ]; then
                assert_fail "Missing config/agents/nix/agents.nix"
              fi
              assert_pass "agents.nix exists"

              # Assertion: claude.nix exists
              if [ ! -f "modules/home/apps/claude.nix" ]; then
                assert_fail "Missing modules/home/apps/claude.nix"
              fi
              assert_pass "claude.nix exists"

              # Assertion: secrets.nix exists
              if [ ! -f "modules/darwin/secrets.nix" ]; then
                assert_fail "Missing modules/darwin/secrets.nix"
              fi
              assert_pass "secrets.nix exists"

              # ─────────────────────────────────────────────────────────────────────
              # Coverage Report
              # ─────────────────────────────────────────────────────────────────────
              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              echo "Coverage Report"
              echo "═══════════════════════════════════════════════════════════════"

              # Calculate coverage
              COVERAGE=$((TESTS_PASSED * 100 / TESTS_TOTAL))

              echo ""
              echo "Tests passed: $TESTS_PASSED / $TESTS_TOTAL"
              echo "Coverage: $COVERAGE%"
              echo ""

              # ─────────────────────────────────────────────────────────────────────
              # Summary
              # ─────────────────────────────────────────────────────────────────────
              echo "─── Inventory ───"
              echo "Skills:   $SKILLS_COUNT generated"
              echo "MCP:      $MCP_COUNT servers"
              echo "Agents:   $AGENT_COUNT definitions"
              echo "Commands: $CMD_COUNT commands"
              echo "Hooks:    $(echo "$REFERENCED_HOOKS" | wc -w | tr -d ' ') referenced"
              echo ""

              # Block if coverage drops below 90%
              if [ "$COVERAGE" -lt 90 ]; then
                echo "ERROR: Coverage $COVERAGE% is below 90% threshold"
                exit 1
              fi

              echo "✓ All AI CLI config checks passed ($COVERAGE% coverage)"
              touch $out
            '';

        # ═══════════════════════════════════════════════════════════════════════════
        # Neovim Configuration Validation
        # Validates Lua syntax of all Neovim configuration files
        # ═══════════════════════════════════════════════════════════════════════════
        neovim-config =
          pkgs.runCommand "neovim-config-check"
            {
              nativeBuildInputs = [
                pkgs.luajit
                pkgs.fd
              ];
              src = ../.;
            }
            ''
              cd $src

              echo "═══════════════════════════════════════════════════════════════"
              echo "Neovim Configuration Validation"
              echo "═══════════════════════════════════════════════════════════════"

              ERRORS=0
              TOTAL=0

              echo ""
              echo "─── Lua Syntax Validation ───"

              # Check all Lua files in config/nvim/lua/
              for file in $(${pkgs.fd}/bin/fd -e lua . config/nvim/lua/); do
                TOTAL=$((TOTAL + 1))
                if ${pkgs.luajit}/bin/luajit -bl "$file" /dev/null; then
                  echo "✓ $file"
                else
                  echo "✗ SYNTAX ERROR: $file"
                  ERRORS=$((ERRORS + 1))
                fi
              done

              echo ""
              echo "─── Test Files Validation ───"

              # Check test files (directory may not exist in all configurations)
              if [ -d "config/nvim/tests" ]; then
                for file in $(${pkgs.fd}/bin/fd -e lua . config/nvim/tests/); do
                  TOTAL=$((TOTAL + 1))
                  if ${pkgs.luajit}/bin/luajit -bl "$file" /dev/null; then
                    echo "✓ $file"
                  else
                    echo "✗ SYNTAX ERROR: $file"
                    ERRORS=$((ERRORS + 1))
                  fi
                done
              fi

              echo ""
              echo "─── Mason Configuration Check ───"

              # Verify Mason only has debug adapters (no linters)
              if grep -qE '"(markdownlint|yamllint|hadolint|sqlfluff)"' config/nvim/lua/plugins/mason.lua; then
                echo "✗ Mason contains linters that should be in Nix"
                ERRORS=$((ERRORS + 1))
              else
                echo "✓ Mason correctly limited to debug adapters"
              fi
              TOTAL=$((TOTAL + 1))

              echo ""
              echo "─── Nix LSP Override Check ───"

              # Verify lang-nix.lua exists and disables nil_ls
              if [ -f "config/nvim/lua/plugins/lang-nix.lua" ]; then
                if grep -q "nil_ls = false" config/nvim/lua/plugins/lang-nix.lua; then
                  echo "✓ nil_ls correctly disabled in lang-nix.lua"
                else
                  echo "✗ nil_ls not disabled in lang-nix.lua"
                  ERRORS=$((ERRORS + 1))
                fi
                if grep -q "nixd" config/nvim/lua/plugins/lang-nix.lua; then
                  echo "✓ nixd configured in lang-nix.lua"
                else
                  echo "✗ nixd not configured in lang-nix.lua"
                  ERRORS=$((ERRORS + 1))
                fi
              else
                echo "✗ lang-nix.lua not found"
                ERRORS=$((ERRORS + 1))
              fi
              TOTAL=$((TOTAL + 2))

              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              echo "Summary: $((TOTAL - ERRORS)) / $TOTAL checks passed"
              echo "═══════════════════════════════════════════════════════════════"

              if [ "$ERRORS" -gt 0 ]; then
                echo "✗ $ERRORS error(s) found"
                exit 1
              fi

              echo "✓ All Neovim configuration checks passed"
              touch $out
            '';
      };
    };
}

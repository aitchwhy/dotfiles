# AI tools justfile
# Usage: just ai [command]
# Version: 2.0.0

# Set shell to zsh for all recipes
set shell := ["zsh", "-cu"]

# Enable colorful output
set dotenv-load
set positional-arguments

# Shared constants
AI_CONFIG_DIR := env_var_or_default("AI_CONFIG_DIR", "{{justfile_directory()}}")
PROMPTS_DIR := env_var_or_default("PROMPTS_DIR", "{{AI_CONFIG_DIR}}/prompts")
MODELS := {
    "claude": "claude-3-7-sonnet-20250219",
    "claude-opus": "claude-3-opus-20240229",
    "claude-haiku": "claude-3-haiku-20240307",
    "gpt4": "gpt-4-turbo-2024-04-09",
    "gpt3.5": "gpt-3.5-turbo-0125",
    "gemini-pro": "gemini-pro",
    "mixtral": "mixtral-8x7b-32768"
}

# Default recipe for this namespace
_default:
    #!/usr/bin/env zsh
    echo "\033[1;36m=== AI Tools - Intelligent Coding Workflows ===\033[0m"
    echo "\033[1;33mLanguage-specific commands:\033[0m"
    {{just_executable()}} --list --unsorted | grep -E "^ai:(typescript|python|shell|nix)" | sort | sed 's/^ai:/  /'
    
    echo "\n\033[1;33mLLM Provider commands:\033[0m"
    {{just_executable()}} --list --unsorted | grep -E "^ai:(claude|gpt|gemini)" | grep -v "history" | sort | sed 's/^ai:/  /'
    
    echo "\n\033[1;33mIDE Integration commands:\033[0m"
    {{just_executable()}} --list --unsorted | grep -E "^ai:(cursor|ghostty)" | sort | sed 's/^ai:/  /'
    
    echo "\n\033[1;33mUtility commands:\033[0m"
    {{just_executable()}} --list --unsorted | 
    grep -E "^ai:" | 
    grep -v -E "(typescript|python|shell|nix|claude|gpt|gemini|cursor|ghostty|run)" | 
    sort | 
    sed 's/^ai:/  /'
    
    echo "\n\033[1;33mFor advanced AI-powered operations:\033[0m"
    echo "  Run 'just ai run' to see available AI execution commands"

# ----------------------------------------------------------
# Claude CLI operations 
# ----------------------------------------------------------
[namespace=claude]

# Retrieve Claude Code conversation history directly from SQLite database
history *args="5":
    #!/usr/bin/env zsh
    echo "=== Claude Code Conversation History ==="
    echo "Retrieving {{args}} most recent conversations..."
    
    # Environment setup
    CLAUDE_DB="$HOME/.claude/__store.db"
    
    if [ ! -f "$CLAUDE_DB" ]; then
        echo "Error: Claude database not found at $CLAUDE_DB"
        exit 1
    fi
    
    # Get conversation summaries
    echo "\nRecent conversations:"
    sqlite3 "$CLAUDE_DB" "
    SELECT 
        strftime('%Y-%m-%d %H:%M', s.updated_at/1000, 'unixepoch', 'localtime') as date,
        b.session_id as session_id,
        s.summary as summary
    FROM 
        conversation_summaries s
    JOIN 
        base_messages b ON s.leaf_uuid = b.uuid
    ORDER BY 
        s.updated_at DESC
    LIMIT {{args}};" | column -t -s'|'
    
    # Instructions for exploring details
    echo "\nTo view specific conversation, use:"
    echo "just claude conversation-details <session_id>"

# View detailed history for a specific conversation
conversation-details session_id:
    #!/usr/bin/env zsh
    echo "=== Conversation Details for {{session_id}} ==="
    
    # Environment setup
    CLAUDE_DB="$HOME/.claude/__store.db"
    
    if [ ! -f "$CLAUDE_DB" ]; then
        echo "Error: Claude database not found at $CLAUDE_DB"
        exit 1
    fi
    
    # Check if session exists
    SESSION_CHECK=$(sqlite3 "$CLAUDE_DB" "SELECT COUNT(*) FROM base_messages WHERE session_id = '{{session_id}}';")
    if [ "$SESSION_CHECK" -eq 0 ]; then
        echo "Error: No conversation found with session ID {{session_id}}"
        exit 1
    fi
    
    # Get conversation summary
    echo "\nSummary:"
    sqlite3 "$CLAUDE_DB" "
    SELECT 
        s.summary
    FROM 
        conversation_summaries s
    JOIN 
        base_messages b ON s.leaf_uuid = b.uuid
    WHERE 
        b.session_id = '{{session_id}}'
    LIMIT 1;"
    
    # Get user messages
    echo "\nUser messages:"
    sqlite3 "$CLAUDE_DB" "
    SELECT 
        strftime('%Y-%m-%d %H:%M', u.timestamp/1000, 'unixepoch', 'localtime') as time,
        json_extract(u.message, '$.content[0].content') as message
    FROM 
        user_messages u
    JOIN 
        base_messages b ON u.uuid = b.uuid
    WHERE 
        b.session_id = '{{session_id}}'
    AND
        json_type(u.message, '$.content[0].content') = 'text'
    ORDER BY 
        u.timestamp ASC;"
    
    # Get assistant messages
    echo "\nAssistant messages:"
    sqlite3 "$CLAUDE_DB" "
    SELECT 
        strftime('%Y-%m-%d %H:%M', a.timestamp/1000, 'unixepoch', 'localtime') as time,
        json_extract(a.message, '$.content[0].text') as message
    FROM 
        assistant_messages a
    JOIN 
        base_messages b ON a.uuid = b.uuid
    WHERE 
        b.session_id = '{{session_id}}'
    AND
        json_extract(a.message, '$.content[0].text') IS NOT NULL
    ORDER BY 
        a.timestamp ASC;"

# Export conversation history to markdown file
export-conversation session_id:
    #!/usr/bin/env zsh
    echo "=== Exporting Conversation {{session_id}} ==="
    
    # Environment setup
    CLAUDE_DB="$HOME/.claude/__store.db"
    LOGS_DIR="$PWD/.logs"
    TIMESTAMP=$(date +"%Y-%m-%d")
    OUTPUT_FILE="$LOGS_DIR/$TIMESTAMP-claude-conversation.md"
    
    # Create logs directory if it doesn't exist
    mkdir -p "$LOGS_DIR"
    
    # Check if session exists
    SESSION_CHECK=$(sqlite3 "$CLAUDE_DB" "SELECT COUNT(*) FROM base_messages WHERE session_id = '{{session_id}}';")
    if [ "$SESSION_CHECK" -eq 0 ]; then
        echo "Error: No conversation found with session ID {{session_id}}"
        exit 1
    fi
    
    # Get conversation summary
    SUMMARY=$(sqlite3 "$CLAUDE_DB" "
    SELECT 
        s.summary
    FROM 
        conversation_summaries s
    JOIN 
        base_messages b ON s.leaf_uuid = b.uuid
    WHERE 
        b.session_id = '{{session_id}}'
    LIMIT 1;")
    
    # Create markdown file with header
    cat > "$OUTPUT_FILE" << EOL
# Claude Code Conversation - $TIMESTAMP

## $SUMMARY

This document contains the conversation history from Claude Code session '{{session_id}}'.

EOL
    
    # Add conversation content - interleaved user and assistant messages
    sqlite3 "$CLAUDE_DB" "
    SELECT 
        'user' as role,
        strftime('%Y-%m-%d %H:%M', u.timestamp/1000, 'unixepoch', 'localtime') as time,
        json_extract(u.message, '$.content[0].content') as content,
        u.timestamp as ts
    FROM 
        user_messages u
    JOIN 
        base_messages b ON u.uuid = b.uuid
    WHERE 
        b.session_id = '{{session_id}}'
    AND
        json_type(u.message, '$.content[0].content') = 'text'
    UNION ALL
    SELECT 
        'assistant' as role,
        strftime('%Y-%m-%d %H:%M', a.timestamp/1000, 'unixepoch', 'localtime') as time,
        json_extract(a.message, '$.content[0].text') as content,
        a.timestamp as ts
    FROM 
        assistant_messages a
    JOIN 
        base_messages b ON a.uuid = b.uuid
    WHERE 
        b.session_id = '{{session_id}}'
    AND
        json_extract(a.message, '$.content[0].text') IS NOT NULL
    ORDER BY 
        ts ASC;" | while IFS='|' read -r role time content _; do
        if [ "$role" = "user" ]; then
            echo -e "\n### User ($time)\n\n$content\n" >> "$OUTPUT_FILE"
        else
            echo -e "\n### Claude ($time)\n\n$content\n" >> "$OUTPUT_FILE"
        fi
    done
    
    echo "Conversation exported to $OUTPUT_FILE"
    echo "To view it, run: glow \"$OUTPUT_FILE\""

# View conversation database location and schema
db-info:
    #!/usr/bin/env zsh
    echo "=== Claude Code Database Information ==="
    
    # Environment setup
    CLAUDE_DB="$HOME/.claude/__store.db"
    
    if [ ! -f "$CLAUDE_DB" ]; then
        echo "Error: Claude database not found at $CLAUDE_DB"
        exit 1
    fi
    
    echo "Database location: $CLAUDE_DB"
    echo "Database type: $(file "$CLAUDE_DB" | cut -d: -f2-)"
    echo "\nTables in database:"
    sqlite3 "$CLAUDE_DB" ".tables"
    
    # Show schemas for the main tables
    echo "\nSchema for base_messages:"
    sqlite3 "$CLAUDE_DB" ".schema base_messages"
    
    echo "\nSchema for user_messages:"
    sqlite3 "$CLAUDE_DB" ".schema user_messages"
    
    echo "\nSchema for assistant_messages:"
    sqlite3 "$CLAUDE_DB" ".schema assistant_messages"
    
    echo "\nSchema for conversation_summaries:"
    sqlite3 "$CLAUDE_DB" ".schema conversation_summaries"

# ----------------------------------------------------------
# Core AI development workflows
# ----------------------------------------------------------
[namespace=ai]

# Generate code using Claude
code language prompt:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude"]}}"
    echo "\033[1;36m=== Generating {{language}} code with Claude ===\033[0m"
    echo "\033[1;33mPrompt:\033[0m {{prompt}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Select appropriate prompt template based on language
    TEMPLATE="${{PROMPTS_DIR}}/{{language}}-template.md"
    if [ ! -f "$TEMPLATE" ]; then
        # Use default template if language-specific one doesn't exist
        TEMPLATE="${{PROMPTS_DIR}}/code-template.md"
        if [ ! -f "$TEMPLATE" ]; then
            # Create minimal template if none exists
            mkdir -p "{{PROMPTS_DIR}}"
            cat > "$TEMPLATE" << EOL
# Code Generation Template

You are an expert {{language}} developer. Create well-documented, efficient, and idiomatic code based on the following request:

{{request}}

Guidelines:
- Make the code clean, readable, and maintainable
- Include appropriate error handling
- Follow modern {{language}} best practices
- Add comments to explain complex logic
- If appropriate, include example usage
EOL
        fi
    fi
    
    # Replace placeholder with actual prompt
    PROMPT_CONTENT=$(cat "$TEMPLATE" | sed "s/{{request}}/{{prompt}}/g")
    
    # Generate code with Claude
    claude --message "$PROMPT_CONTENT" --model "$MODEL" --max-tokens 1500

# Execute AI-assisted code review
review file_path:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude"]}}"
    echo "\033[1;36m=== AI Code Review ===\033[0m"
    echo "\033[1;33mReviewing:\033[0m {{file_path}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate file exists
    if [ ! -f "{{file_path}}" ]; then
        echo "\033[1;31mError: File {{file_path}} does not exist.\033[0m"
        exit 1
    fi
    
    # Determine file type and language
    FILE_EXT="${{file_path}##*.}"
    LANGUAGE=""
    
    case "$FILE_EXT" in
        js|jsx|ts|tsx) LANGUAGE="TypeScript/JavaScript" ;;
        py) LANGUAGE="Python" ;;
        rb) LANGUAGE="Ruby" ;;
        go) LANGUAGE="Go" ;;
        rs) LANGUAGE="Rust" ;;
        java) LANGUAGE="Java" ;;
        c|cpp|cc|h|hpp) LANGUAGE="C/C++" ;;
        sh|bash|zsh) LANGUAGE="Shell" ;;
        nix) LANGUAGE="Nix" ;;
        *) LANGUAGE="Unknown" ;;
    esac
    
    # Read file content
    FILE_CONTENT=$(cat "{{file_path}}")
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create review prompt
    REVIEW_PROMPT="You are an expert $LANGUAGE code reviewer. Review the following code and provide:

1. A brief summary of what the code does
2. Potential bugs or edge cases
3. Performance considerations
4. Improvements for readability and maintainability
5. Security concerns if applicable

Format your review as markdown with appropriate headings and code examples when suggesting changes.

CODE TO REVIEW:
\`\`\`$FILE_EXT
$FILE_CONTENT
\`\`\`"
    
    # Generate review with Claude
    claude --message "$REVIEW_PROMPT" --model "$MODEL" --max-tokens 1500

# Generate commit message from git diff
commit-msg:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-haiku"]}}"
    echo "\033[1;36m=== AI Commit Message Generator ===\033[0m"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Get git diff of staged changes
    DIFF=$(git diff --staged)
    
    if [ -z "$DIFF" ]; then
        echo "\033[1;31mNo staged changes found. Stage changes with 'git add' first.\033[0m"
        exit 1
    fi
    
    # Get git status
    STATUS=$(git status --short)
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create prompt for generating commit message
    PROMPT="Generate a concise, informative git commit message for the following changes. 
Follow the Conventional Commits specification (https://www.conventionalcommits.org/).
Format: <type>(<scope>): <description>

Types: feat, fix, docs, style, refactor, test, chore, perf
Scope is optional but should indicate the component being changed
Description should be present tense, lowercase, no period at end

STAGED CHANGES:
$DIFF

STATUS:
$STATUS

Respond ONLY with the commit message, nothing else."
    
    # Generate commit message with Claude
    COMMIT_MSG=$(claude --message "$PROMPT" --model "$MODEL" --max-tokens 100)
    
    # Display the suggested commit message
    echo "\033[1;32mSuggested commit message:\033[0m"
    echo "$COMMIT_MSG"
    
    # Ask if user wants to use this message
    read "REPLY?Use this commit message? [Y/n] "
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        git commit -m "$COMMIT_MSG"
        echo "\033[1;32mCommit created successfully!\033[0m"
    else
        echo "\033[1;33mCommit cancelled.\033[0m"
    fi

# Generate docstrings for code
docstrings file_path:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-haiku"]}}"
    echo "\033[1;36m=== AI Docstring Generator ===\033[0m"
    echo "\033[1;33mProcessing:\033[0m {{file_path}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate file exists
    if [ ! -f "{{file_path}}" ]; then
        echo "\033[1;31mError: File {{file_path}} does not exist.\033[0m"
        exit 1
    fi
    
    # Determine file type and language
    FILE_EXT="${{file_path}##*.}"
    LANGUAGE=""
    
    case "$FILE_EXT" in
        js|jsx|ts|tsx) LANGUAGE="TypeScript/JavaScript" ;;
        py) LANGUAGE="Python" ;;
        rb) LANGUAGE="Ruby" ;;
        go) LANGUAGE="Go" ;;
        rs) LANGUAGE="Rust" ;;
        java) LANGUAGE="Java" ;;
        c|cpp|cc|h|hpp) LANGUAGE="C/C++" ;;
        sh|bash|zsh) LANGUAGE="Shell" ;;
        nix) LANGUAGE="Nix" ;;
        *) LANGUAGE="Unknown" ;;
    esac
    
    # Read file content
    FILE_CONTENT=$(cat "{{file_path}}")
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create docstring prompt
    DOCSTRING_PROMPT="You are an expert $LANGUAGE developer. Add comprehensive, standard docstrings to all functions/methods/classes in the following code. Maintain the existing code exactly as is, just add appropriate docstrings where they're missing.

1. For Python, use Google style docstrings
2. For JavaScript/TypeScript, use JSDoc comments
3. For other languages, use the most common docstring format for that language

Return the entire file with added docstrings. Keep all original code intact - only add docstrings, don't modify anything else.

CODE:
\`\`\`$FILE_EXT
$FILE_CONTENT
\`\`\`"
    
    # Generate docstrings with Claude
    RESULT=$(claude --message "$DOCSTRING_PROMPT" --model "$MODEL" --max-tokens 1500)
    
    # Extract code block with docstrings
    CODE_WITH_DOCSTRINGS=$(echo "$RESULT" | awk '/```/{flag=1;next}/```/{flag=0}flag')
    
    if [ -z "$CODE_WITH_DOCSTRINGS" ]; then
        echo "\033[1;31mError: Couldn't extract code with docstrings from the result.\033[0m"
        echo "Raw result:"
        echo "$RESULT"
        exit 1
    fi
    
    # Display the result
    echo "\033[1;32mCode with docstrings:\033[0m"
    echo "$CODE_WITH_DOCSTRINGS"
    
    # Ask if user wants to update the file
    read "REPLY?Update the file with these docstrings? [Y/n] "
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        echo "$CODE_WITH_DOCSTRINGS" > "{{file_path}}"
        echo "\033[1;32mFile updated successfully!\033[0m"
    else
        echo "\033[1;33mUpdate cancelled.\033[0m"
    fi

# Convert code from one language to another
translate from_file to_language:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude"]}}"
    echo "\033[1;36m=== AI Code Translator ===\033[0m"
    echo "\033[1;33mTranslating:\033[0m {{from_file}} to {{to_language}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate file exists
    if [ ! -f "{{from_file}}" ]; then
        echo "\033[1;31mError: File {{from_file}} does not exist.\033[0m"
        exit 1
    fi
    
    # Determine source language
    FROM_EXT="${{from_file}##*.}"
    FROM_LANGUAGE=""
    
    case "$FROM_EXT" in
        js|jsx) FROM_LANGUAGE="JavaScript" ;;
        ts|tsx) FROM_LANGUAGE="TypeScript" ;;
        py) FROM_LANGUAGE="Python" ;;
        rb) FROM_LANGUAGE="Ruby" ;;
        go) FROM_LANGUAGE="Go" ;;
        rs) FROM_LANGUAGE="Rust" ;;
        java) FROM_LANGUAGE="Java" ;;
        c) FROM_LANGUAGE="C" ;;
        cpp|cc) FROM_LANGUAGE="C++" ;;
        sh|bash) FROM_LANGUAGE="Shell" ;;
        nix) FROM_LANGUAGE="Nix" ;;
        *) FROM_LANGUAGE="Unknown" ;;
    esac
    
    # Determine target file extension
    TO_EXT=""
    case "{{to_language}}" in
        javascript|js) TO_EXT="js" ;;
        typescript|ts) TO_EXT="ts" ;;
        python|py) TO_EXT="py" ;;
        ruby|rb) TO_EXT="rb" ;;
        go) TO_EXT="go" ;;
        rust|rs) TO_EXT="rs" ;;
        java) TO_EXT="java" ;;
        c) TO_EXT="c" ;;
        cpp|c++) TO_EXT="cpp" ;;
        shell|bash|sh) TO_EXT="sh" ;;
        nix) TO_EXT="nix" ;;
        *) 
            echo "\033[1;31mError: Unsupported target language {{to_language}}.\033[0m"
            exit 1
            ;;
    esac
    
    # Read file content
    FILE_CONTENT=$(cat "{{from_file}}")
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create translation prompt
    TRANSLATE_PROMPT="You are an expert programmer in both $FROM_LANGUAGE and {{to_language}}. Translate the following $FROM_LANGUAGE code to {{to_language}} while maintaining the same functionality, logic, and behavior. 

Include equivalent comments and docstrings in the translated code. Make sure to follow best practices and idioms of the target language.

CODE TO TRANSLATE ($FROM_LANGUAGE):
\`\`\`$FROM_EXT
$FILE_CONTENT
\`\`\`

Return only the translated code in a code block."
    
    # Generate translation with Claude
    RESULT=$(claude --message "$TRANSLATE_PROMPT" --model "$MODEL" --max-tokens 1500)
    
    # Extract translated code
    TRANSLATED_CODE=$(echo "$RESULT" | awk '/```/{flag=1;next}/```/{flag=0}flag')
    
    if [ -z "$TRANSLATED_CODE" ]; then
        echo "\033[1;31mError: Couldn't extract translated code from the result.\033[0m"
        echo "Raw result:"
        echo "$RESULT"
        exit 1
    fi
    
    # Determine output filename
    BASE_NAME=$(basename "{{from_file}}" ".$FROM_EXT")
    OUTPUT_FILE="${BASE_NAME}.$TO_EXT"
    
    # Display the result
    echo "\033[1;32mTranslated code:\033[0m"
    echo "$TRANSLATED_CODE"
    
    # Ask if user wants to save the translated code
    read "REPLY?Save the translated code to $OUTPUT_FILE? [Y/n] "
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        echo "$TRANSLATED_CODE" > "$OUTPUT_FILE"
        echo "\033[1;32mTranslated code saved to $OUTPUT_FILE successfully!\033[0m"
    else
        echo "\033[1;33mSave cancelled.\033[0m"
    fi

# Generate tests for a file
test-gen file_path:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude"]}}"
    echo "\033[1;36m=== AI Test Generator ===\033[0m"
    echo "\033[1;33mGenerating tests for:\033[0m {{file_path}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate file exists
    if [ ! -f "{{file_path}}" ]; then
        echo "\033[1;31mError: File {{file_path}} does not exist.\033[0m"
        exit 1
    fi
    
    # Determine file type and testing framework
    FILE_EXT="${{file_path}##*.}"
    LANGUAGE=""
    TEST_FRAMEWORK=""
    TEST_FILE_EXT=""
    
    case "$FILE_EXT" in
        js|jsx) 
            LANGUAGE="JavaScript" 
            TEST_FRAMEWORK="Jest"
            TEST_FILE_EXT="test.js"
            ;;
        ts|tsx) 
            LANGUAGE="TypeScript" 
            TEST_FRAMEWORK="Jest with TypeScript"
            TEST_FILE_EXT="test.ts"
            ;;
        py) 
            LANGUAGE="Python" 
            TEST_FRAMEWORK="pytest"
            TEST_FILE_EXT="test.py"
            ;;
        rb) 
            LANGUAGE="Ruby" 
            TEST_FRAMEWORK="RSpec"
            TEST_FILE_EXT="_spec.rb"
            ;;
        go) 
            LANGUAGE="Go" 
            TEST_FRAMEWORK="Go testing package"
            TEST_FILE_EXT="_test.go"
            ;;
        rs) 
            LANGUAGE="Rust" 
            TEST_FRAMEWORK="Rust's built-in testing framework"
            TEST_FILE_EXT="_test.rs"
            ;;
        *) 
            echo "\033[1;31mError: Unsupported file type .$FILE_EXT for test generation.\033[0m"
            exit 1
            ;;
    esac
    
    # Read file content
    FILE_CONTENT=$(cat "{{file_path}}")
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create test generation prompt
    TEST_PROMPT="You are an expert $LANGUAGE developer specializing in testing with $TEST_FRAMEWORK. Generate comprehensive tests for the following code. 

Include tests for:
1. Normal operation with various inputs
2. Edge cases and boundary conditions
3. Error handling and exception cases
4. Any implicit requirements based on the code's purpose

CODE TO TEST:
\`\`\`$FILE_EXT
$FILE_CONTENT
\`\`\`

Return only the test code in a code block. Make sure the tests are runnable and follow best practices for $TEST_FRAMEWORK."
    
    # Generate tests with Claude
    RESULT=$(claude --message "$TEST_PROMPT" --model "$MODEL" --max-tokens 1500)
    
    # Extract test code
    TEST_CODE=$(echo "$RESULT" | awk '/```/{flag=1;next}/```/{flag=0}flag')
    
    if [ -z "$TEST_CODE" ]; then
        echo "\033[1;31mError: Couldn't extract test code from the result.\033[0m"
        echo "Raw result:"
        echo "$RESULT"
        exit 1
    fi
    
    # Determine output filename
    BASE_NAME=$(basename "{{file_path}}" ".$FILE_EXT")
    DIR_NAME=$(dirname "{{file_path}}")
    OUTPUT_FILE="$DIR_NAME/$BASE_NAME.$TEST_FILE_EXT"
    
    # Display the result
    echo "\033[1;32mGenerated tests:\033[0m"
    echo "$TEST_CODE"
    
    # Ask if user wants to save the tests
    read "REPLY?Save these tests to $OUTPUT_FILE? [Y/n] "
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        echo "$TEST_CODE" > "$OUTPUT_FILE"
        echo "\033[1;32mTests saved to $OUTPUT_FILE successfully!\033[0m"
    else
        echo "\033[1;33mSave cancelled.\033[0m"
    fi

# Explain a code snippet or file
explain file_path:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-haiku"]}}"
    echo "\033[1;36m=== AI Code Explainer ===\033[0m"
    echo "\033[1;33mExplaining:\033[0m {{file_path}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate file exists
    if [ ! -f "{{file_path}}" ]; then
        echo "\033[1;31mError: File {{file_path}} does not exist.\033[0m"
        exit 1
    fi
    
    # Read file content
    FILE_CONTENT=$(cat "{{file_path}}")
    FILE_EXT="${{file_path}##*.}"
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create explanation prompt
    EXPLAIN_PROMPT="Explain the following code in detail:

\`\`\`$FILE_EXT
$FILE_CONTENT
\`\`\`

In your explanation:
1. Summarize what the code does at a high level
2. Explain the purpose of key functions, classes, or modules
3. Walk through the logic step by step
4. Highlight any important patterns, algorithms, or techniques used
5. Note any potential issues or edge cases

Format your explanation as markdown with appropriate headings and code references."
    
    # Generate explanation with Claude
    claude --message "$EXPLAIN_PROMPT" --model "$MODEL" --max-tokens 1500 | less -R

# ----------------------------------------------------------
# Language-specific commands
# ----------------------------------------------------------

[namespace=ai typescript]

# Generate a TypeScript function based on a description
function description:
    #!/usr/bin/env zsh
    echo "\033[1;36m=== TypeScript Function Generator ===\033[0m"
    {{just_executable()}} ai code typescript "Write a TypeScript function that {{description}}. Include proper type annotations, error handling, and unit tests."

# Generate TypeScript interfaces from JSON
interfaces-from-json file_path:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-haiku"]}}"
    echo "\033[1;36m=== TypeScript Interface Generator ===\033[0m"
    echo "\033[1;33mGenerating interfaces from:\033[0m {{file_path}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate file exists
    if [ ! -f "{{file_path}}" ]; then
        echo "\033[1;31mError: File {{file_path}} does not exist.\033[0m"
        exit 1
    fi
    
    # Read JSON content
    JSON_CONTENT=$(cat "{{file_path}}")
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create interfaces prompt
    INTERFACES_PROMPT="Generate TypeScript interfaces for the following JSON structure. Create proper type definitions and include optional/required properties appropriately.

Use good naming conventions, add JSDoc comments to explain complex properties, and organize the interfaces in a logical way.

JSON:
\`\`\`json
$JSON_CONTENT
\`\`\`

Return only the TypeScript interface definitions in a code block."
    
    # Generate interfaces with Claude
    RESULT=$(claude --message "$INTERFACES_PROMPT" --model "$MODEL" --max-tokens 1000)
    
    # Extract interfaces code
    INTERFACES_CODE=$(echo "$RESULT" | awk '/```/{flag=1;next}/```/{flag=0}flag')
    
    if [ -z "$INTERFACES_CODE" ]; then
        echo "\033[1;31mError: Couldn't extract interfaces code from the result.\033[0m"
        echo "Raw result:"
        echo "$RESULT"
        exit 1
    fi
    
    # Determine output filename
    BASE_NAME=$(basename "{{file_path}}" ".json")
    OUTPUT_FILE="${BASE_NAME}.interfaces.ts"
    
    # Display the result
    echo "\033[1;32mGenerated interfaces:\033[0m"
    echo "$INTERFACES_CODE"
    
    # Ask if user wants to save the interfaces
    read "REPLY?Save these interfaces to $OUTPUT_FILE? [Y/n] "
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        echo "$INTERFACES_CODE" > "$OUTPUT_FILE"
        echo "\033[1;32mInterfaces saved to $OUTPUT_FILE successfully!\033[0m"
    else
        echo "\033[1;33mSave cancelled.\033[0m"
    fi

# Generate a React component
react-component name props_description:
    #!/usr/bin/env zsh
    echo "\033[1;36m=== React Component Generator ===\033[0m"
    {{just_executable()}} ai code typescript "Create a modern React component named {{name}} that {{props_description}}. Use TypeScript and functional components with hooks. Include proper props interface, comments, and example usage."

[namespace=ai python]

# Generate a Python function based on a description
function description:
    #!/usr/bin/env zsh
    echo "\033[1;36m=== Python Function Generator ===\033[0m"
    {{just_executable()}} ai code python "Write a Python function that {{description}}. Include proper type hints, docstrings, error handling, and unit tests using pytest."

# Parse a Python file for type hints and documentation gaps
analyze file_path:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-haiku"]}}"
    echo "\033[1;36m=== Python Code Analyzer ===\033[0m"
    echo "\033[1;33mAnalyzing:\033[0m {{file_path}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate file exists
    if [ ! -f "{{file_path}}" ]; then
        echo "\033[1;31mError: File {{file_path}} does not exist.\033[0m"
        exit 1
    fi
    
    # Read Python content
    PYTHON_CONTENT=$(cat "{{file_path}}")
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create analysis prompt
    ANALYSIS_PROMPT="Analyze this Python file for improvements in typing and documentation:

\`\`\`python
$PYTHON_CONTENT
\`\`\`

For each function or class:
1. Check if it's missing proper type hints (PEP 484)
2. Verify if it has appropriate docstrings (Google style preferred)
3. Identify any unclear variable names or magic numbers
4. Note potential error handling improvements

Return your analysis as markdown with clear headings for each section and code examples for suggested improvements."
    
    # Generate analysis with Claude
    claude --message "$ANALYSIS_PROMPT" --model "$MODEL" --max-tokens 1000

# Generate a FastAPI route
fastapi-route endpoint description:
    #!/usr/bin/env zsh
    echo "\033[1;36m=== FastAPI Route Generator ===\033[0m"
    {{just_executable()}} ai code python "Create a FastAPI route for {{endpoint}} that {{description}}. Include proper Pydantic models, type hints, docstrings, error handling, and OpenAPI documentation."

[namespace=ai shell]

# Generate a shell script based on a description
script description:
    #!/usr/bin/env zsh
    echo "\033[1;36m=== Shell Script Generator ===\033[0m"
    {{just_executable()}} ai code bash "Write a shell script that {{description}}. Include error handling, usage information, and proper comments. Make it compatible with both bash and zsh."

# Refactor a shell script for better practices
refactor file_path:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude"]}}"
    echo "\033[1;36m=== Shell Script Refactorer ===\033[0m"
    echo "\033[1;33mRefactoring:\033[0m {{file_path}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate file exists
    if [ ! -f "{{file_path}}" ]; then
        echo "\033[1;31mError: File {{file_path}} does not exist.\033[0m"
        exit 1
    fi
    
    # Read script content
    SCRIPT_CONTENT=$(cat "{{file_path}}")
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create refactoring prompt
    REFACTOR_PROMPT="Refactor this shell script following modern best practices:

\`\`\`bash
$SCRIPT_CONTENT
\`\`\`

Improvements to make:
1. Add proper error handling and exit codes
2. Use safer constructs (e.g., quote variables, set -e, set -u)
3. Add helpful comments and usage information
4. Make the code more modular with functions
5. Improve variable naming and organization
6. Ensure compatibility with both bash and zsh

Return the refactored script in a code block with explanations of key improvements."
    
    # Generate refactored script with Claude
    RESULT=$(claude --message "$REFACTOR_PROMPT" --model "$MODEL" --max-tokens 1500)
    
    # Extract refactored script
    REFACTORED_SCRIPT=$(echo "$RESULT" | awk '/```/{flag=1;next}/```/{flag=0}flag')
    
    if [ -z "$REFACTORED_SCRIPT" ]; then
        echo "\033[1;31mError: Couldn't extract refactored script from the result.\033[0m"
        echo "Raw result:"
        echo "$RESULT"
        exit 1
    fi
    
    # Determine output filename
    OUTPUT_FILE="{{file_path}}.refactored"
    
    # Display the result
    echo "\033[1;32mRefactored script:\033[0m"
    echo "$REFACTORED_SCRIPT"
    
    # Ask if user wants to save the refactored script
    read "REPLY?Save the refactored script to $OUTPUT_FILE? [Y/n] "
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        echo "$REFACTORED_SCRIPT" > "$OUTPUT_FILE"
        echo "\033[1;32mRefactored script saved to $OUTPUT_FILE successfully!\033[0m"
    else
        echo "\033[1;33mSave cancelled.\033[0m"
    fi

[namespace=ai nix]

# Generate a Nix expression based on a description
expression description:
    #!/usr/bin/env zsh
    echo "\033[1;36m=== Nix Expression Generator ===\033[0m"
    {{just_executable()}} ai code nix "Write a Nix expression that {{description}}. Include proper comments and follow best practices for Nix."

# Create a Nix shell environment for a project
devshell file_path:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude"]}}"
    echo "\033[1;36m=== Nix Development Shell Generator ===\033[0m"
    echo "\033[1;33mCreating devshell for:\033[0m {{file_path}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Determine project type
    PROJECT_TYPE=""
    
    if [ -f "{{file_path}}/package.json" ]; then
        PROJECT_TYPE="Node.js"
        DEPS=$(cat "{{file_path}}/package.json" | jq -r '.dependencies | keys | join(", ")')
        DEV_DEPS=$(cat "{{file_path}}/package.json" | jq -r '.devDependencies | keys | join(", ")')
    elif [ -f "{{file_path}}/requirements.txt" ]; then
        PROJECT_TYPE="Python"
        DEPS=$(cat "{{file_path}}/requirements.txt" | tr '\n' ', ')
    elif [ -f "{{file_path}}/Cargo.toml" ]; then
        PROJECT_TYPE="Rust"
        DEPS=$(cat "{{file_path}}/Cargo.toml" | grep -A 100 '\[dependencies\]' | grep -v '\[' | grep '=' | awk '{print $1}' | tr '\n' ', ')
    elif [ -f "{{file_path}}/go.mod" ]; then
        PROJECT_TYPE="Go"
        DEPS=$(cat "{{file_path}}/go.mod" | grep -v '//' | grep -v 'module' | grep -v 'go ' | tr '\n' ', ')
    else
        PROJECT_TYPE="Generic"
    fi
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create devshell prompt
    DEVSHELL_PROMPT="Create a Nix development shell (shell.nix) for a $PROJECT_TYPE project. 

Project details:
- Type: $PROJECT_TYPE
- Dependencies: $DEPS
- Dev Dependencies: $DEV_DEPS

The shell.nix file should:
1. Include all necessary development tools for this type of project
2. Set appropriate environment variables
3. Include helpful comments explaining key parts
4. Follow modern Nix best practices (flake-compatible if possible)

Return only the Nix code in a code block."
    
    # Generate devshell with Claude
    RESULT=$(claude --message "$DEVSHELL_PROMPT" --model "$MODEL" --max-tokens 1000)
    
    # Extract devshell code
    DEVSHELL_CODE=$(echo "$RESULT" | awk '/```/{flag=1;next}/```/{flag=0}flag')
    
    if [ -z "$DEVSHELL_CODE" ]; then
        echo "\033[1;31mError: Couldn't extract Nix code from the result.\033[0m"
        echo "Raw result:"
        echo "$RESULT"
        exit 1
    fi
    
    # Output filename
    OUTPUT_FILE="{{file_path}}/shell.nix"
    
    # Display the result
    echo "\033[1;32mGenerated shell.nix:\033[0m"
    echo "$DEVSHELL_CODE"
    
    # Ask if user wants to save the shell.nix
    read "REPLY?Save this shell.nix to $OUTPUT_FILE? [Y/n] "
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        echo "$DEVSHELL_CODE" > "$OUTPUT_FILE"
        echo "\033[1;32mshell.nix saved to $OUTPUT_FILE successfully!\033[0m"
    else
        echo "\033[1;33mSave cancelled.\033[0m"
    fi

# ----------------------------------------------------------
# IDE Integration commands
# ----------------------------------------------------------

[namespace=ai cursor]

# Create Cursor-specific AI prompts for a project
setup project_dir:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-haiku"]}}"
    echo "\033[1;36m=== Cursor AI Setup ===\033[0m"
    echo "\033[1;33mCreating Cursor configuration for:\033[0m {{project_dir}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate directory exists
    if [ ! -d "{{project_dir}}" ]; then
        echo "\033[1;31mError: Directory {{project_dir}} does not exist.\033[0m"
        exit 1
    fi
    
    # Determine project type
    PROJECT_TYPE=""
    
    if [ -f "{{project_dir}}/package.json" ]; then
        PROJECT_TYPE="Node.js/JavaScript/TypeScript"
    elif [ -f "{{project_dir}}/requirements.txt" ]; then
        PROJECT_TYPE="Python"
    elif [ -f "{{project_dir}}/Cargo.toml" ]; then
        PROJECT_TYPE="Rust"
    elif [ -f "{{project_dir}}/go.mod" ]; then
        PROJECT_TYPE="Go"
    else
        PROJECT_TYPE="Generic"
    fi
    
    # Create Cursor config directory
    CURSOR_DIR="{{project_dir}}/.cursor"
    mkdir -p "$CURSOR_DIR"
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create prompt for generating Cursor configs
    CONFIG_PROMPT="Create a set of Cursor AI-powered coding assistant configurations for a $PROJECT_TYPE project. 

Include the following files:
1. A settings.json file with optimized settings for Cursor in a $PROJECT_TYPE project
2. A prompts.json file with 5-10 useful custom prompts specific to $PROJECT_TYPE development
3. A README.md explaining how to use these configurations effectively

Each file should be within a code block with the appropriate filename as the language specifier."
    
    # Generate configs with Claude
    RESULT=$(claude --message "$CONFIG_PROMPT" --model "$MODEL" --max-tokens 1500)
    
    # Extract and save each config file
    echo "$RESULT" | awk '/```(.*)/{filename=$2; getline; file=""; while (!/```/) {file=file $0 "\n"; getline}; print filename ":" file}' | while IFS=':' read -r filename content; do
        if [[ ! -z "$filename" && "$filename" != "markdown" && "$filename" != "json" ]]; then
            echo "$content" > "$CURSOR_DIR/$filename"
            echo "\033[1;32mCreated $CURSOR_DIR/$filename\033[0m"
        fi
    done
    
    echo "\033[1;32mCursor AI configuration completed successfully!\033[0m"
    echo "Files are located in: $CURSOR_DIR"

# Generate Cursor-compatible snippets
snippets project_dir:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-haiku"]}}"
    echo "\033[1;36m=== Cursor Snippets Generator ===\033[0m"
    echo "\033[1;33mCreating snippets for:\033[0m {{project_dir}}"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Validate directory exists
    if [ ! -d "{{project_dir}}" ]; then
        echo "\033[1;31mError: Directory {{project_dir}} does not exist.\033[0m"
        exit 1
    fi
    
    # Determine project type
    PROJECT_TYPE=""
    
    if [ -f "{{project_dir}}/package.json" ]; then
        PROJECT_TYPE="Node.js/JavaScript/TypeScript"
    elif [ -f "{{project_dir}}/requirements.txt" ]; then
        PROJECT_TYPE="Python"
    elif [ -f "{{project_dir}}/Cargo.toml" ]; then
        PROJECT_TYPE="Rust"
    elif [ -f "{{project_dir}}/go.mod" ]; then
        PROJECT_TYPE="Go"
    else
        PROJECT_TYPE="Generic"
    fi
    
    # Create Cursor snippets directory
    CURSOR_DIR="{{project_dir}}/.cursor"
    SNIPPETS_DIR="$CURSOR_DIR/snippets"
    mkdir -p "$SNIPPETS_DIR"
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create prompt for generating snippets
    SNIPPETS_PROMPT="Create a set of useful code snippets for a $PROJECT_TYPE project in Cursor-compatible format. 

These snippets should:
1. Cover common patterns and idioms in $PROJECT_TYPE development
2. Include proper documentation and explanations
3. Be formatted as individual .json files for Cursor to use
4. Follow naming conventions like 'pattern-name.json'

Each snippet should be within a code block with the filename as the language specifier."
    
    # Generate snippets with Claude
    RESULT=$(claude --message "$SNIPPETS_PROMPT" --model "$MODEL" --max-tokens 1500)
    
    # Extract and save each snippet
    echo "$RESULT" | awk '/```(.*)/{filename=$2; getline; file=""; while (!/```/) {file=file $0 "\n"; getline}; print filename ":" file}' | while IFS=':' read -r filename content; do
        if [[ "$filename" == *.json ]]; then
            echo "$content" > "$SNIPPETS_DIR/$filename"
            echo "\033[1;32mCreated snippet: $SNIPPETS_DIR/$filename\033[0m"
        fi
    done
    
    echo "\033[1;32mCursor snippets generated successfully!\033[0m"
    echo "Snippets are located in: $SNIPPETS_DIR"

[namespace=ai ghostty]

# Setup Ghostty terminal with AI-optimized configuration
setup:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-haiku"]}}"
    echo "\033[1;36m=== Ghostty AI-Optimized Setup ===\033[0m"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Create Ghostty config directory
    GHOSTTY_DIR="$HOME/.config/ghostty"
    mkdir -p "$GHOSTTY_DIR"
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Create prompt for generating Ghostty config
    CONFIG_PROMPT="Create an optimized Ghostty terminal configuration file focused on AI-driven development workflows. 

The configuration should:
1. Use a modern, easy-to-read color scheme suitable for long coding sessions (Tokyo Night preferred)
2. Configure key bindings for efficient AI-assisted coding workflows
3. Set up appropriate font and spacing for code display
4. Include performance optimizations for terminal rendering
5. Configure integration with tools like zsh, starship prompt, etc.
6. Add helpful comments explaining the key configurations

Return only the configuration in a code block."
    
    # Generate config with Claude
    RESULT=$(claude --message "$CONFIG_PROMPT" --model "$MODEL" --max-tokens 1000)
    
    # Extract config
    GHOSTTY_CONFIG=$(echo "$RESULT" | awk '/```/{flag=1;next}/```/{flag=0}flag')
    
    if [ -z "$GHOSTTY_CONFIG" ]; then
        echo "\033[1;31mError: Couldn't extract Ghostty configuration from the result.\033[0m"
        echo "Raw result:"
        echo "$RESULT"
        exit 1
    fi
    
    # Output filename
    OUTPUT_FILE="$GHOSTTY_DIR/config"
    
    # Backup existing config if it exists
    if [ -f "$OUTPUT_FILE" ]; then
        cp "$OUTPUT_FILE" "$OUTPUT_FILE.bak"
        echo "\033[1;33mBacked up existing configuration to $OUTPUT_FILE.bak\033[0m"
    fi
    
    # Display the result
    echo "\033[1;32mGenerated Ghostty configuration:\033[0m"
    echo "$GHOSTTY_CONFIG"
    
    # Ask if user wants to save the configuration
    read "REPLY?Save this configuration to $OUTPUT_FILE? [Y/n] "
    if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        echo "$GHOSTTY_CONFIG" > "$OUTPUT_FILE"
        echo "\033[1;32mGhostty configuration saved to $OUTPUT_FILE successfully!\033[0m"
    else
        echo "\033[1;33mSave cancelled.\033[0m"
    fi

# ----------------------------------------------------------
# AI-powered operations (using Claude Code or other AI tools)
# ----------------------------------------------------------
[namespace=ai run]

# Retrieve and analyze Claude Code conversation history with AI
claude-code-history *args="5":
    #!/usr/bin/env zsh
    echo "=== AI-Enhanced Claude Code History Analysis ==="
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "Error: claude-cli not found. Using standard history display instead."
        {{just_executable()}} claude history {{args}}
        exit 1
    fi
    
    # Environment setup
    CLAUDE_DB="$HOME/.claude/__store.db"
    TEMP_FILE=$(mktemp)
    
    if [ ! -f "$CLAUDE_DB" ]; then
        echo "Error: Claude database not found at $CLAUDE_DB"
        exit 1
    fi
    
    # Retrieve conversations
    echo "Retrieving and analyzing {{args}} most recent conversations..."
    sqlite3 "$CLAUDE_DB" "
    SELECT 
        s.leaf_uuid,
        b.session_id,
        s.summary,
        s.updated_at,
        strftime('%Y-%m-%d %H:%M', s.updated_at/1000, 'unixepoch', 'localtime') as time
    FROM 
        conversation_summaries s
    JOIN 
        base_messages b ON s.leaf_uuid = b.uuid
    ORDER BY 
        s.updated_at DESC
    LIMIT {{args}};" > "$TEMP_FILE"
    
    # Prepare data for AI analysis
    echo "Database contains conversations at $CLAUDE_DB" > conversation_data.txt
    echo "Recent conversations:" >> conversation_data.txt
    cat "$TEMP_FILE" | while IFS='|' read -r uuid session_id summary updated_at time; do
        echo "Session: $session_id ($time)" >> conversation_data.txt
        echo "Summary: $summary" >> conversation_data.txt
        echo "Recent user messages:" >> conversation_data.txt
        
        sqlite3 "$CLAUDE_DB" "
        SELECT 
            json_extract(u.message, '$.content[0].content') as message
        FROM 
            user_messages u
        JOIN 
            base_messages b ON u.uuid = b.uuid
        WHERE 
            b.session_id = '$session_id'
        AND
            json_type(u.message, '$.content[0].content') = 'text'
        ORDER BY 
            u.timestamp DESC
        LIMIT 3;" | while read -r message; do
            echo "- $message" >> conversation_data.txt
        done
        echo "" >> conversation_data.txt
    done
    
    # Use Claude to analyze the conversation history
    claude --message "Analyze these Claude Code conversation summaries and provide an organized overview. For each conversation, provide: (1) a clearer title if needed, (2) key topics discussed, (3) any code changes or files edited, and (4) estimated duration based on timestamps. Format your response as markdown." --file conversation_data.txt --max-tokens 1000
    
    # Clean up
    rm "$TEMP_FILE"
    rm conversation_data.txt
    
    # Instructions for detailed viewing
    echo "\nTo view specific conversation details, use:"
    echo "just claude conversation-details <session_id>"
    echo "To export conversation to markdown, use:"
    echo "just claude export-conversation <session_id>"

# Extract coding patterns and preferences from conversation history
extract-preferences:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude"]}}"
    echo "\033[1;36m=== Extract Coding Preferences from Conversation History ===\033[0m"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Environment setup
    CLAUDE_DB="$HOME/.claude/__store.db"
    OUTPUT_DIR="{{AI_CONFIG_DIR}}/preferences"
    mkdir -p "$OUTPUT_DIR"
    
    if [ ! -f "$CLAUDE_DB" ]; then
        echo "\033[1;31mError: Claude database not found at $CLAUDE_DB\033[0m"
        exit 1
    fi
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Get recent conversations for analysis
    echo "Retrieving conversation data for preference analysis..."
    TEMP_FILE=$(mktemp)
    
    # Get conversation IDs and summaries
    sqlite3 "$CLAUDE_DB" "
    SELECT 
        b.session_id,
        s.summary
    FROM 
        conversation_summaries s
    JOIN 
        base_messages b ON s.leaf_uuid = b.uuid
    ORDER BY 
        s.updated_at DESC
    LIMIT 15;" > "$TEMP_FILE"
    
    # Prepare conversation data for analysis
    echo "Analyzing conversations to extract coding preferences..."
    cat "$TEMP_FILE" | while IFS='|' read -r session_id summary; do
        # Get user messages from this conversation
        sqlite3 "$CLAUDE_DB" "
        SELECT 
            json_extract(u.message, '$.content[0].content') as message
        FROM 
            user_messages u
        JOIN 
            base_messages b ON u.uuid = b.uuid
        WHERE 
            b.session_id = '$session_id'
        AND
            json_type(u.message, '$.content[0].content') = 'text'
        ORDER BY 
            u.timestamp ASC
        LIMIT 10;" | grep -v "null" >> "$TEMP_FILE.user_messages"
        
        # Get assistant messages from this conversation
        sqlite3 "$CLAUDE_DB" "
        SELECT 
            json_extract(a.message, '$.content[0].text') as message
        FROM 
            assistant_messages a
        JOIN 
            base_messages b ON a.uuid = b.uuid
        WHERE 
            b.session_id = '$session_id'
        AND
            json_extract(a.message, '$.content[0].text') IS NOT NULL
        ORDER BY 
            a.timestamp ASC
        LIMIT 10;" | grep -v "null" >> "$TEMP_FILE.assistant_messages"
    done
    
    # Create extraction prompt
    EXTRACT_PROMPT="Analyze these snippets from coding assistant conversations and extract the user's coding preferences, styles, and patterns.

USER MESSAGES:
$(cat "$TEMP_FILE.user_messages" | head -n 100)

ASSISTANT RESPONSES:
$(cat "$TEMP_FILE.assistant_messages" | head -n 100)

Based on these conversations, identify:
1. Preferred programming languages and frameworks
2. Coding style preferences (e.g., naming conventions, formatting)
3. Common tasks and workflows
4. Tools and environments frequently used
5. Any specific preferences for documentation or commenting style

Create four separate documents:
1. coding_style.md: Detailed preferences for code style and formatting
2. workflows.md: Common development workflows and patterns
3. tools.md: Preferred tools, frameworks, and environments
4. documentation.md: Preferences for documentation and commenting

Each document should be formatted as markdown and begin with a code block."
    
    # Generate preferences with Claude
    RESULT=$(claude --message "$EXTRACT_PROMPT" --model "$MODEL" --max-tokens 2000)
    
    # Extract and save each document
    echo "$RESULT" | awk '/```markdown/{filename=""; getline; if($0 ~ /^#/) filename=tolower($2) ".md"; if(filename=="") filename="coding_style.md"; file=""; while(!/```/ && length($0)>0) {file=file $0 "\n"; getline}; if(filename!="" && file!="") print filename ":" file}' | while IFS=':' read -r filename content; do
        if [[ ! -z "$filename" && ! -z "$content" ]]; then
            echo "$content" > "$OUTPUT_DIR/$filename"
            echo "\033[1;32mCreated preference document: $OUTPUT_DIR/$filename\033[0m"
        fi
    done
    
    # Clean up temp files
    rm "$TEMP_FILE"
    rm "$TEMP_FILE.user_messages"
    rm "$TEMP_FILE.assistant_messages"
    
    echo "\033[1;32mPreference extraction completed!\033[0m"
    echo "Preference documents saved to: $OUTPUT_DIR"

# Generate structured summary of conversations for documentation
summarize-all:
    #!/usr/bin/env zsh
    MODEL="{{MODELS["claude-opus"]}}"
    echo "\033[1;36m=== Generate Comprehensive Documentation from Conversations ===\033[0m"
    echo "\033[1;33mModel:\033[0m $MODEL"
    echo ""
    
    # Environment setup
    CLAUDE_DB="$HOME/.claude/__store.db"
    OUTPUT_DIR="{{AI_CONFIG_DIR}}/summaries"
    mkdir -p "$OUTPUT_DIR"
    
    if [ ! -f "$CLAUDE_DB" ]; then
        echo "\033[1;31mError: Claude database not found at $CLAUDE_DB\033[0m"
        exit 1
    fi
    
    # Check if claude-cli is available
    if ! command -v claude &> /dev/null; then
        echo "\033[1;31mError: claude-cli not found. Please install it with 'pip install claude-cli'.\033[0m"
        exit 1
    fi
    
    # Get conversation data
    echo "Retrieving conversation summaries for documentation..."
    TEMP_FILE=$(mktemp)
    
    # Get conversation summaries
    sqlite3 "$CLAUDE_DB" "
    SELECT 
        s.summary,
        strftime('%Y-%m-%d', s.updated_at/1000, 'unixepoch', 'localtime') as date
    FROM 
        conversation_summaries s
    JOIN 
        base_messages b ON s.leaf_uuid = b.uuid
    ORDER BY 
        s.updated_at DESC
    LIMIT 25;" > "$TEMP_FILE"
    
    # Create summarization prompt
    SUMMARIZE_PROMPT="Based on these conversation summaries from interactions with coding assistants, create a comprehensive documentation package that captures the key insights, solutions, and patterns.

CONVERSATION SUMMARIES:
$(cat "$TEMP_FILE")

Create the following documentation files:

1. system_architecture.md: A high-level overview of system architecture based on discussions
2. best_practices.md: Coding best practices extracted from conversations
3. troubleshooting.md: Common issues and their solutions
4. setup_guide.md: Setup and configuration guidance from conversations
5. api_patterns.md: API design patterns and preferences

Each document should:
- Be well-organized with clear headings
- Include code examples where appropriate
- Reference specific patterns or solutions from the conversations
- Be formatted in clear, professional markdown

Begin each document with a code block and appropriate markdown."
    
    # Generate documentation with Claude
    RESULT=$(claude --message "$SUMMARIZE_PROMPT" --model "$MODEL" --max-tokens 2500)
    
    # Extract and save each document
    echo "$RESULT" | awk '/```markdown/{filename=""; getline; if($0 ~ /^#/) filename=tolower($2) ".md"; if(filename=="") next; file=""; while(!/```/ && length($0)>0) {file=file $0 "\n"; getline}; if(filename!="" && file!="") print filename ":" file}' | while IFS=':' read -r filename content; do
        if [[ ! -z "$filename" && ! -z "$content" ]]; then
            echo "$content" > "$OUTPUT_DIR/$filename"
            echo "\033[1;32mCreated documentation: $OUTPUT_DIR/$filename\033[0m"
        fi
    done
    
    # Clean up temp file
    rm "$TEMP_FILE"
    
    echo "\033[1;32mDocumentation generation completed!\033[0m"
    echo "Documentation saved to: $OUTPUT_DIR"
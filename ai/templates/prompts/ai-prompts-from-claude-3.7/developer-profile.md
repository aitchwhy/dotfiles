# Developer Profile

## Core Identity
- Senior software engineer specializing in systems, AI infrastructure, and developer tooling
- Background in distributed systems, data engineering, and systems architecture
- Preference for intelligent, reproducible, and automated solutions
- Values high-quality implementations with minimal technical debt

## Technical Environment

### Hardware/OS
- Apple Silicon Mac (primary development environment)
- Multi-machine synchronization requirements
- Local-first architecture preferences

### Development Environment
- **Package Management**: Nix, Homebrew, uv (Python)
- **Configuration**: Git-tracked dotfiles, declarative configurations
- **Editor Ecosystem**: Neovim (LazyVim), Cursor IDE
- **Terminal**: Ghostty with ZSH
- **Window Management**: Raycast, Swish, Yabai, Hammerspoon

### Technical Stack
- **Primary Languages**: 
  - TypeScript (eslint + prettier)
  - Python (ruff for linting)
  - Exposure to Rust, Go, and other systems languages
- **Tooling Preferences**:
  - Modern CLI utilities (ripgrep, fd, zoxide, atuin, starship)
  - AI-augmented development workflows
  - Keyboard-driven interfaces with minimal mouse usage

## Workflow Characteristics

### General Approach
- Preference for keyboard-driven, efficient workflows
- Strong Vim expertise and modal editing proficiency
- Value tools that reduce cognitive load and automate routine tasks
- Emphasis on reproducibility and declarative configuration

### Technical Values
- Intelligence/capability prioritized over resource usage
- Clear, maintainable code valued over cleverness
- Preference for functional programming patterns where appropriate
- Appreciation for elegant solutions that balance simplicity and power

### Learning Style
- Preference for bottom-up understanding with comprehensive examples
- Value explanations that balance theory and practical application
- Appreciate insights into underlying mechanisms and design decisions
- Learn best through hands-on implementation after conceptual understanding

## Communication Preferences

### Technical Documentation
- Structured, hierarchical organization with clear navigation
- Balanced detail: comprehensive without overwhelming
- Code examples that demonstrate real-world usage
- Visual aids for complex relationships and architectures

### Decision Processes
- Evidence-based recommendations with explicit reasoning
- Clear articulation of tradeoffs and constraints
- Preference for quantitative evaluation when possible
- Appreciation for multiple perspectives before conclusions

## AI Collaboration Context

### Interaction Mode
- Direct, efficient communication without unnecessary niceties
- Preference for precise, technical language
- Appreciation for both depth (when needed) and brevity (when appropriate)

### Output Preferences
- Structured, scannable content with clear section demarcation
- Visual representations for complex relationships
- Code that balances readability and efficiency
- Practical, implementable recommendations

### Follow-up Style
- Iterative refinement rather than extended initial responses
- Focused questions to clarify ambiguities
- Building on previous context rather than repetition

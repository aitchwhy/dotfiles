# Claude Code Single Source of Truth
# Generates: MCP servers, plugins, marketplaces for Claude Desktop AND Code CLI
#
# ARCHITECTURE (January 2026 - MINIMAL):
# - Claude Desktop: Reads ~/Library/Application Support/Claude/claude_desktop_config.json
#   → Generated by Nix activation hook (Electron app needs PATH injection)
# - Claude Code CLI: Reads ~/.claude.json
#   → Generated by Nix activation hook (merges with runtime state via jq)
# - nix-config.json: Plugins/marketplaces for TypeScript to consume
#
# MINIMAL Configuration (February 2026):
# - 1 MCP server (ref) - SOTA docs, 60-95% fewer tokens
# - 1 plugin (ralph-wiggum) - Autonomous loops only
# - 0 extra marketplaces - ralph-wiggum is in default marketplace
# - 1 DXT extension (Filesystem) - 5 focused allowed directories
{
  config,
  lib,
  ...
}:
let
  inherit (lib)
    concatStringsSep
    mapAttrs
    filterAttrs
    hasSuffix
    mkEnableOption
    mkIf
    removeSuffix
    toUpper
    ;

  # Determinate Nix profile paths (in priority order)
  # Uses $USER for portability - resolved at shell runtime, not Nix evaluation
  nixPaths = [
    "/etc/profiles/per-user/$USER/bin"
    "/run/current-system/sw/bin"
    "/nix/var/nix/profiles/default/bin"
    "$HOME/.nix-profile/bin"
    "$HOME/.local/bin" # For uvx (Python MCP servers)
  ];
  pathString = concatStringsSep ":" nixPaths;

  # Generic MCP secrets path (shared across Claude, Gemini, Cursor, etc.)
  mcpSecretsPath = "$HOME/.config/mcp";

  # ═══════════════════════════════════════════════════════════════════════════
  # MCP SERVERS SSOT (January 2026 - MINIMAL)
  # ═══════════════════════════════════════════════════════════════════════════

  mcpServerDefs = {
    ref = {
      # Ref.tools - 60-95% fewer tokens than context7/fetch alternatives
      # Context-aware documentation search with session deduplication
      # https://ref.tools/
      isHttp = true;
      url = "https://api.ref.tools/mcp";
      apiKeyPath = "${mcpSecretsPath}/ref-api-key";
    };
    ast-grep = {
      # AST-based code search and transformation
      # https://github.com/ast-grep/ast-grep-mcp
      isPython = true;
      package = "git+https://github.com/ast-grep/ast-grep-mcp";
      executable = "ast-grep-server";
      args = [ ];
    };
  };

  # ═══════════════════════════════════════════════════════════════════════════
  # PLUGINS SSOT (January 2026 - MINIMAL)
  # ═══════════════════════════════════════════════════════════════════════════

  pluginDefs = {
    default = [ "ralph-wiggum" ]; # Autonomous loops only
  };

  enabledPlugins =
    let
      mkPluginEntry = marketplace: plugin: {
        name = "${plugin}@${marketplace}";
        value = true;
      };
      defaultPlugins = map (mkPluginEntry "claude-code-plugins") pluginDefs.default;
    in
    builtins.listToAttrs defaultPlugins;

  marketplaceDefs = { }; # Empty - ralph-wiggum is in default marketplace

  # JSON for direct injection into .claude.json (no intermediate file needed)
  enabledPluginsJson = builtins.toJSON enabledPlugins;

  # ═══════════════════════════════════════════════════════════════════════════
  # CLAUDE DESKTOP EXTENSIONS SSOT (February 2026)
  # ═══════════════════════════════════════════════════════════════════════════

  # Filesystem extension allowed directories (SOTA: 3-5 focused directories)
  # Avoid large repos with node_modules to prevent 31MB+ directory_tree responses
  filesystemAllowedDirs = [
    "$HOME/src/told" # Primary project
    "$HOME/dotfiles" # System config
    "$HOME/.claude" # Claude state
    "$HOME/Downloads" # File transfers
    "$HOME/Documents" # General docs
  ];

  filesystemExtensionConfig = builtins.toJSON {
    isEnabled = true;
    userConfig = {
      allowed_directories = filesystemAllowedDirs;
    };
  };

  # ═══════════════════════════════════════════════════════════════════════════
  # Format Generators
  # ═══════════════════════════════════════════════════════════════════════════

  # Generic env sourcing from sops-nix decrypted files
  # Uses semicolon (not &&) for independent sourcing - missing files don't block others
  mkEnvSource =
    def:
    let
      envVars = def.envVars or { };
      sources = lib.mapAttrsToList (
        name: path: "[ -f ${path} ] && export ${name}=$(cat ${path})"
      ) envVars;
    in
    if sources == [ ] then "" else (lib.concatStringsSep "; " sources) + "; ";

  # Filter out HTTP and SSE servers for stdio format generators
  stdioServerDefs = filterAttrs (
    _name: def: !(def.isHttp or false) && !(def.isSse or false)
  ) mcpServerDefs;

  # Desktop-only servers (consumer use, not development)
  # Desktop doesn't support HTTP MCP, so only stdio servers
  # MINIMAL: No desktop servers (January 2026)
  desktopOnlyDefs = { };

  # Claude Desktop format: wrap commands in /bin/sh to inject Nix PATH
  # Electron apps don't inherit shell PATH, so we must inject it
  toDesktopFormat =
    _name: def:
    let
      argsString = if def.args or [ ] == [ ] then "" else " " + (concatStringsSep " " def.args);
      envSource = mkEnvSource def;
    in
    if def.isLocal or false then
      {
        # Local servers (e.g., bun scripts) - wrap with PATH injection
        command = "/bin/sh";
        args = [
          "-c"
          "${envSource}PATH=${pathString}:$PATH exec ${def.command}${argsString}"
        ];
      }
    else if def.isPython or false then
      let
        uvxCmd =
          if def.executable or null != null then
            "uvx --from ${def.package} ${def.executable}"
          else
            "uvx ${def.package}";
      in
      {
        # Python packages via uvx
        command = "/bin/sh";
        args = [
          "-c"
          "${envSource}PATH=${pathString}:$PATH exec ${uvxCmd}${argsString}"
        ];
      }
    else
      {
        # npm packages via npx
        command = "/bin/sh";
        args = [
          "-c"
          "${envSource}PATH=${pathString}:$PATH exec npx -y ${def.package}${argsString}"
        ];
      };

  # Derive placeholder name from secret file path
  # e.g., "~/.config/mcp/exa-api-key" → "__EXA_KEY__"
  # e.g., "~/.config/mcp/github-token" → "__GITHUB_TOKEN__"
  secretPathToPlaceholder =
    path:
    let
      filename = builtins.baseNameOf path;
    in
    if hasSuffix "-api-key" filename then
      let
        prefix = removeSuffix "-api-key" filename;
      in
      "__${toUpper prefix}_KEY__"
    else if hasSuffix "-token" filename then
      let
        prefix = removeSuffix "-token" filename;
      in
      "__${toUpper prefix}_TOKEN__"
    else
      throw "Unknown secret format: ${filename}. Expected *-api-key or *-token";

  # Claude Code CLI format: direct commands (shell has PATH)
  # Uses env field for secrets (cleaner than shell wrapper)
  toCliFormat =
    _name: def:
    let
      hasEnvVars = (def.envVars or { }) != { };
      # Generate env with placeholder values for runtime substitution
      envWithPlaceholders = mapAttrs (_: secretPathToPlaceholder) (def.envVars or { });
    in
    if def.isLocal or false then
      {
        command = def.command;
        args = def.args;
        type = "stdio";
      }
    else if def.isPython or false then
      {
        # Python packages via uvx
        command = "uvx";
        args =
          (
            if def.executable or null != null then
              [
                "--from"
                def.package
                def.executable
              ]
            else
              [ def.package ]
          )
          ++ (def.args or [ ]);
        type = "stdio";
      }
    else if hasEnvVars then
      {
        # npm packages with env vars - use env field with placeholders
        command = "npx";
        args = [
          "-y"
          def.package
        ]
        ++ def.args;
        type = "stdio";
        env = envWithPlaceholders;
      }
    else
      {
        # npm packages via npx
        command = "npx";
        args = [
          "-y"
          def.package
        ]
        ++ def.args;
        type = "stdio";
      };

  # Generate stdio server configs
  desktopStdioServers = mapAttrs toDesktopFormat desktopOnlyDefs; # Only exa for Desktop
  cliStdioServers = mapAttrs toCliFormat stdioServerDefs;

  # HTTP server format for CLI (with placeholder for runtime API key injection)
  # Placeholder format: __SERVERNAME_KEY__ (e.g., __REF_KEY__)
  toCliHttpFormat = name: def: {
    type = "http";
    url = "${def.url}?apiKey=__${toUpper name}_KEY__";
  };

  # SSE server format for CLI (OAuth-based, no API key needed)
  toCliSseFormat = _name: def: {
    type = "sse";
    url = def.url;
  };

  # Filter and generate HTTP server configs (CLI only - Desktop doesn't support HTTP)
  httpServerDefs = filterAttrs (_name: def: def.isHttp or false) mcpServerDefs;
  cliHttpServers = mapAttrs toCliHttpFormat httpServerDefs;

  # Filter and generate SSE server configs (CLI only - Desktop doesn't support SSE)
  sseServerDefs = filterAttrs (_name: def: def.isSse or false) mcpServerDefs;
  cliSseServers = mapAttrs toCliSseFormat sseServerDefs;

  # Combine stdio + HTTP + SSE for full CLI config
  cliAllServers = cliStdioServers // cliHttpServers // cliSseServers;
  cliAllJson = builtins.toJSON cliAllServers;

  # Pre-compute JSON fragments for activation script (strip outer braces)
  desktopStdioJson = builtins.toJSON desktopStdioServers;
  desktopStdioFragment = builtins.substring 1 (
    builtins.stringLength desktopStdioJson - 2
  ) desktopStdioJson;

  # Config JSON for Claude Code CLI (all servers - stdio + HTTP)
  cliConfigJson = builtins.toJSON cliAllServers;
in
{
  options.modules.home.apps.mcp = {
    enable = mkEnableOption "MCP servers for Claude Desktop, Code CLI, and other agentic IDEs";

    # Expose CLI config for other modules to use
    cliMcpServersJson = lib.mkOption {
      type = lib.types.str;
      default = cliConfigJson;
      readOnly = true;
      description = "Generated MCP servers JSON for Claude Code CLI";
    };
  };

  config = mkIf config.modules.home.apps.mcp.enable {
    # ═══════════════════════════════════════════════════════════════════════════
    # Claude Settings & Skills (SSOT - symlinks to Quality System generated files)
    # ═══════════════════════════════════════════════════════════════════════════

    home.file.".claude/settings.json" = {
      source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/dotfiles/config/quality/generated/claude/settings.json";
    };

    home.file.".claude/skills" = {
      source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/dotfiles/config/quality/generated/claude/skills";
    };

    home.file.".claude/agents" = {
      source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/dotfiles/config/quality/generated/claude/personas";
    };

    home.file.".claude/commands" = {
      source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/dotfiles/config/quality/commands";
    };

    # ═══════════════════════════════════════════════════════════════════════════
    # MCP Config Generation (Activation-time for HTTP server API key injection)
    # ═══════════════════════════════════════════════════════════════════════════

    # Generate Claude Desktop config (MINIMAL: 0 MCP servers, 1 DXT extension)
    home.activation.generateMcpConfigs = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      DESKTOP_CONFIG="${config.home.homeDirectory}/Library/Application Support/Claude/claude_desktop_config.json"
      mkdir -p "$(dirname "$DESKTOP_CONFIG")"

      cat > "$DESKTOP_CONFIG" << 'DESKTOPEOF'
      {
        "mcpServers": {}
      }
      DESKTOPEOF

      echo "Claude Desktop config generated (0 MCP servers - MINIMAL)"
    '';

    # Generate Claude Desktop Filesystem extension settings (SSOT for allowed_directories)
    home.activation.generateFilesystemExtensionConfig = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      EXT_SETTINGS_DIR="${config.home.homeDirectory}/Library/Application Support/Claude/Claude Extensions Settings"
      EXT_CONFIG="$EXT_SETTINGS_DIR/ant.dir.ant.anthropic.filesystem.json"
      mkdir -p "$EXT_SETTINGS_DIR"

      # Expand $HOME in allowed_directories paths
      cat > "$EXT_CONFIG" << 'EXTEOF'
      ${filesystemExtensionConfig}
      EXTEOF

      # Replace $HOME with actual home directory
      sed -i "" "s|\$HOME|${config.home.homeDirectory}|g" "$EXT_CONFIG"

      echo "Filesystem extension config generated (5 allowed directories from SSOT)"
    '';

    # Generate Claude Code CLI config (~/.claude.json)
    # Uses jq to MERGE mcpServers + enabledPlugins with existing runtime state
    # Runtime state includes: numStartups, oauthAccount, projects, etc. (31+ keys)
    # MINIMAL: 1 server (ref), 1 plugin (ralph-wiggum)
    home.activation.generateClaudeCodeConfig = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      MCP_SECRETS="${config.home.homeDirectory}/.config/mcp"
      CLAUDE_CODE_CONFIG="${config.home.homeDirectory}/.claude.json"

      # Read API key for ref server
      REF_KEY=""
      [ -f "$MCP_SECRETS/ref-api-key" ] && REF_KEY=$(cat "$MCP_SECRETS/ref-api-key")

      # MCP servers JSON from Nix SSOT (with placeholders for secrets)
      MCP_SERVERS='${cliAllJson}'
      ENABLED_PLUGINS='${enabledPluginsJson}'

      # Substitute placeholder with actual secret value
      MCP_SERVERS=$(echo "$MCP_SERVERS" | sed "s/__REF_KEY__/$REF_KEY/g")

      # Merge with existing config (preserve runtime state)
      if [ -f "$CLAUDE_CODE_CONFIG" ]; then
        MERGED=$(jq --argjson servers "$MCP_SERVERS" --argjson plugins "$ENABLED_PLUGINS" \
          '.mcpServers = $servers | .enabledPlugins = $plugins' "$CLAUDE_CODE_CONFIG")
        echo "$MERGED" > "$CLAUDE_CODE_CONFIG"
        echo "Claude Code config updated (1 server, 1 plugin from SSOT)"
      else
        echo "{\"mcpServers\": $MCP_SERVERS, \"enabledPlugins\": $ENABLED_PLUGINS}" > "$CLAUDE_CODE_CONFIG"
        echo "Claude Code config created (1 server, 1 plugin from SSOT)"
      fi
    '';

    # Generate Quality System artifacts (skills, personas, rules, settings)
    home.activation.generateQuality = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      QUALITY_DIR="${config.home.homeDirectory}/dotfiles/config/quality"
      BUN="/etc/profiles/per-user/${config.home.username}/bin/bun"

      if [ -f "$QUALITY_DIR/package.json" ]; then
        echo "Generating Intelligence artifacts..."
        cd "$QUALITY_DIR"

        if ! $BUN install --frozen-lockfile; then
          echo "ERROR: bun install failed in $QUALITY_DIR"
          exit 1
        fi

        if ! $BUN run generate; then
          echo "ERROR: Intelligence generation failed in $QUALITY_DIR"
          exit 1
        fi

        echo "Intelligence System artifacts generated successfully"
      fi
    '';

    # Cleanup old plan and todo files (7-day retention)
    # Runs on every `darwin-rebuild switch` or `home-manager switch`
    home.activation.cleanupClaudeEphemeral = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      PLANS_DIR="${config.home.homeDirectory}/.claude/plans"
      TODOS_DIR="${config.home.homeDirectory}/.claude/todos"

      # Delete plan files older than 7 days
      if [ -d "$PLANS_DIR" ]; then
        /usr/bin/find "$PLANS_DIR" -name "*.md" -mtime +7 -type f -delete 2>/dev/null || true
        echo "Claude plans cleanup: removed files older than 7 days"
      fi

      # Delete todo files older than 7 days
      if [ -d "$TODOS_DIR" ]; then
        /usr/bin/find "$TODOS_DIR" -name "*.json" -mtime +7 -type f -delete 2>/dev/null || true
        echo "Claude todos cleanup: removed files older than 7 days"
      fi
    '';

    # ═══════════════════════════════════════════════════════════════════════════
    # LAUNCHD AGENTS (SOTA Log Rotation - February 2026)
    # ═══════════════════════════════════════════════════════════════════════════

    # Claude Desktop log rotation - runs daily at 3am
    # Deletes logs >10MB to prevent disk bloat from large MCP responses
    # SOTA: Keep logs manageable, Filesystem extension can produce 31MB+ responses
    launchd.agents.claude-log-rotation = {
      enable = true;
      config = {
        Label = "com.claude.log-rotation";
        ProgramArguments = [
          "/bin/sh"
          "-c"
          ''
            LOG_DIR="$HOME/Library/Logs/Claude"
            if [ -d "$LOG_DIR" ]; then
              # Delete logs larger than 10MB
              /usr/bin/find "$LOG_DIR" -name "*.log" -size +10M -delete 2>/dev/null
              # Delete rotated logs (numbered backups)
              /usr/bin/find "$LOG_DIR" -name "*.log.*" -mtime +7 -delete 2>/dev/null
              echo "$(date): Claude log rotation completed" >> /tmp/claude-log-rotation.log
            fi
          ''
        ];
        StartCalendarInterval = [
          {
            Hour = 3;
            Minute = 0;
          }
        ];
        StandardOutPath = "/tmp/claude-log-rotation.log";
        StandardErrorPath = "/tmp/claude-log-rotation.err";
      };
    };
  };
}

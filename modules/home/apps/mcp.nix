# Generic MCP Server Single Source of Truth
# Generates configs for: Claude Desktop and provides setup script for Claude Code CLI
#
# ARCHITECTURE (December 2025):
# - Claude Desktop: Reads ~/Library/Application Support/Claude/claude_desktop_config.json
#   → Generated by this Nix module (Electron app needs PATH injection)
# - Claude Code CLI: Reads ~/.claude.json (managed by `claude mcp add/remove` commands)
#   → NOT managed by Nix directly. Run `setup-claude-mcps` after darwin-rebuild.
#
# Token Optimization (December 2025):
# - Reduced from 16 to 6 MCP servers (~75% token reduction)
# - SOTA servers: Ref.tools (60-95% fewer tokens), Exa AI (code search)
# - Removed redundant servers that duplicate native Claude Code capabilities
{
  config,
  lib,
  ...
}:
let
  inherit (lib)
    concatStringsSep
    mapAttrs
    filterAttrs
    mkEnableOption
    mkIf
    ;

  # Determinate Nix profile paths (in priority order)
  nixPaths = [
    "/etc/profiles/per-user/hank/bin"
    "/run/current-system/sw/bin"
    "/nix/var/nix/profiles/default/bin"
    "$HOME/.nix-profile/bin"
    "$HOME/.local/bin" # For uvx (Python MCP servers)
  ];
  pathString = concatStringsSep ":" nixPaths;

  # Generic MCP secrets path (shared across Claude, Gemini, Cursor, etc.)
  mcpSecretsPath = "$HOME/.config/mcp";

  # ═══════════════════════════════════════════════════════════════════════════
  # SINGLE SOURCE OF TRUTH: MCP Server Definitions (Optimized December 2025)
  # ═══════════════════════════════════════════════════════════════════════════
  # Target: <25k tokens (down from ~116k)
  # Strategy: SOTA search/docs (Ref, Exa) + unique capabilities only
  mcpServerDefs = {
    # ═══════════════════════════════════════════════════════════════════════════
    # DOCUMENTATION & SEARCH (State-of-the-Art - December 2025)
    # ═══════════════════════════════════════════════════════════════════════════

    ref = {
      # Ref.tools - 60-95% fewer tokens than context7/fetch alternatives
      # Context-aware documentation search with session deduplication
      # https://ref.tools/
      isHttp = true;
      url = "https://api.ref.tools/mcp";
      # API key will be appended at activation time from sops-nix
      apiKeyPath = "${mcpSecretsPath}/ref-api-key";
    };

    exa = {
      # Exa AI - Code context search across billions of repos
      # Tools: get_code_context_exa, web_search_exa
      # https://exa.ai/
      package = "exa-mcp-server";
      args = [ ];
      envVars = {
        EXA_API_KEY = "${mcpSecretsPath}/exa-api-key";
      };
    };

    # ═══════════════════════════════════════════════════════════════════════════
    # UNIQUE CAPABILITIES (No native Claude Code equivalent)
    # ═══════════════════════════════════════════════════════════════════════════

    github = {
      # GitHub API: repos, issues, PRs, code search
      # Token sourced from sops-nix secret file
      package = "@modelcontextprotocol/server-github";
      args = [ ];
      envVars = {
        GITHUB_PERSONAL_ACCESS_TOKEN = "${mcpSecretsPath}/github-token";
      };
    };

    playwright = {
      # Browser automation for testing and web interactions
      package = "@playwright/mcp";
      args = [ ];
    };

    ast-grep = {
      # AST-based structural code search across 20+ languages
      package = "@notprolands/ast-grep-mcp";
      args = [ ];
    };

    repomix = {
      # Codebase packaging for AI analysis
      package = "repomix";
      args = [ "--mcp" ];
    };
  };

  # ═══════════════════════════════════════════════════════════════════════════
  # Format Generators
  # ═══════════════════════════════════════════════════════════════════════════

  # Generic env sourcing from sops-nix decrypted files
  # Uses semicolon (not &&) for independent sourcing - missing files don't block others
  mkEnvSource =
    def:
    let
      envVars = def.envVars or { };
      sources = lib.mapAttrsToList (
        name: path: "[ -f ${path} ] && export ${name}=$(cat ${path})"
      ) envVars;
    in
    if sources == [ ] then "" else (lib.concatStringsSep "; " sources) + "; ";

  # Filter out HTTP servers for stdio format generators
  stdioServerDefs = filterAttrs (_name: def: !(def.isHttp or false)) mcpServerDefs;

  # Claude Desktop format: wrap commands in /bin/sh to inject Nix PATH
  # Electron apps don't inherit shell PATH, so we must inject it
  toDesktopFormat =
    _name: def:
    let
      argsString = if def.args or [ ] == [ ] then "" else " " + (concatStringsSep " " def.args);
      envSource = mkEnvSource def;
    in
    if def.isLocal or false then
      {
        # Local servers (e.g., bun scripts) - wrap with PATH injection
        command = "/bin/sh";
        args = [
          "-c"
          "${envSource}PATH=${pathString}:$PATH exec ${def.command}${argsString}"
        ];
      }
    else if def.isPython or false then
      {
        # Python packages via uvx
        command = "/bin/sh";
        args = [
          "-c"
          "${envSource}PATH=${pathString}:$PATH exec uvx ${def.package}${argsString}"
        ];
      }
    else
      {
        # npm packages via npx
        command = "/bin/sh";
        args = [
          "-c"
          "${envSource}PATH=${pathString}:$PATH exec npx -y ${def.package}${argsString}"
        ];
      };

  # Claude Code CLI format: direct commands (shell has PATH)
  # For servers needing env vars, we wrap in sh to source secrets
  toCliFormat =
    _name: def:
    let
      envSource = mkEnvSource def;
      needsWrapper = (def.envVars or { }) != { };
    in
    if def.isLocal or false then
      {
        command = def.command;
        args = def.args;
        type = "stdio";
      }
    else if def.isPython or false then
      {
        # Python packages via uvx
        command = "uvx";
        args = [ def.package ] ++ def.args;
        type = "stdio";
      }
    else if needsWrapper then
      {
        # npm packages that need env vars - wrap in shell
        command = "/bin/sh";
        args = [
          "-c"
          "${envSource}exec npx -y ${def.package}${
            if def.args == [ ] then "" else " " + (concatStringsSep " " def.args)
          }"
        ];
        type = "stdio";
      }
    else
      {
        # npm packages via npx
        command = "npx";
        args = [
          "-y"
          def.package
        ]
        ++ def.args;
        type = "stdio";
      };

  # Generate stdio server configs
  desktopStdioServers = mapAttrs toDesktopFormat stdioServerDefs;
  cliStdioServers = mapAttrs toCliFormat stdioServerDefs;

  # Pre-compute JSON fragments for activation script (strip outer braces)
  desktopStdioJson = builtins.toJSON desktopStdioServers;
  desktopStdioFragment = builtins.substring 1 (
    builtins.stringLength desktopStdioJson - 2
  ) desktopStdioJson;

  cliStdioJson = builtins.toJSON cliStdioServers;
  cliStdioFragment = builtins.substring 1 (builtins.stringLength cliStdioJson - 2) cliStdioJson;

  # Config JSON for Claude Code CLI (stdio servers only - HTTP added at activation)
  cliConfigJson = builtins.toJSON cliStdioServers;
in
{
  options.modules.home.apps.mcp = {
    enable = mkEnableOption "MCP servers for Claude Desktop, Code CLI, and other agentic IDEs";

    # Expose CLI config for other modules to use
    cliMcpServersJson = lib.mkOption {
      type = lib.types.str;
      default = cliConfigJson;
      readOnly = true;
      description = "Generated MCP servers JSON for Claude Code CLI";
    };
  };

  config = mkIf config.modules.home.apps.mcp.enable {
    # ═══════════════════════════════════════════════════════════════════════════
    # Claude Settings & Skills (SSOT - symlinks to Quality System generated files)
    # ═══════════════════════════════════════════════════════════════════════════

    home.file.".claude/settings.json" = {
      source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/dotfiles/config/quality/generated/claude/settings.json";
    };

    home.file.".claude/skills" = {
      source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/dotfiles/config/quality/generated/claude/skills";
    };

    home.file.".claude/agents" = {
      source = config.lib.file.mkOutOfStoreSymlink "${config.home.homeDirectory}/dotfiles/config/quality/generated/claude/personas";
    };

    # ═══════════════════════════════════════════════════════════════════════════
    # Claude Code CLI Setup Script
    # ═══════════════════════════════════════════════════════════════════════════
    # Claude Code CLI manages its own MCPs via ~/.claude.json
    # Run this script after darwin-rebuild to configure MCPs reproducibly

    home.file.".local/bin/setup-claude-mcps" = {
      executable = true;
      text = ''
        #!/usr/bin/env bash
        set -euo pipefail

        # ═══════════════════════════════════════════════════════════════════════════
        # Claude Code MCP Setup Script
        # Generated by mcp.nix - SINGLE SOURCE OF TRUTH
        #
        # Architecture:
        # - This script manages Claude Code CLI MCPs (~/.claude.json)
        # - Claude Desktop is managed by Nix activation (separate config)
        # - API keys sourced from sops-nix: ~/.config/mcp/
        #
        # Idempotency: Safe to run multiple times, always produces same result
        # ═══════════════════════════════════════════════════════════════════════════

        MCP_SECRETS="$HOME/.config/mcp"
        REQUIRED_SERVERS=6

        echo "═══════════════════════════════════════════════════════════════════════════"
        echo "Claude Code MCP Setup - $(date '+%Y-%m-%d %H:%M:%S')"
        echo "═══════════════════════════════════════════════════════════════════════════"
        echo ""

        # ─────────────────────────────────────────────────────────────────────────────
        # STEP 1: Clean Slate (remove ALL existing MCPs for idempotency)
        # ─────────────────────────────────────────────────────────────────────────────
        echo "Step 1: Removing all existing MCPs (clean slate)..."

        # Get list of all current MCPs
        CURRENT_MCPS=$(claude mcp list 2>/dev/null | grep -E "^[a-z]" | awk '{print $1}' | tr -d ':' || true)

        for mcp in $CURRENT_MCPS; do
          claude mcp remove "$mcp" 2>/dev/null && echo "  Removed $mcp" || true
        done

        echo ""

        # ─────────────────────────────────────────────────────────────────────────────
        # STEP 2: Verify Prerequisites
        # ─────────────────────────────────────────────────────────────────────────────
        echo "Step 2: Verifying prerequisites..."

        MISSING_SECRETS=()

        [ ! -f "$MCP_SECRETS/ref-api-key" ] && MISSING_SECRETS+=("ref-api-key")
        [ ! -f "$MCP_SECRETS/exa-api-key" ] && MISSING_SECRETS+=("exa-api-key")
        [ ! -f "$MCP_SECRETS/github-token" ] && MISSING_SECRETS+=("github-token")

        if [ ''${#MISSING_SECRETS[@]} -gt 0 ]; then
          echo "  Warning: Missing secrets (MCPs will be skipped):"
          for secret in "''${MISSING_SECRETS[@]}"; do
            echo "    - $MCP_SECRETS/$secret"
          done
        else
          echo "  All secrets present"
        fi

        echo ""

        # ─────────────────────────────────────────────────────────────────────────────
        # STEP 3: Add MCPs (canonical set of 6)
        # ─────────────────────────────────────────────────────────────────────────────
        echo "Step 3: Adding MCPs..."

        ADDED=0
        SKIPPED=0

        # --- 1. Ref.tools (SOTA documentation - HTTP transport) ---
        if [ -f "$MCP_SECRETS/ref-api-key" ]; then
          REF_KEY=$(cat "$MCP_SECRETS/ref-api-key")
          claude mcp add ref \
            --transport http \
            "https://api.ref.tools/mcp?apiKey=$REF_KEY" \
            --scope user
          echo "  [1/6] ref - SOTA documentation (HTTP)"
          ((ADDED++))
        else
          echo "  [1/6] ref - SKIPPED (no API key)"
          ((SKIPPED++))
        fi

        # --- 2. Exa AI (SOTA code search - stdio transport) ---
        if [ -f "$MCP_SECRETS/exa-api-key" ]; then
          EXA_KEY=$(cat "$MCP_SECRETS/exa-api-key")
          claude mcp add exa \
            --scope user \
            --env EXA_API_KEY="$EXA_KEY" \
            -- npx -y exa-mcp-server
          echo "  [2/6] exa - SOTA code search (stdio)"
          ((ADDED++))
        else
          echo "  [2/6] exa - SKIPPED (no API key)"
          ((SKIPPED++))
        fi

        # --- 3. GitHub (PR/issue workflows - stdio transport) ---
        if [ -f "$MCP_SECRETS/github-token" ]; then
          GH_TOKEN=$(cat "$MCP_SECRETS/github-token")
          claude mcp add github \
            --scope user \
            --env GITHUB_PERSONAL_ACCESS_TOKEN="$GH_TOKEN" \
            -- npx -y @modelcontextprotocol/server-github
          echo "  [3/6] github - PR/issue workflows (stdio)"
          ((ADDED++))
        else
          echo "  [3/6] github - SKIPPED (no token)"
          ((SKIPPED++))
        fi

        # --- 4. Playwright (browser automation - no auth) ---
        claude mcp add playwright \
          --scope user \
          -- npx -y @playwright/mcp
        echo "  [4/6] playwright - Browser automation (stdio)"
        ((ADDED++))

        # --- 5. AST-grep (semantic code search - no auth) ---
        claude mcp add ast-grep \
          --scope user \
          -- npx -y @notprolands/ast-grep-mcp
        echo "  [5/6] ast-grep - Semantic code search (stdio)"
        ((ADDED++))

        # --- 6. Repomix (codebase packaging - no auth) ---
        claude mcp add repomix \
          --scope user \
          -- npx -y repomix --mcp
        echo "  [6/6] repomix - Codebase packaging (stdio)"
        ((ADDED++))

        echo ""

        # ─────────────────────────────────────────────────────────────────────────────
        # STEP 4: Verify Configuration
        # ─────────────────────────────────────────────────────────────────────────────
        echo "Step 4: Verifying configuration..."
        echo ""

        claude mcp list

        echo ""

        # Count configured servers
        CONFIGURED=$(cat ~/.claude.json 2>/dev/null | jq -r '.mcpServers | keys | length' || echo 0)

        echo "═══════════════════════════════════════════════════════════════════════════"
        echo "RESULTS"
        echo "═══════════════════════════════════════════════════════════════════════════"
        echo "  Added:      $ADDED"
        echo "  Skipped:    $SKIPPED"
        echo "  Configured: $CONFIGURED"
        echo ""

        if [ "$CONFIGURED" -lt "$REQUIRED_SERVERS" ]; then
          echo "WARNING: Only $CONFIGURED of $REQUIRED_SERVERS servers configured"
          echo "  Check missing secrets or server health"
        else
          echo "All $CONFIGURED MCP servers configured"
        fi

        echo ""
        echo "Next steps:"
        echo "  1. Start a new Claude Code session"
        echo "  2. Run /context to verify MCP tokens < 25k"
        echo "═══════════════════════════════════════════════════════════════════════════"
      '';
    };

    # ═══════════════════════════════════════════════════════════════════════════
    # MCP Config Generation (Activation-time for HTTP server API key injection)
    # ═══════════════════════════════════════════════════════════════════════════

    # Generate MCP configs at activation time (after sops decryption)
    # This allows HTTP servers like Ref to have API keys injected into URLs
    home.activation.generateMcpConfigs = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
            MCP_SECRETS="${config.home.homeDirectory}/.config/mcp"

            # Read API key for Ref HTTP server
            REF_KEY=""
            if [ -f "$MCP_SECRETS/ref-api-key" ]; then
              REF_KEY=$(cat "$MCP_SECRETS/ref-api-key")
            fi

            # Generate Claude Desktop config with HTTP servers
            DESKTOP_CONFIG="${config.home.homeDirectory}/Library/Application Support/Claude/claude_desktop_config.json"
            mkdir -p "$(dirname "$DESKTOP_CONFIG")"

            # Combine stdio servers (from Nix) with HTTP servers (runtime key injection)
            cat > "$DESKTOP_CONFIG" << DESKTOPEOF
      {
        "mcpServers": {
          "ref": {
            "type": "http",
            "url": "https://api.ref.tools/mcp?apiKey=$REF_KEY"
          },
          ${desktopStdioFragment}
        }
      }
      DESKTOPEOF

            echo "Claude Desktop config generated (6 servers)"
            echo "For Claude Code CLI, run: setup-claude-mcps"
    '';

    # Generate Quality System artifacts (skills, personas, rules, settings)
    # Runs after writeBoundary to ensure all files are in place
    home.activation.generateQuality = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      QUALITY_DIR="${config.home.homeDirectory}/dotfiles/config/quality"
      BUN="/etc/profiles/per-user/${config.home.username}/bin/bun"

      if [ -f "$QUALITY_DIR/package.json" ]; then
        echo "Generating Intelligence artifacts..."
        cd "$QUALITY_DIR"

        if ! $BUN install --frozen-lockfile; then
          echo "ERROR: bun install failed in $QUALITY_DIR"
          exit 1
        fi

        if ! $BUN run generate; then
          echo "ERROR: Intelligence generation failed in $QUALITY_DIR"
          exit 1
        fi

        echo "Intelligence System artifacts generated successfully"
      fi
    '';
  };
}

This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
models/
  extracts.ts
  message.ts
orchestrator/
  tools/
    mnr.ts
  anthropic.ts
  gemini.ts
  orchestrator.ts
app.ts
infra.ts
main.ts
parser.test.ts
parser.ts
platform.ts
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="models/extracts.ts">
import type { SchemaLike } from "@anterior/lib-platform/schema";
import * as z from "@anterior/lib-platform/zod";
import { clinicalExtraction } from "../../@anterior/models/s3/clinical_extraction.ts";

export const extractsSchema = z.object({
	extracts: clinicalExtraction.shape.extracts,
	pdf_path: z.string(),
});

export type Extracts = z.infer<typeof extractsSchema>;

export type BoundingBox = {
	top: number;
	right: number;
	bottom: number;
	left: number;
};

export const boundingBoxSchema = z.object({
	top: z.number().gte(0).lte(1),
	right: z.number().gte(0).lte(1),
	bottom: z.number().gte(0).lte(1),
	left: z.number().gte(0).lte(1),
}) satisfies SchemaLike<BoundingBox>;

export type ReductoVertices = Array<[number, number]>;

export type ExtractBlock = {
	extractId: string;
	blockId: number | null;
	pageNumber: number | null;
	boundingBox: BoundingBox;
	text: string;
};

export const extractBlockSchema = z.object({
	extractId: z.string(),
	blockId: z.number().nullable(),
	pageNumber: z.number().nullable(),
	boundingBox: boundingBoxSchema,
	text: z.string(),
}) satisfies SchemaLike<ExtractBlock>;

export const reductoVerticesSchema = z
	.array(z.tuple([z.number(), z.number()]))
	.length(4) satisfies SchemaLike<ReductoVertices>;

export const blockSchema = clinicalExtraction.shape.extracts.element.shape.blocks.element;
export type Block = z.infer<typeof blockSchema>;
</file>

<file path="models/message.ts">
import { type SchemaLike } from "@anterior/lib-platform/schema";
import * as z from "@anterior/lib-platform/zod";

// *----------------*
// Types
// *----------------*

export type Role = "user" | "assistant" | "system";

export type Section = {
	artifact_id: string;
	section_type: string;
	section_payload?: unknown; // FIXME: `section_payload` is REQUIRED, change when `zod/v4` is released
};

export type FinishReason =
	| "end_turn"
	| "max_tokens"
	| "stop_sequence"
	| "tool_use"
	| "tool_result"
	| "error";

export type Citation = {
	from: Section;
	to: Section;
};

export type MessageMetadata = {
	finish_reason?: FinishReason | undefined; // FIXME: Finish reason must be a string if present, change when `zod/v4` is released
	model_name?: string | undefined; // FIXME: Model name must be a string if present, change when `zod/v4` is released
};

export type TextContentBlock = {
	content_type: "text";
	text: string;
	citations?: Citation[] | undefined; // FIXME: Citations must be an array if present, change when `zod/v4` is released
};

export type MarkdownContentBlock = {
	content_type: "markdown";
	markdown: string;
	citations?: Citation[] | undefined; // FIXME: Citations must be an array if present, change when `zod/v4` is released
};

export type ImageContentBlock = {
	content_type: "image";
	image_url: string;
	alt_text?: string | undefined; // FIXME: Alt text must be a string if present, change when `zod/v4` is released
};

export type ToolUseContentBlock = {
	content_type: "tool_use";
	tool_name: string;
	tool_parameters: Record<string, unknown>;
	tool_id?: string | undefined; // FIXME: Tool ID must be a string if present, change when `zod/v4` is released
};

export type AgentHandoffContentBlock = {
	content_type: "agent_handoff";
	agent_name: string;
};

export type ContentBlock =
	| TextContentBlock
	| MarkdownContentBlock
	| ImageContentBlock
	| ToolUseContentBlock
	| AgentHandoffContentBlock;

export type ChatMessage = {
	message_id: string;
	timestamp: string;
	role: Role;
	content: ContentBlock[];
	metadata?: MessageMetadata | undefined; // FIXME: Metadata must be an object if present, change when `zod/v4` is released
};

export type ChatRequestMessage = {
	role: Role;
	content: ContentBlock[];
};

export type ChatRequestBody = {
	stem_id: string;
	messages: ChatMessage[];
	new_message: ChatRequestMessage;
	pdf_ids: string[];
};

// *----------------*
// Schemas
// *----------------*

export const sectionSchema = z.object({
	artifact_id: z.string(),
	section_type: z.string(),
	section_payload: z.unknown(),
}) satisfies SchemaLike<Section>;

export const citationSchema = z.object({
	from: sectionSchema,
	to: sectionSchema,
}) satisfies SchemaLike<Citation>;

export const contentBlockSchema = z.discriminatedUnion("content_type", [
	z.object({
		content_type: z.literal("text"),
		text: z.string(),
		citations: z.array(citationSchema).optional(),
	}),
	z.object({
		content_type: z.literal("markdown"),
		markdown: z.string(),
		citations: z.array(citationSchema).optional(),
	}),
	z.object({
		content_type: z.literal("image"),
		image_url: z.string().url(),
		alt_text: z.string().optional(),
	}),
	z.object({
		content_type: z.literal("tool_use"),
		tool_name: z.string(),
		tool_parameters: z.record(z.unknown()),
		tool_id: z.string().optional(),
	}),
	z.object({
		content_type: z.literal("agent_handoff"),
		agent_name: z.string(),
	}),
]) satisfies SchemaLike<ContentBlock>;

export const finishReasonSchema = z.enum([
	"end_turn",
	"max_tokens",
	"stop_sequence",
	"tool_use",
	"tool_result",
	"error",
]) satisfies SchemaLike<FinishReason>;

export const messageMetadataSchema = z.object({
	finish_reason: finishReasonSchema.optional(),
	model_name: z.string().optional(),
}) satisfies SchemaLike<MessageMetadata>;

export const roleSchema = z.enum(["user", "assistant", "system"]) satisfies SchemaLike<Role>;

export const chatMessageSchema = z.object({
	message_id: z.string(),
	timestamp: z.string().datetime(),
	role: roleSchema,
	content: z.array(contentBlockSchema).min(1),
	metadata: messageMetadataSchema.optional(),
}) satisfies SchemaLike<ChatMessage>;

export const chatRequestMessageSchema = z.object({
	role: roleSchema,
	content: z.array(contentBlockSchema).min(1),
}) satisfies SchemaLike<ChatRequestMessage>;

export const chatRequestBodySchema = z.object({
	stem_id: z.string(),
	messages: z.array(chatMessageSchema),
	new_message: chatRequestMessageSchema,
	pdf_ids: z.array(z.string()),
	provider: z.enum(["anthropic", "gemini"]).optional(),
}) satisfies SchemaLike<ChatRequestBody>;
</file>

<file path="orchestrator/tools/mnr.ts">
import type { Logger } from "@anterior/lib-platform/log";
import type { SchemaLike } from "@anterior/lib-platform/schema";
import { z } from "@anterior/lib-platform/zod";
import type { Messages } from "@anthropic-ai/sdk/resources/messages";
import type { Platform } from "../../platform.ts";

export type MnrToolInput = {
	clinicals_uri: string;
	guideline_uri: string;
	requested_service_description?: string | undefined;
	indication_description?: string | undefined;
	cpt_code?: string | undefined;
	icd_10_code?: string | undefined;
	hcpcs_code?: string | undefined;
};

export const mnrToolInputSchema = z.object({
	clinicals_uri: z.string(),
	guideline_uri: z.string(),
	requested_service_description: z.string().optional(),
	indication_description: z.string().optional(),
	cpt_code: z.string().optional(),
	icd_10_code: z.string().optional(),
	hcpcs_code: z.string().optional(),
}) satisfies SchemaLike<MnrToolInput>;

export class MnrTool {
	private logger: Logger;
	private platform: Platform;

	constructor(logger: Logger, platform: Platform) {
		this.logger = logger;
		this.platform = platform;
	}

	getToolDefinition(): Messages.Tool {
		return {
			name: "perform_mnr",
			description: "Performs Medical Necessity Review on clinical documents",
			input_schema: {
				type: "object",
				properties: {
					clinicals_uri: {
						type: "string",
						description: "URI to the clinical document that needs to be reviewed",
					},
					guideline_uri: {
						type: "string",
						description: "URI to the guideline document to use for the review",
					},
					requested_service_description: {
						type: "string",
						description: "Description of the requested medical service",
					},
					indication_description: {
						type: "string",
						description: "Description of the medical indication",
					},
					cpt_code: {
						type: "string",
						description: "CPT code for the procedure",
					},
					icd_10_code: {
						type: "string",
						description: "ICD-10 diagnosis code",
					},
					hcpcs_code: {
						type: "string",
						description: "HCPCS code for the procedure or service",
					},
				},
				required: ["clinicals_uri", "guideline_uri"],
			},
		};
	}

	execute(rawInput: unknown): string {
		// Parse & validate input with zod – throws on invalid structure.
		const input = mnrToolInputSchema.parse(rawInput);

		this.logger.info({
			msg: "Executing perform_mnr tool",
			clinicalsUri: input.clinicals_uri,
			guidelineUri: input.guideline_uri,
		});

		const mockResult = {
			assessment: "APPROVED",
			reason: "The clinical documentation supports medical necessity based on guideline criteria.",
			matching_criteria: [
				"Patient age and condition meets guideline requirements",
				"Documented previous treatments align with step therapy protocols",
				"Clinical evidence supports requested procedure",
			],
			clinical_summary:
				"Patient shows appropriate indications for the requested service based on the clinical documentation.",
		};

		return JSON.stringify(mockResult);
	}
}
</file>

<file path="orchestrator/anthropic.ts">
import { generateRandomId } from "@anterior/lib-platform/ids";
import type { Logger } from "@anterior/lib-platform/log";
import type { Anthropic } from "@anthropic-ai/sdk";
import type { Messages, Tool, ToolUseBlock } from "@anthropic-ai/sdk/resources/messages";
import type { ChatMessage, ContentBlock } from "../models/message.ts";
import type { Platform } from "../platform.ts";
import { LOG_MESSAGES, type Orchestrator } from "./orchestrator.ts";
import { MnrTool, mnrToolInputSchema } from "./tools/mnr.ts";

export const anthropicBlockToText = (block: ContentBlock): string => {
	switch (block.content_type) {
		case "text":
			return block.text;
		case "markdown":
			return block.markdown;
		case "image":
			return block.image_url;
		case "tool_use":
			return block.tool_name;
		case "agent_handoff":
			return block.agent_name;
		default:
			return JSON.stringify(block);
	}
};

export class AnthropicOrchestrator implements Orchestrator {
	static readonly MODEL_NAME = "claude-3-7-sonnet-latest";

	private readonly logger: Logger;
	private client: Anthropic;

	mnrTool: MnrTool;
	constructor(platform: Platform, logger: Logger, client: Anthropic) {
		this.logger = logger;
		this.client = client;
		this.mnrTool = new MnrTool(logger, platform);
	}
	parseMessages<T> (messages: ChatMessage[]): T[] {
		return messages.map((m) => ({
			role: m.role,
			content: m.content.map(anthropicBlockToText).join("\n\n"),
		}));
	}
	getModelName(): string {
		return AnthropicOrchestrator.MODEL_NAME;
	}

	getClient(): Anthropic {
		return this.client;
	}

	protected getTools(): Tool[] {
		return [];
		// return [this.mnrTool.getToolDefinition()];
	}


	protected handleToolCalls(toolCall: Messages.ToolUseBlock): string {
		const { name, id, input } = toolCall;
		if (name === "perform_mnr") {
			try {
				return this.mnrTool.execute(mnrToolInputSchema.parse(input));
			} catch (error) {
				this.logger.error({
					msg: `${LOG_MESSAGES.ERROR_EXECUTING_TOOL} perform_mnr tool`,
					toolName: name,
					toolId: id,
					error,
				});
				return JSON.stringify({ error: "Failed to perform medical necessity review" });
			}
		}

		this.logger.error({
			msg: LOG_MESSAGES.UNKNOWN_TOOL,
			toolName: name,
			toolId: id,
		});
		return JSON.stringify({ error: "Unknown tool" });
	}

	async processChat(messages: ChatMessage[]): Promise<ChatMessage> {
		const parsedMessages = messages.map((m) => ({
			role: m.role,
			content: m.content.map(anthropicBlockToText).join("\n\n"),
		}));

		const tools = this.getTools();

		const requestStart = Date.now();
		const initialResponse = await this.client.messages.create({
			model: AnthropicOrchestrator.MODEL_NAME,
			max_tokens: 1024,
			system: this.getSystemPrompt(),
			messages: parsedMessages,

			tools: tools,
		});
		const requestDuration = Date.now() - requestStart;

		this.logger.info({
			msg: LOG_MESSAGES.LLM_RESPONSE,
			model: AnthropicOrchestrator.MODEL_NAME,
			duration: `${requestDuration}ms`,
			content: initialResponse.content,
			usage: initialResponse.usage,
		});

		let toolUseBlock: ToolUseBlock | undefined;
		let fullResponse = "";

		for (const block of initialResponse.content) {
			if (block.type === "text") {
				fullResponse += block.text;
			} else if (block.type === "tool_use") {
				// Assuming there's always only one tool use block for now
				toolUseBlock = block;

				this.logger.info({
					msg: LOG_MESSAGES.TOOL_USE_DETECTED,
					toolName: block.name,
					toolId: block.id,
					input: block.input,
				});
			}
		}

		if (toolUseBlock) {
			this.logger.info({
				msg: LOG_MESSAGES.EXECUTING_TOOL,
				toolName: toolUseBlock.name,
			});

			const toolStart = Date.now();
			const toolResults = this.handleToolCalls(toolUseBlock);
			const toolDuration = Date.now() - toolStart;

			this.logger.info({
				msg: LOG_MESSAGES.TOOL_RESULTS,
				toolName: toolUseBlock.name,
				duration: `${toolDuration}ms`,
				results: toolResults,
			});

			const continuationStart = Date.now();
			const continuationResponse = await this.client.messages.create({
				model: AnthropicOrchestrator.MODEL_NAME,
				max_tokens: 1024,
				system: this.getSystemPrompt(),
				messages: [
					...parsedMessages,
					{ role: "assistant", content: initialResponse.content },
					{
						role: "user",
						content: [
							{
								type: "tool_result",
								tool_use_id: toolUseBlock.id,
								content: toolResults,
							},
						],
					},
				],
			});
			const continuationDuration = Date.now() - continuationStart;

			this.logger.info({
				msg: LOG_MESSAGES.LLM_CONTINUATION,
				model: AnthropicOrchestrator.MODEL_NAME,
				duration: `${continuationDuration}ms`,
				content: continuationResponse.content,
				usage: continuationResponse.usage,
			});

			fullResponse = "";
			for (const block of continuationResponse.content) {
				if (block.type === "text") {
					fullResponse += block.text;
				}
			}
		}

		const newMessage: ChatMessage = {
			message_id: generateRandomId("msg"),
			timestamp: new Date().toISOString(),
			role: "assistant",
			content: [
				{
					content_type: "text",
					text: fullResponse,
				},
			],
			metadata: {
				model_name: AnthropicOrchestrator.MODEL_NAME,
				finish_reason: initialResponse.stop_reason ?? undefined,
			},
		};
		return newMessage;
	}
}
</file>

<file path="orchestrator/gemini.ts">
import { generateRandomId } from "@anterior/lib-platform/ids";
import type { Logger } from "@anterior/lib-platform/log";
import type { SchemaLike } from "@anterior/lib-platform/schema";
import { z } from "@anterior/lib-platform/zod";
import type { GoogleGenAI, } from "@google/genai";
import type { ChatMessage, ContentBlock } from "../models/message.ts";
import type { Platform } from "../platform.ts";
import { SYSTEM_PROMPT, type Orchestrator } from "./orchestrator.ts";

export type GeminiClient = GoogleGenAI;

export type GeminiMessage = {
	role: "user" | "assistant";
	parts: { text: string }[];
};



export type GeminiMessageParam = {
	role: "user" | "assistant";
	parts: { text: string }[];
};
export const geminiMessageParamSchema = z.object({
	role: z.enum(["user", "assistant"]),
	parts: z.array(z.object({ text: z.string() })),
}) satisfies SchemaLike<GeminiMessageParam>;



export class GeminiOrchestrator implements Orchestrator {
	static readonly MODEL_NAME = "gemini-2.5-pro-preview-05-06";
	private client: GoogleGenAI;
	private logger: Logger;
	private platform: Platform;
	constructor(platform: Platform, logger: Logger, client: GoogleGenAI) {
		this.client = client;
		this.logger = logger;
		this.platform = platform;
	}
	private const geminiBlockToText = (block: ContentBlock): string => {
		switch (block.content_type) {
			case "text": return block.text;
			case "markdown": return block.markdown;
			case "image": return block.image_url;
			case "tool_use": return block.tool_name;
			default: return JSON.stringify(block);
		}
	};

	parseMessages(messages: ChatMessage[]): Partial<ChatMessage> & { parts: { text: string }[] }[] {
		return messages.map((m) => ({
			role: m.role,
			parts: [{ text: m.content.map(geminiBlockToText).join("\n\n") }],
		}));
	}
	getModelName(): string {
		return GeminiOrchestrator.MODEL_NAME;
	}
	getSystemPrompt(): string {
		return SYSTEM_PROMPT;
	}
	getClient(): GoogleGenAI {
		return this.client;
	}

	async processChat(messages: ChatMessage[]): Promise<ChatMessage> {
		const client = this.getClient();

		const messageParams = {
			model: this.getModelName(),
			contents: this.parseMessages(messages),
			config: {
				systemInstruction: this.getSystemPrompt(),
			},
		};
		this.logger.info(messageParams, "Gemini MessageParams");
		const result = await client.models.generateContent(messageParams);
		this.logger.info(result, "Gemini generateContent Result");
		const newMessage: ChatMessage = {
			message_id: generateRandomId("msg"),
			timestamp: new Date().toISOString(),
			role: "assistant",
			content: [
				{
					content_type: "text",
					text: result.text ?? "",
				},
			],
			metadata: {
				model_name: this.getModelName(),
			},
		};

		return newMessage;
	}
}
</file>

<file path="orchestrator/orchestrator.ts">
import type Anthropic from "@anthropic-ai/sdk";
import type { GoogleGenAI } from "@google/genai";
import type { ChatAppContext } from "../app.ts";
import type { ChatMessage } from "../models/message.ts";

export const LOG_MESSAGES = {
	INITIALIZING: "\ud83d\ude80 Initializing",
	LLM_REQUEST: "\u2192 LLM Request",
	LLM_RESPONSE: "\u2190 LLM Response",
	TOOL_USE_DETECTED: "\ud83d\udd27 Tool Use Detected",
	EXECUTING_TOOL: "\ud83d\udd28 Executing Tool",
	TOOL_RESULTS: "\u2713 Tool Results",
	LLM_CONTINUATION: "\u2190 LLM Continuation Response",
	ERROR_EXECUTING_TOOL: "\u274c Error executing tool",
	UNKNOWN_TOOL: "\u274c Unknown tool requested",
};
export const SYSTEM_PROMPT = "You are a helpful utilization management nurse.";

export type AiProvider = "anthropic" | "gemini"

export type AiApater = Anthropic | GoogleGenAI;



export interface Orchestrator {

	getModelName(): AiProvider;
	getClient(): Anthropic | GoogleGenAI;
	parseMessages<T>(messages: ChatMessage[]): T[];
	processChat(messages: ChatMessage[]): Promise<ChatMessage>;

}

export type OrchestratorFactory = (provider: Provider) => Orchestrator;

export const createOrchestrator = (ctx: ChatAppContext): OrchestratorFactory => {
	const { logger, platform, clients } = ctx;

	return new Orchestrator(ctx);

	// return (provider: Provider) => {
	// 	switch (provider) {
	// 		case "anthropic":
	// 			return new AnthropicOrchestrator(platform, logger, clients[provider] as Anthropic);
	// 		case "gemini":
	// 		default:
	// 			return new GeminiOrchestrator(platform, logger, clients[provider] as GoogleGenAI);
	// 	}
	// };
};
</file>

<file path="app.ts">
import {
	App,
	type AppOptions,
	type EndpointSignature,
	type RequestContext,
} from "@anterior/lib-platform/app";
import { generateRandomId } from "@anterior/lib-platform/ids";
import { type Logger } from "@anterior/lib-platform/log";
import { pdfSectionV0120250514 } from "../@anterior/models/shared/pdf_section_v01_20250514.ts";
import { textSectionV0120250514 } from "../@anterior/models/shared/text_section_v01_20250514.ts";
import { parseAuthInfo } from "../auth/jwt.ts";
import {
	extractsSchema,
	type Block,
	type BoundingBox,
	type ExtractBlock,
} from "./models/extracts.ts";
import {
	chatRequestBodySchema,
	type ChatMessage,
	type ChatRequestBody,
	type Citation,
} from "./models/message.ts";
import type { Client, Provider } from "./orchestrator/orchestrator.ts";
import { createOrchestrator as getOrchestratorFactory } from "./orchestrator/orchestrator.ts";
import { calculateContentOffsets } from "./parser.ts";
import type { Platform } from "./platform.ts";

type PdfExtractBlocksContainer = Record<string, ExtractBlock[]>;

export const boundingBoxFromVertices = (block: Block): BoundingBox => {
	const vertices = block.layout?.vertices ?? [];
	const minX = Math.min(...vertices.map((v) => Number(v[0])));
	const maxX = Math.max(...vertices.map((v) => Number(v[0])));
	const minY = Math.min(...vertices.map((v) => Number(v[1])));
	const maxY = Math.max(...vertices.map((v) => Number(v[1])));

	const left = minX;
	const right = 1 - maxX;
	const top = minY;
	const bottom = 1 - maxY;

	return {
		top,
		bottom,
		left,
		right,
	};
};

interface BuildS3PdfPathArgs {
	enterpriseUid: string;
	stemId: string;
	pdfId: string;
	filename: string;
}

function buildS3PdfPath({ enterpriseUid, stemId, pdfId, filename }: BuildS3PdfPathArgs): string {
	const basePath = `stems/${enterpriseUid}/${stemId}/${pdfId}`;
	return `${basePath}/${filename}`;
}

export function createLlmMessages(userMessage: string, inputExtractsXml: string): ChatMessage[] {
	const systemMessageText = `
		#INPUT:

		<input>
			<task>{TASK}</task>
			<pdfs>
				<pdf id="{PDF_ID}">
					<extract id="{EXTRACT_ID}">{TEXT}</extract>
				</pdf>
			</pdfs>
		</input>

		---

		# INSTRUCTIONS:

		You are an expert research assistant tasked with answering questions based on provided PDF document extracts. Your goal is to find relevant information within these documents and provide a well-cited answer to the given question.

		To complete the task in the input, follow these steps:
		- Carefully review the PDF document extracts and identify the extracts that are most relevant to answering the question. These extracts should be relatively short and provide valid backing for your answer.
		- If there are no relevant extracts, you do not need to include any extracts in your answer.

		Remember to use the provided PDF document extracts as your sole source of information. Do not include any external knowledge or assumptions in your answer. If the question cannot be fully answered using the available information, state this clearly in your response.

		---

		# RESPONSE:

		<output>
			<extract ids="{PDF_ID}#{EXTRACT_ID}">
			{TEXT}
			</extract> {TEXT}

			<extract ids="{PDF_ID}#{EXTRACT_ID}">
				{TEXT}
			</extract>
		</output>

		---

		# EXAMPLES:

		## Example 1:

		- Input:

		<input>
			<task>What is the main idea of the document?</task>
			<pdfs>
				<pdf id="pdf_1">
					<extract id="ext_1">The main idea of the document is to provide a comprehensive overview of the topic.</extract>
				</pdf>
			</pdfs>
		</input>

		- Output:

		<output>
			<extract ids="pdf_1#ext_1">The main idea of the document is to provide a comprehensive overview of the topic.</extract>
		</output>

		## Example 2:

		- Input:

		<input>
			<task>What is the main idea of the document?</task>
			<pdfs>
				<pdf id="pdf_1">
					<extract id="ext_1">The main idea of the document is to provide a comprehensive overview of the topic.</extract>
					<extract id="ext_2">The main idea of the document is to provide a comprehensive overview of the topic.</extract>
				</pdf>
			</pdfs>
		</input>

		- Output:

		<output>
			Let me summarize the document for you:
			<extract ids="pdf_1#ext_1">The main idea of the document is to provide a comprehensive overview of the topic.</extract>
			<extract ids="pdf_1#ext_2">The main idea of the document is to provide a comprehensive overview of the topic.</extract>
		</output>

		`;

	const systemMessage: ChatMessage = {
		message_id: generateRandomId("msg"),
		timestamp: new Date().toISOString(),
		role: "user",
		content: [
			{
				content_type: "markdown",
				markdown: systemMessageText,
			},
		],
	};

	const pdfMessage: ChatMessage = {
		message_id: generateRandomId("msg"),
		timestamp: new Date().toISOString(),
		role: "user",
		content: [
			{
				content_type: "markdown",
				markdown: `<input><task>${userMessage}</task>${inputExtractsXml}</input>`,
			},
		],
	};

	return [systemMessage, pdfMessage];
}

export interface ChatAppContext {
	logger: Logger;
	platform: Platform;
	clients: Record<Provider, Client>;
}
export interface ChatAppService {
	POST: {
		"/": EndpointSignature<ChatRequestBody, Response>;
	};
}

export type ChatApp = App<ChatAppService, ChatAppContext>;

export function createChatApp(baseCtx: ChatAppContext, options: AppOptions): ChatApp {
	baseCtx.logger.info({
		msg: "Creating Chat App",
		contextKeys: Object.keys(baseCtx),
	});
	const orchestratorFactory = getOrchestratorFactory(baseCtx);
	const app: ChatApp = new App(baseCtx, options);

	app.endpoint({
		method: "POST",
		body: chatRequestBodySchema,
		route: "/",
		async handler(ctx) {
			const orchestrator = orchestratorFactory(ctx.body.provider ?? "gemini");
			const userMessage: ChatMessage = {
				message_id: generateRandomId("msg"),
				timestamp: new Date().toISOString(),
				...ctx.body.new_message,
			};
			ctx.logger.info(userMessage, "Received user message in POST /chat");

			// NB: We are re-fetching the extracts for each chat message from S3
			// This can slow the request a bit, profile before you optimize
			const extractsByPdfId = await getExtractsByPdfId(ctx);
			const extractsXml = buildExtractsXml(extractsByPdfId);

			const llmMessages = createLlmMessages(
				getAllTextFromChatMessage(userMessage),
				extractsXml
			);
			const orchestratorResponseMessage: ChatMessage =
				await orchestrator.processChat(llmMessages);
			const orchestratorResponseText = getAllTextFromChatMessage(orchestratorResponseMessage);
			const { textCitations, strippedText } =
				calculateContentOffsets(orchestratorResponseText);
			const citations: Citation[] = [];
			for (const textCitation of textCitations) {
				const extractBlock = extractsByPdfId[textCitation.pdfId]?.find(
					(block) => `${block.extractId}.${block.blockId}` === textCitation.extractId
				);
				if (!extractBlock) {
					ctx.logger.warn(
						{
							msg: "Citation extract not found, skipping",
							citation: textCitation,
						},
						"citationSkip"
					);
					continue;
				}
				citations.push({
					from: {
						artifact_id: orchestratorResponseMessage.message_id,
						section_type: textSectionV0120250514.shape.section_type.value,
						section_payload: textSectionV0120250514.parse({
							section_type: textSectionV0120250514.shape.section_type.value,
							start: textCitation.start,
							end: textCitation.end,
						}),
					},
					to: {
						artifact_id: textCitation.pdfId,
						section_type: pdfSectionV0120250514.shape.section_type.value,
						section_payload: pdfSectionV0120250514.parse({
							section_type: pdfSectionV0120250514.shape.section_type.value,
							page: extractBlock.pageNumber,
							bounding_box: extractBlock.boundingBox,
						}),
					},
				});
			}
			orchestratorResponseMessage.content = [
				{
					content_type: "markdown",
					markdown: strippedText,
					citations,
				},
			];

			// Need to add the user message to the response
			const responseMessages = [...ctx.body.messages]; // shallow copy
			responseMessages.push(userMessage);
			responseMessages.push(orchestratorResponseMessage);
			ctx.logger.debug(responseMessages, "responseMessages");
			return new Response(JSON.stringify(responseMessages), {
				headers: {
					"Content-Type": "application/json",
					"Cache-Control": "no-cache",
				},
			});
		},
	});

	return app;
}

/**
 * This is a helper function that fetches the extracts for a list of pdfs from S3.
 * This can later be done via a query to the citations store.
 *
 * @returns Map of pdfId to ExtractBlocks[]
 */
async function getExtractsByPdfId(
	// eslint-disable-next-line @typescript-eslint/no-empty-object-type
	ctx: RequestContext<ChatAppContext, "/", {}, unknown, unknown, ChatRequestBody>
): Promise<PdfExtractBlocksContainer> {
	const { enterpriseUid } = parseAuthInfo(ctx);
	const { stem_id, pdf_ids } = ctx.body;

	const pdfIdToExtracts = await Promise.all(
		pdf_ids.map(async (pdfId: string) => {
			const path = buildS3PdfPath({
				enterpriseUid,
				stemId: stem_id,
				pdfId,
				filename: "extracts.json",
			});
			const blob = await ctx.platform.blobs.fetchBlob(path);
			const text = await blob.text();
			const extracts = extractsSchema.parse(JSON.parse(text));
			return {
				extracts,
				pdfId,
			};
		})
	);

	return pdfIdToExtracts.reduce<PdfExtractBlocksContainer>(
		(extractBlockAcc, { pdfId, extracts }) => {
			const allExtractBlocksForThisPdf: ExtractBlock[] = extracts.extracts.flatMap(
				(singleExtract) =>
					singleExtract.blocks.map((block) => {
						return {
							extractId: singleExtract.id,
							blockId: block.id,
							pageNumber: block.page,
							text: block.content,
							boundingBox: boundingBoxFromVertices(block),
						};
					})
			);
			extractBlockAcc[pdfId] = allExtractBlocksForThisPdf;
			return extractBlockAcc;
		},
		{} as PdfExtractBlocksContainer
	);
}

// Build XML string for all pdf extracts
function buildExtractsXml(pdfExtractBlocksContainer: PdfExtractBlocksContainer): string {
	const pdfsXml = Object.entries(pdfExtractBlocksContainer)
		.map(([pdfId, extractBlocks]) => {
			const extractsXml = extractBlocks
				.map(({ extractId, blockId, text }) => {
					return `<extract id="${pdfId}#${extractId}.${blockId}">${text}</extract>`;
				})
				.join("\n");
			return `<pdf id="${pdfId}">${extractsXml}</pdf>`;
		})
		.join("\n");
	return `<pdfs>\n${pdfsXml}\n</pdfs>`;
}

function getAllTextFromChatMessage(message: ChatMessage): string {
	return message.content
		.map((content) => {
			switch (content.content_type) {
				case "text":
					return content.text;
				case "markdown":
					return content.markdown;
				default:
					return "";
			}
		})
		.join("\n");
}
</file>

<file path="infra.ts">
import infra_ from "@anterior/lib-infra";
import config from "@anterior/lib-infra/config";
import { S3Bucket } from "@anterior/lib-infra/s3";
import { BlobStore } from "@anterior/lib-platform/blob";
import { logger } from "@anterior/lib-platform/log";
import { Platform } from "./platform.ts";

const BUCKET_NAME = config.ANT_S3_BUCKET;
const chatStorageS3 = new S3Bucket(BUCKET_NAME);
export const chatStorageBlobs = new BlobStore(logger, chatStorageS3);

// todo:
// set filepaths for relevant stem/chat storage

/**
 * Platform configuration for the chat application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for chat data and file uploads
 */
export const infra = {
	logger,
	blobs: infra_.s3Bucket,
};

export const platform = Platform.fromInfra(infra);
</file>

<file path="main.ts">
import secrets from "@anterior/lib-infra/secrets";
import { logger } from "@anterior/lib-platform/log";
import Anthropic from "@anthropic-ai/sdk";
import { GoogleGenAI } from "@google/genai";
import config from "../config.ts";
import { createChatApp } from "./app.ts";
import { platform } from "./infra.ts";

export default createChatApp(
	{
		logger,
		platform,
		clients: {
			anthropic: new Anthropic({
				apiKey: config["ANTHROPIC_API_KEY"],
			}),
			gemini: new GoogleGenAI({
				apiKey: config["GEMINI_API_KEY"],
			}),
		},
	},
	{
		name: "chat",
		port: parseInt(config.ANT_LISTEN_PORT),
		allowedOrigins: config.ANT_ALLOWED_ORIGINS.split(","),
		allowedHeaders: ["X-API-Key", "X-Anterior-Enterprise-Id"],
		useCSRF: true,
		noLogging: false,
		authConfig: {
			jwtSecret: secrets.ANT_JWT_SECRET.getValue(),
			tokenRefreshEndpoint: config.ANT_TOKEN_REFRESH_ENDPOINT,
			apiKeyHeader: "x-api-key",
			redirectUrl: "/auth/login.html",
			apiBaseUrl__smellsBad: config.ANT_API_BASE_URL,
		},
	}
);
</file>

<file path="parser.test.ts">
import { expect, test } from "vitest";
import { calculateContentOffsets } from "./parser.ts";

const input1 = `Based on the provided clinical documentation, I'll summarize the key clinical information about patient Jane Jungle: <output> <extract ids="pdf_93741bc012_128e8c6f93#E0.2">Name Jane Jungle</extract> <extract ids="pdf_93741bc012_128e8c6f93#E0.3">DOB 07/14/1976</extract> <extract ids="pdf_93741bc012_128e8c6f93#E0.4">Appt Date/Time 9/22/2024, 09:00 am</extract> Jane Jungle is a 48-year-old female presenting with two different clinical narratives: In the first documentation: <extract ids="pdf_93741bc012_128e8c6f93#E0.10">Chronic pelvic pain, heavy menstrual bleeding, and worsening symptoms of endometriosis.</extract> <extract ids="pdf_93741bc012_128e8c6f93#E1.16">Jane Jungle is a 48-year-old female with a longstanding history of endometriosis. She reports ongoing pelvic pain, dysmenorrhea, dyspareunia, menorrhagia and bloating. Since 2002, Jane has experienced periods lasting 13 days with the first 3 days requiring her to bleed through a super heavy tampon and pad every 1.5 to 2 hours every other month. Despite previous treatments, including hormonal therapy for over 2 years and pain management for 3 months, and a D&C, her symptoms have progressively worsened over the past 4 months. Jane expresses significant distress and reports that the pain is affecting her daily activities and quality of life. Had negative pregnancy test today. Most recent PAP WNL. A pelvic ultrasound was performed, showing evidence of diffuse adenomyosis with multiple adhesions involving the uterus and surrounding pelvic structures. There is no evidence of malignancy.</extract> In the second documentation: <extract ids="pdf_4ec5709a84_e5822a91dd#E0.9">Surgical consult for hysterectomy w/ BSO in the setting of BRCA gene mutation.</extract> <extract ids="pdf_4ec5709a84_e5822a91dd#E0.12">Jane Jungle is a 48-year-old female with a confirmed diagnosis of BRCA gene mutation. Pt has been on tamoxifen for the last 6 months. Plan for estrogen HRT.</extract> Medical history includes: <extract ids="pdf_93741bc012_128e8c6f93#E2.18">• Endometriosis</extract> <extract ids="pdf_93741bc012_128e8c6f93#E2.19"> - Polycystic ovarian syndrome</extract> Plan of care: <extract ids="pdf_93741bc012_128e8c6f93#E2.30"> 1. Total hysterectomy endometriosis</extract> <extract ids="pdf_93741bc012_128e8c6f93#E2.31"> • Patient to undergo total hysterectomy to address symptoms refractory to medical management.</extract> Note: There appear to be some discrepancies between the two clinical documents regarding the primary reason for hysterectomy (endometriosis vs. BRCA mutation). </output>`;

const output1 = [
	{
		end: 136,
		extractId: "E0.2",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 120,
	},
	{
		end: 153,
		extractId: "E0.3",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 139,
	},
	{
		end: 190,
		extractId: "E0.4",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 156,
	},
	{
		end: 395,
		extractId: "E0.10",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 308,
	},
	{
		end: 1291,
		extractId: "E1.16",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 398,
	},
	{
		end: 1401,
		extractId: "E0.9",
		pdfId: "pdf_4ec5709a84_e5822a91dd",
		start: 1323,
	},
	{
		end: 1560,
		extractId: "E0.12",
		pdfId: "pdf_4ec5709a84_e5822a91dd",
		start: 1404,
	},
	{
		end: 1604,
		extractId: "E2.18",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 1589,
	},
	{
		end: 1637,
		extractId: "E2.19",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 1607,
	},
	{
		end: 1690,
		extractId: "E2.30",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 1654,
	},
	{
		end: 1787,
		extractId: "E2.31",
		pdfId: "pdf_93741bc012_128e8c6f93",
		start: 1693,
	},
];

test("calculateContentOffsets", () => {
	const offsets = calculateContentOffsets(input1);
	expect(offsets.textCitations).toEqual(output1);
});
</file>

<file path="parser.ts">
export function calculateContentOffsets(text: string): {
	textCitations: Array<{
		start: number;
		end: number;
		pdfId: string;
		extractId: string;
	}>;
	strippedText: string;
} {
	// Use regex to match extract tags
	const regex = /<extract(?:\s+ids="([^"]*)")?>([\s\S]*?)<\/extract>/g;

	// list of all regex matches
	const matches: Array<{
		pdfId: string;
		extractId: string;
		content: string;
	}> = [];

	const allGroups = text.matchAll(regex);
	for (const match of allGroups) {
		const ids = match[1];
		const content = match[2];
		if (ids === undefined) {
			throw new Error("No ids found for extract tag");
		}
		if (content === undefined) {
			throw new Error("No content found for extract tag");
		}
		const idArray = ids.split(",");
		idArray.forEach((id) => {
			const pdfId = id.split("#")[0];
			if (pdfId === undefined) {
				throw new Error("No pdf id found for extract tag");
			}
			const extractId = id.split("#")[1];
			if (extractId === undefined) {
				throw new Error("No extract id found for extract tag");
			}
			matches.push({
				pdfId,
				extractId,
				content,
			});
		});
	}

	// strip the text of all xml tags
	const strippedText = text.replace(/<[^>]*>/g, "\n");

	const textCitations: Array<{
		pdfId: string;
		extractId: string;
		start: number;
		end: number;
	}> = [];

	for (const match of matches) {
		let start: number;
		if (textCitations.length > 0) {
			const lastCitation = textCitations[textCitations.length - 1];
			if (lastCitation === undefined) {
				throw new Error("No last citation found");
			}
			start = strippedText.indexOf(match.content, lastCitation.end);
		} else {
			start = strippedText.indexOf(match.content);
		}
		const end = start + match.content.length;

		textCitations.push({
			pdfId: match.pdfId,
			extractId: match.extractId,
			start,
			end,
		});
	}

	return {
		textCitations,
		strippedText,
	};
}
</file>

<file path="platform.ts">
import { BlobStore, type BlobStoreBackend } from "@anterior/lib-platform/blob";
import { InMemoryBlobStoreBackend } from "@anterior/lib-platform/in-memory";
import { Logger, logger } from "@anterior/lib-platform/log";

// NB: for when we want to store chats similar to how we store
// pdfs and notes within noggin/src/notes (formerly llms)
// @ajit we'll likely want to store everything flopilot related
// in the same place within the same stem
//
// every new "chat" could comprise a new stem...we may have
// different types of stems over time, starting with "chat"
// the various elements of the chat: input pdfs, chat history,
// artifacts, the workflows that create them, could be stored
// as part of that stem
//
// note that we do not have any events for any of the noggin
// implementations yet...that's to come

export interface Infra {
	logger: Logger;
	blobs: BlobStoreBackend;
}

export function getInMemoryInfra(): Infra {
	return {
		logger,
		blobs: new InMemoryBlobStoreBackend(),
	};
}

export interface Stores {
	readonly blobs: BlobStore;
}

export class Platform {
	public static inMemory(infra: Partial<Infra> = {}): Platform {
		return Platform.fromInfra({ ...getInMemoryInfra(), ...infra });
	}

	public static fromInfra(infra: Infra): Platform {
		const stores: Stores = {
			blobs: new BlobStore(infra.logger, infra.blobs),
		};
		return new Platform(stores);
	}

	constructor(public readonly stores: Stores) {}

	get blobs(): BlobStore {
		return this.stores.blobs;
	}
}
</file>

<file path="README.md">
## Test

> ⚠️ This only works if you turn off the JWT Config in `main.ts`. We need to get API Key authentication working otherwise.

```sh
curl -X POST http://localhost:59000/chat -H "Content-Type: application/json" -d '{"messages":[{"role":"user","content":"A 65-year-old patient with COPD presents with increased shortness of breath and a productive cough for the past 5 days. The patient has been using their rescue inhaler more frequently. What clinical indicators would support the medical necessity for a chest X-ray and what specific documentation should be reviewed?"}]}' -N
```
</file>

</files>

# Task ID: 6
# Title: Implement BRRR Worker Task for Template Population
# Status: pending
# Dependencies: 3
# Priority: high
# Description: Create the BRRR worker task to consume populate_template events and execute template population jobs, as specified in FLO-139.
# Details:
1. Create `populate_template.py` in `brrr/tasks/`
2. Implement task to consume events from the message broker:

```python
from brrr.core import Task, event
from brrr.db import Database
from typing import Dict, Any

class PopulateTemplateTask(Task):
    @event('template.populate')
    async def handle_populate_template(self, event_data: Dict[str, Any]):
        run_id = event_data['runId']
        template_id = event_data['templateId']
        stem_id = event_data['stemId']
        params = event_data.get('params', {})
        
        # Update stem status to loading
        await self.db.execute(
            "UPDATE stems SET status = 'loading' WHERE id = %s",
            [stem_id]
        )
        
        # Emit started event
        await self.emit_event('TEMPLATE_POPULATING_STARTED', {
            'stem_id': stem_id,
            'run_id': run_id
        })
        
        # Send progress updates (in a real implementation, this would be
        # interspersed throughout the actual processing)
        await self.report_progress(stem_id, 25, 'Processing template')
        await self.report_progress(stem_id, 50, 'Analyzing clinical data')
        await self.report_progress(stem_id, 75, 'Generating content')
        
        try:
            # TODO: Actual template population logic
            # For now, just a placeholder
            note_id = 'generated-note-id'
            
            # Update stem status to complete
            await self.db.execute(
                "UPDATE stems SET status = 'complete' WHERE id = %s",
                [stem_id]
            )
            
            # Emit completed event
            await self.emit_event('TEMPLATE_POPULATING_COMPLETED', {
                'stem_id': stem_id,
                'run_id': run_id,
                'note_id': note_id,
                'success': True
            })
            
            await self.report_progress(stem_id, 100, 'Complete')
            
        except Exception as e:
            # Update stem status to error
            await self.db.execute(
                "UPDATE stems SET status = 'error' WHERE id = %s",
                [stem_id]
            )
            
            # Emit error event
            await self.emit_event('TEMPLATE_POPULATING_COMPLETED', {
                'stem_id': stem_id,
                'run_id': run_id,
                'success': False,
                'error': str(e)
            })
    
    async def report_progress(self, stem_id: str, pct: int, message: str):
        # Emit progress event that will be picked up by WebSocket
        await self.emit_event('run.progress', {
            'stem_id': stem_id,
            'percentComplete': pct,
            'statusMessage': message
        })
```

3. Register the task in BRRR's task registry

# Test Strategy:
1. Unit test the task handler with mocked dependencies
2. Test event consumption and processing
3. Test progress reporting
4. Test error handling and recovery
5. Integration test with in-memory message broker and database
6. Verify correct event emissions for started, progress, and completed events

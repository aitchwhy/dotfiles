# Effect HttpApi SSOT: Ban manual API client classes/objects
# This catches patterns like: export const apiClient = { startConversation: async () => ... }
id: http-ssot-no-api-client-class
language: TypeScript
severity: error
message: "Manual API client classes/objects are banned. Use HttpApiClient.make(YourApi) to derive a type-safe client from your contract."
note: |
  Manual API client definitions bypass the HttpApi contract system.
  They lead to split-brain architecture where:
  - Types exist in one place
  - Implementation exists in another
  - They can drift silently

  WRONG (manual client object/class):
    export const apiClient = {
      startConversation: async (questionId: string) => {
        const response = await fetch('/api/conversation/start', {...})
        return response.json()
      }
    }

    // or
    export class ApiClient {
      async getUsers() {
        return fetch('/api/users').then(r => r.json())
      }
    }

  RIGHT (derived from contract):
    // 1. Contract (@yourpackage/contracts)
    export class ConversationApi extends HttpApi.make('conversation').add(...)

    // 2. Service Tag + Layer
    export class ApiClient extends Context.Tag('ApiClient')<
      ApiClient,
      Effect.Effect.Success<typeof HttpApiClient.make<typeof YourApi>>
    >() {}

    export const ApiClientLive = Layer.effect(
      ApiClient,
      HttpApiClient.make(YourApi, { baseUrl })
    )

rule:
  any:
    # Object with HTTP method calls as properties
    - pattern: |
        export const $NAME = {
          $$$METHODS
        }
      has:
        any:
          - pattern: fetch($$$)
          - pattern: await fetch($$$)
    # Class with methods that call fetch
    - pattern: |
        class $NAME {
          $$$BODY
        }
      has:
        any:
          - pattern: fetch($$$)
          - pattern: await fetch($$$)

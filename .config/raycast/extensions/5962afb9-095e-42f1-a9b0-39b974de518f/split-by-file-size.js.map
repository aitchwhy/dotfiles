{
  "version": 3,
  "sources": ["../src/split-by-file-size.ts", "swift:/Users/runner/work/extensions/extensions/extensions/pdf-tools/swift"],
  "sourcesContent": ["import { closeMainWindow, getPreferenceValues, getSelectedFinderItems, showToast, Toast } from \"@raycast/api\";\nimport path from \"path\";\nimport { isPDFDocumentLocked, splitByFileSize } from \"swift:../swift\";\n\ninterface Preferences {\n  suffix: string;\n}\n\nexport default async function Command(props: { arguments: { maxSizeMB: string } }) {\n  try {\n    const maxSizeMB = parseFloat(props.arguments.maxSizeMB);\n\n    if (isNaN(maxSizeMB) || maxSizeMB <= 0) {\n      throw new Error(\"A positive number is required\");\n    }\n\n    const selectedItems = await getSelectedFinderItems();\n\n    if (selectedItems.length === 0) {\n      throw new Error(\"You must select at least one PDF file in Finder\");\n    }\n\n    for (const item of selectedItems) {\n      if (path.extname(item.path).toLowerCase() !== \".pdf\") {\n        throw new Error(\"Only PDF files should be selected in Finder\");\n      }\n\n      if (await isPDFDocumentLocked(item.path)) {\n        throw new Error(`\"${path.basename(item.path)}\" is password-protected`);\n      }\n    }\n\n    await closeMainWindow();\n\n    const preferences = getPreferenceValues<Preferences>();\n    const suffix = preferences.suffix || undefined;\n\n    for (const item of selectedItems) {\n      await showToast({\n        style: Toast.Style.Animated,\n        title: `Splitting \"${path.basename(item.path)}\"`,\n      });\n\n      await splitByFileSize(item.path, maxSizeMB, suffix);\n    }\n\n    await showToast({\n      style: Toast.Style.Success,\n      title: `PDF file${selectedItems.length > 1 ? \"s\" : \"\"} split successfully`,\n    });\n  } catch (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n", "\nimport { environment } from \"@raycast/api\";\nimport { join } from \"path\";\nimport { chmod } from \"fs/promises\";\nimport { spawn } from \"child_process\";\n\nasync function runSwiftFunction(command, ...args) {\n  const swiftPath = join(environment.assetsPath, \"compiled_raycast_swift/swift\");\n  await chmod(swiftPath, \"755\");\n\n  return new Promise((resolve, reject) => {\n    const commandArgs = [command];\n    for (const arg of args) {\n      try {\n        commandArgs.push(JSON.stringify(arg, (k, v) => v === undefined ? null : v));\n      } catch (err) {\n        reject(new SwiftError(\"Failed to serialize input to JSON: \" + err.message));\n        return;\n      }\n    }\n    const child = spawn(swiftPath, commandArgs);\n    const stdout = [];\n    const stderr = [];\n\n    child.stdout?.on(\"data\", (data) => {\n      stdout.push(data.toString());\n    });\n    child.stderr?.on(\"data\", (data) => {\n      stderr.push(data.toString());\n    });\n\n    child.on(\"exit\", (code) => {\n      if (code === 0) {\n        try {\n          const result = stdout.join(\"\").trim();\n          if (result.length != 0) {\n            resolve(JSON.parse(result));\n          } else {\n            resolve(null);\n          }\n        } catch (err) {\n          const error = new SwiftError(\"Failed to deserialize result from JSON: \" + err.message);\n          error.stdout = stdout.join(\"\").trim();\n          error.stderr = stderr.join(\"\").trim();\n          reject(error);\n        }\n      } else {\n        const error = new SwiftError(stderr.join(\"\").trim() || stdout.join(\"\").trim() || \"Could not get any data\");\n        error.stdout = stdout.join(\"\").trim();\n        error.stderr = stderr.join(\"\").trim();\n        reject(error);\n      }\n    });\n\n    child.on(\"error\", (error) => {\n      reject(error);\n    });\n  });\n}\n\nexport async function splitByFileSize(filePath, maxSizeMB, suffix) {\n  return await runSwiftFunction(\"splitByFileSize\", filePath, maxSizeMB, suffix)\n}\n\nexport async function isPDFDocumentLocked(filePath) {\n  return await runSwiftFunction(\"isPDFDocumentLocked\", filePath)\n}\n\nexport async function unlock(filePath, password) {\n  return await runSwiftFunction(\"unlock\", filePath, password)\n}\n\nexport async function merge(filePaths, outputFilename) {\n  return await runSwiftFunction(\"merge\", filePaths, outputFilename)\n}\n\nexport async function protect(filePath, password) {\n  return await runSwiftFunction(\"protect\", filePath, password)\n}\n\nexport async function watermark(filePath, text, transparency, rotation, fontSize) {\n  return await runSwiftFunction(\"watermark\", filePath, text, transparency, rotation, fontSize)\n}\n\nexport async function splitByPageCount(filePath, pageCount, suffix) {\n  return await runSwiftFunction(\"splitByPageCount\", filePath, pageCount, suffix)\n}\n\nexport class SwiftError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"SwiftError\";\n  }\n}\n"],
  "mappings": "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",
  "names": ["split_by_file_size_exports", "__export", "Command", "__toCommonJS", "import_api", "import_path", "import_api", "import_path", "import_promises", "import_child_process", "runSwiftFunction", "command", "args", "swiftPath", "resolve", "reject", "commandArgs", "arg", "k", "v", "err", "SwiftError", "child", "stdout", "stderr", "data", "code", "result", "error", "splitByFileSize", "filePath", "maxSizeMB", "suffix", "isPDFDocumentLocked", "SwiftError", "message", "Command", "props", "maxSizeMB", "selectedItems", "item", "path", "isPDFDocumentLocked", "suffix", "splitByFileSize", "error"]
}

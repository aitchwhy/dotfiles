{
  "version": 3,
  "sources": ["../src/travelTo.tsx", "../src/utils/input.ts", "../src/utils/url.ts"],
  "sourcesContent": ["import { Action, ActionPanel, Form, getPreferenceValues, Icon, popToRoot } from \"@raycast/api\";\nimport { useEffect, useState, useCallback } from \"react\";\nimport { fetchItemInput } from \"./utils/input\";\nimport { Preferences, TransportType, OriginOption } from \"./utils/types\";\nimport { makeDirectionsURL } from \"./utils/url\";\n\nexport default function Command() {\n  // Get user preferences\n  const preferences = getPreferenceValues<Preferences>();\n\n  // State variables\n  const [origin, setOrigin] = useState<OriginOption>(preferences.preferredOrigin); // Controls which origin option is selected\n  const [originAddress, setOriginAddress] = useState<string>(\"\"); // Stores the origin address\n  const [destination, setDestination] = useState<string>(\"\"); // Stores the destination address\n  const [mode, setMode] = useState<string>(preferences.preferredMode); // Stores the selected transport mode\n  const [isLoading, setIsLoading] = useState<boolean>(preferences.useSelected); // Controls loading state\n\n  // Handle changes to the origin dropdown\n  const handleOriginChange = useCallback(\n    (value: string) => {\n      const newOrigin = value as OriginOption;\n      setOrigin(newOrigin);\n      if (newOrigin === OriginOption.CurLoc) {\n        setOriginAddress(\"\");\n      } else if (newOrigin === OriginOption.Home) {\n        setOriginAddress(preferences.homeAddress);\n      } else {\n        setOriginAddress(\"\");\n      }\n    },\n    [preferences.homeAddress]\n  );\n\n  // Effect to auto-fill destination if useSelected preference is true\n  useEffect(() => {\n    async function autoFillDestination() {\n      if (preferences.useSelected) {\n        try {\n          const inputItem = await fetchItemInput();\n          setDestination(inputItem);\n        } catch (error) {\n          console.error(\"Error fetching input:\", error);\n        } finally {\n          setIsLoading(false);\n        }\n      } else {\n        setIsLoading(false);\n      }\n    }\n\n    autoFillDestination();\n  }, [preferences.useSelected]);\n\n  return (\n    <Form\n      isLoading={isLoading}\n      actions={\n        <ActionPanel>\n          {/* Action to open directions in browser */}\n          <Action.OpenInBrowser\n            url={makeDirectionsURL(originAddress, destination, mode)}\n            icon={Icon.Globe}\n            onOpen={() => popToRoot()}\n          />\n          {/* Action to copy directions URL to clipboard */}\n          <Action.CopyToClipboard\n            content={makeDirectionsURL(originAddress, destination, mode)}\n            icon={Icon.Clipboard}\n            onCopy={() => popToRoot()}\n          />\n        </ActionPanel>\n      }\n    >\n      {/* Destination input field */}\n      <Form.TextField\n        id=\"destination\"\n        title=\"Destination\"\n        placeholder=\"Name or Address\"\n        value={destination}\n        onChange={setDestination}\n      />\n      <Form.Separator />\n      {/* Origin selection dropdown */}\n      <Form.Dropdown id=\"origin\" title=\"Starting from\" value={origin} onChange={handleOriginChange}>\n        <Form.Dropdown.Item value={OriginOption.CurLoc} title=\"Current Location\" icon={Icon.Pin} />\n        <Form.Dropdown.Item value={OriginOption.Home} title=\"Home\" icon={Icon.House} />\n        <Form.Dropdown.Item value={OriginOption.Custom} title=\"Custom Address\" icon={Icon.Pencil} />\n      </Form.Dropdown>\n      {/* Custom origin address input (only shown when Custom is selected) */}\n      {origin === OriginOption.Custom && (\n        <Form.TextField\n          id=\"originAddress\"\n          title=\"Address\"\n          placeholder=\"Name or Address\"\n          value={originAddress}\n          onChange={setOriginAddress}\n        />\n      )}\n      {/* Transport mode selection dropdown */}\n      <Form.Dropdown id=\"TransportType\" title=\"Transport Preference\" value={mode} onChange={setMode}>\n        <Form.Dropdown.Item value={TransportType.Driving} title=\"Driving\" icon={Icon.Car} />\n        <Form.Dropdown.Item value={TransportType.Transit} title=\"Transit\" icon={Icon.Train} />\n        <Form.Dropdown.Item value={TransportType.Walking} title=\"Walking\" icon={Icon.Footprints} />\n        <Form.Dropdown.Item value={TransportType.Cycling} title=\"Cycling\" icon={Icon.Bike} />\n      </Form.Dropdown>\n    </Form>\n  );\n}\n", "import { Clipboard, getSelectedText } from \"@raycast/api\";\n\n/**\n * Checks if a string is empty or null/undefined.\n * @param str - The string to check.\n * @returns True if the string is empty, null, or undefined; false otherwise.\n */\nconst isEmpty = (str: string | null | undefined): boolean => {\n  return !str || str.trim().length === 0;\n};\n\n/**\n * Replaces all line breaks in a string with a single space.\n * @param str - The string to process.\n * @returns The processed string with line breaks replaced by spaces.\n */\nconst replaceLineBreaks = (str: string): string => {\n  return str.replace(/(\\r\\n|\\n|\\r)/gm, \" \").trim();\n};\n\n/**\n * Gets the text content from the clipboard and replaces line breaks with spaces.\n * @returns The processed clipboard text content or an empty string if unavailable.\n */\nconst getClipboardText = async (): Promise<string> => {\n  try {\n    const content = await Clipboard.readText();\n    return content ? replaceLineBreaks(content) : \"\";\n  } catch (error) {\n    console.error(\"Error reading clipboard:\", error);\n    return \"\";\n  }\n};\n\n/**\n * Gets selected text if available, otherwise falls back to clipboard text.\n * Replaces any line breaks with spaces in the result.\n * @returns Processed selected text, clipboard text, or an empty string.\n */\nexport const fetchItemInput = async (): Promise<string> => {\n  try {\n    const selectedText = await getSelectedText();\n    if (!isEmpty(selectedText)) {\n      return replaceLineBreaks(selectedText);\n    }\n  } catch (error) {\n    // Silently catch the error and proceed to clipboard\n  }\n\n  // If no selected text or error occurred, try clipboard\n  return getClipboardText();\n};\n\nexport { isEmpty };\n", "/**\n * Given an origin, a destination, and a travel mode, returns a direction url according to the following specs:\n * https://developers.google.com/maps/documentation/urls/get-started\n *\n * @param origin The origin address\n * @param destination The destination address\n * @param transporttype One of four possible transit types\n * @returns A properly URI encoded string according to Google Maps documentation\n */\nexport function makeDirectionsURL(origin: string, destination: string, transporttype: string): string {\n  const mapsBase = \"https://www.google.com/maps/dir/?api=1\";\n  return (\n    mapsBase +\n    \"&origin=\" +\n    encodeURI(origin) +\n    \"&destination=\" +\n    encodeURI(destination) +\n    \"&travelmode=\" +\n    encodeURI(transporttype)\n  );\n}\n\n/**\n * Given a query string, returns search url according to the following specs:\n * https://developers.google.com/maps/documentation/urls/get-started\n *\n * @param query The query address\n * @returns A properly URI encoded string according to Google Maps documentation\n */\nexport function makeSearchURL(query: string): string {\n  const mapsBase = \"https://www.google.com/maps/search/?api=1\";\n  return mapsBase + \"&query=\" + encodeURI(query);\n}\n"],
  "mappings": "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",
  "names": ["travelTo_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_api", "isEmpty", "str", "replaceLineBreaks", "getClipboardText", "content", "error", "fetchItemInput", "selectedText", "makeDirectionsURL", "origin", "destination", "transporttype", "import_jsx_runtime", "Command", "preferences", "origin", "setOrigin", "originAddress", "setOriginAddress", "destination", "setDestination", "mode", "setMode", "isLoading", "setIsLoading", "handleOriginChange", "value", "newOrigin", "autoFillDestination", "inputItem", "fetchItemInput", "error", "makeDirectionsURL"]
}

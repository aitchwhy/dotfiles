{
  "version": 3,
  "sources": ["../../src/tools/get-current-time.ts", "../../src/lib/utils.ts"],
  "sourcesContent": ["import { toHumanReadableTime, toISO8601WithTimezoneOffset } from \"../lib/utils\";\n\n/**\n * Get the current time\n *\n * @remarks\n * Use this tool only if you need to get the current time.\n * Returns the current time in ISO 8601 format with timezone offset (e.g., \"2024-06-15T14:30:00-07:00\"),\n * which is the recommended format for accurate timezone handling with LLMs.\n * The timezone offset (e.g., -07:00, +02:00) is explicitly included rather than using Z (UTC)\n * to ensure proper timezone interpretation.\n */\nconst tool = async () => {\n  const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n\n  const now = new Date();\n  const iso8601 = toISO8601WithTimezoneOffset(now);\n  const humanReadableTime = toHumanReadableTime(now);\n\n  return {\n    timezone,\n    iso8601,\n    humanReadableTime,\n  };\n};\n\nexport default tool;\n", "import { environment, getPreferenceValues } from \"@raycast/api\";\n\nconst SIGNATURE = \"Created with <a href='https://raycast.com'>Raycast</a>\";\n\nconst preferences: Preferences.CreateEvent = getPreferenceValues();\n\nexport function roundUpTime(date = new Date(), roundMins = 15) {\n  const ms = 1000 * 60 * roundMins;\n  return new Date(Math.ceil(date.getTime() / ms) * ms);\n}\n\nexport function addSignature(description: string | undefined) {\n  if (!preferences.addSignature) {\n    return description;\n  }\n\n  if (!description) {\n    return SIGNATURE;\n  }\n\n  return `${description}\\n<hr>${SIGNATURE}`;\n}\n\nfunction parseRRule(rrule: string): string {\n  // Remove RRULE: prefix if present\n  const rule = rrule.replace(\"RRULE:\", \"\");\n  const parts = rule.split(\";\");\n  const ruleObj: Record<string, string> = {};\n\n  parts.forEach((part) => {\n    const [key, value] = part.split(\"=\");\n    ruleObj[key] = value;\n  });\n\n  const freq = ruleObj.FREQ?.toLowerCase() || \"\";\n  const interval = ruleObj.INTERVAL ? parseInt(ruleObj.INTERVAL) : 1;\n  const count = ruleObj.COUNT ? parseInt(ruleObj.COUNT) : undefined;\n  const until = ruleObj.UNTIL\n    ? new Date(`${ruleObj.UNTIL.slice(0, 4)}-${ruleObj.UNTIL.slice(4, 6)}-${ruleObj.UNTIL.slice(6, 8)}`)\n    : undefined;\n\n  let humanReadable = \"\";\n\n  // Handle frequency and interval\n  if (interval === 1) {\n    humanReadable = `Every ${freq.slice(0, -2)}`;\n  } else {\n    humanReadable = `Every ${interval} ${freq.slice(0, -2)}s`;\n  }\n\n  // Handle end condition\n  if (count) {\n    humanReadable += `, ${count} times`;\n  } else if (until) {\n    humanReadable += ` until ${until.toLocaleDateString()}`;\n  }\n\n  // Handle specific days for weekly recurrence\n  if (freq === \"weekly\" && ruleObj.BYDAY) {\n    const days = ruleObj.BYDAY.split(\",\").map((day) => {\n      const dayMap: Record<string, string> = {\n        MO: \"Monday\",\n        TU: \"Tuesday\",\n        WE: \"Wednesday\",\n        TH: \"Thursday\",\n        FR: \"Friday\",\n        SA: \"Saturday\",\n        SU: \"Sunday\",\n      };\n      return dayMap[day];\n    });\n\n    if (days.length > 0) {\n      humanReadable += ` on ${days.join(\", \")}`;\n    }\n  }\n\n  return humanReadable;\n}\n\nexport function formatRecurrence(recurrence: string[]): string {\n  if (!recurrence?.length) return \"\";\n\n  const rules = recurrence\n    .map((rule) => {\n      if (rule.startsWith(\"RRULE:\")) {\n        return parseRRule(rule);\n      } else if (rule.startsWith(\"EXRULE:\")) {\n        return `Except ${parseRRule(rule.replace(\"EXRULE:\", \"\"))}`;\n      } else if (rule.startsWith(\"RDATE:\")) {\n        const dates = rule\n          .replace(\"RDATE:\", \"\")\n          .split(\",\")\n          .map((date) => new Date(date).toLocaleDateString());\n        return `Also occurs on ${dates.join(\", \")}`;\n      } else if (rule.startsWith(\"EXDATE:\")) {\n        const dates = rule\n          .replace(\"EXDATE:\", \"\")\n          .split(\",\")\n          .map((date) => new Date(date).toLocaleDateString());\n        return `Except on ${dates.join(\", \")}`;\n      }\n      return \"\";\n    })\n    .filter(Boolean);\n\n  return rules.join(\"\\n\");\n}\n\nexport function isInternal() {\n  return environment.supportPath.includes(\"com.raycast.macos.internal\");\n}\n\nexport function toISO8601WithTimezoneOffset(date = new Date()) {\n  const year = date.getFullYear();\n  const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n  const day = date.getDate().toString().padStart(2, \"0\");\n  const hours = date.getHours().toString().padStart(2, \"0\");\n  const minutes = date.getMinutes().toString().padStart(2, \"0\");\n  const seconds = date.getSeconds().toString().padStart(2, \"0\");\n\n  const offset = date.getTimezoneOffset();\n  const offsetHours = Math.abs(Math.floor(offset / 60))\n    .toString()\n    .padStart(2, \"0\");\n  const offsetMinutes = Math.abs(offset % 60)\n    .toString()\n    .padStart(2, \"0\");\n  const offsetSign = offset <= 0 ? \"+\" : \"-\";\n\n  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${offsetSign}${offsetHours}:${offsetMinutes}`;\n}\n\nexport function toHumanReadableTime(date = new Date()) {\n  return date.toLocaleString(undefined, {\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    timeZoneName: \"short\",\n  });\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GCAA,IAAAI,EAAiD,wBAIjD,IAAMC,KAAuC,uBAAoB,EA6G1D,SAASC,EAA4BC,EAAO,IAAI,KAAQ,CAC7D,IAAMC,EAAOD,EAAK,YAAY,EACxBE,GAASF,EAAK,SAAS,EAAI,GAAG,SAAS,EAAE,SAAS,EAAG,GAAG,EACxDG,EAAMH,EAAK,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAG,GAAG,EAC/CI,EAAQJ,EAAK,SAAS,EAAE,SAAS,EAAE,SAAS,EAAG,GAAG,EAClDK,EAAUL,EAAK,WAAW,EAAE,SAAS,EAAE,SAAS,EAAG,GAAG,EACtDM,EAAUN,EAAK,WAAW,EAAE,SAAS,EAAE,SAAS,EAAG,GAAG,EAEtDO,EAASP,EAAK,kBAAkB,EAChCQ,EAAc,KAAK,IAAI,KAAK,MAAMD,EAAS,EAAE,CAAC,EACjD,SAAS,EACT,SAAS,EAAG,GAAG,EACZE,EAAgB,KAAK,IAAIF,EAAS,EAAE,EACvC,SAAS,EACT,SAAS,EAAG,GAAG,EACZG,EAAaH,GAAU,EAAI,IAAM,IAEvC,MAAO,GAAGN,CAAI,IAAIC,CAAK,IAAIC,CAAG,IAAIC,CAAK,IAAIC,CAAO,IAAIC,CAAO,GAAGI,CAAU,GAAGF,CAAW,IAAIC,CAAa,EAC3G,CAEO,SAASE,EAAoBX,EAAO,IAAI,KAAQ,CACrD,OAAOA,EAAK,eAAe,OAAW,CACpC,KAAM,UACN,MAAO,OACP,IAAK,UACL,KAAM,UACN,OAAQ,UACR,OAAQ,UACR,aAAc,OAChB,CAAC,CACH,CDnIA,IAAMY,EAAO,SAAY,CACvB,IAAMC,EAAW,KAAK,eAAe,EAAE,gBAAgB,EAAE,SAEnDC,EAAM,IAAI,KACVC,EAAUC,EAA4BF,CAAG,EACzCG,EAAoBC,EAAoBJ,CAAG,EAEjD,MAAO,CACL,SAAAD,EACA,QAAAE,EACA,kBAAAE,CACF,CACF,EAEOE,EAAQP",
  "names": ["get_current_time_exports", "__export", "get_current_time_default", "__toCommonJS", "import_api", "preferences", "toISO8601WithTimezoneOffset", "date", "year", "month", "day", "hours", "minutes", "seconds", "offset", "offsetHours", "offsetMinutes", "offsetSign", "toHumanReadableTime", "tool", "timezone", "now", "iso8601", "toISO8601WithTimezoneOffset", "humanReadableTime", "toHumanReadableTime", "get_current_time_default"]
}

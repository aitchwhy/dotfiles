{
  "version": 3,
  "sources": ["../src/my-devices.tsx", "../src/shared.tsx", "../src/components/CopyActions.tsx"],
  "sourcesContent": ["import { List, Icon, Image } from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport { Device, getStatus, getErrorDetails, getDevices, sortDevices, ErrorDetails } from \"./shared\";\nimport CopyActions from \"./components/CopyActions\";\n\nexport default function MyDeviceList() {\n  const [devices, setDevices] = useState<Device[]>();\n  const [error, setError] = useState<ErrorDetails>();\n  useEffect(() => {\n    async function fetch() {\n      try {\n        const status = getStatus();\n        const me: string = status.Self.UserID.toString();\n        const _list = getDevices(status);\n        const _mylist = _list.filter((device) => device.userid === me);\n        sortDevices(_mylist);\n        setDevices(_mylist);\n      } catch (error) {\n        setError(getErrorDetails(error, \"Couldn\u2019t load device list.\"));\n      }\n    }\n    fetch();\n  }, []);\n\n  return (\n    <List isLoading={!devices && !error}>\n      {error ? (\n        <List.EmptyView icon={Icon.Warning} title={error.title} description={error.description} />\n      ) : (\n        devices?.map((device) => (\n          <List.Item\n            title={device.name}\n            subtitle={device.ipv4 + \"    \" + device.os}\n            key={device.key}\n            icon={\n              device.online\n                ? {\n                    source: {\n                      light: \"connected_light.png\",\n                      dark: \"connected_dark.png\",\n                    },\n                    mask: Image.Mask.Circle,\n                  }\n                : {\n                    source: {\n                      light: \"lastseen_light.png\",\n                      dark: \"lastseen_dark.png\",\n                    },\n                    mask: Image.Mask.Circle,\n                  }\n            }\n            accessories={\n              device.self\n                ? [\n                    { text: \"This device\", icon: Icon.Person },\n                    {\n                      text: device.online\n                        ? `        Connected`\n                        : \"Last seen \" +\n                          device.lastseen.toLocaleString(\"en-US\", {\n                            month: \"short\",\n                            day: \"numeric\",\n                            hour: \"numeric\",\n                            minute: \"numeric\",\n                          }),\n                    },\n                  ]\n                : [\n                    {\n                      text: device.online\n                        ? `        Connected`\n                        : \"Last seen \" +\n                          device.lastseen.toLocaleString(\"en-US\", {\n                            month: \"short\",\n                            day: \"numeric\",\n                            hour: \"numeric\",\n                            minute: \"numeric\",\n                          }),\n                    },\n                  ]\n            }\n            actions={<CopyActions device={device} />}\n          />\n        ))\n      )}\n    </List>\n  );\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { execSync } from \"node:child_process\";\n\nexport const MULLVAD_DEVICE_TAG = \"tag:mullvad-exit-node\";\n\nexport interface Device {\n  self: boolean;\n  key: string;\n  name: string;\n  userid: string;\n  dns: string;\n  ipv4: string;\n  ipv6: string;\n  os: string;\n  online: boolean;\n  lastseen: Date;\n  exitnode: boolean;\n  exitnodeoption: boolean;\n  tags?: string[];\n}\n\nexport class InvalidPathError extends Error {}\nexport class NotRunningError extends Error {}\nexport class NotConnectedError extends Error {}\nexport class ENOBUFSError extends Error {}\nexport class MaxBufferNaNError extends Error {}\n\nexport type StatusDevice = {\n  Active: boolean;\n  ID: string;\n  DNSName: string;\n  ExitNode: boolean;\n  ExitNodeOption: boolean;\n  Online: boolean;\n  OS: string;\n  TailscaleIPs: string[];\n  LastSeen: string;\n  UserID: number;\n  HostName: string;\n  Tags?: string[];\n};\n\n/**\n * StatusResponse is a subset of the fields returned by `tailscale status --json`.\n */\nexport type StatusResponse = {\n  Version: string;\n  TailscaleIPs: string[];\n  Self: StatusDevice;\n  MagicDNSSuffix: string;\n  Peer: Record<string, StatusDevice>;\n  User: Record<\n    string,\n    {\n      ID: number;\n      DisplayName: string;\n      LoginName: string;\n      ProfilePictureURL: string;\n    }\n  >;\n};\n\n/**\n * NetcheckResponse are the fields returned by `tailscale netcheck --format json`.\n * These are mentioned to not be stable and may change in the future. Doubtful, but possible.\n */\nexport type NetcheckResponse = {\n  UDP: boolean;\n  IPv4: boolean;\n  GlobalV4: string;\n  IPv6: boolean;\n  GlobalV6: string;\n  MappingVariesByDestIP: boolean;\n  UPnP: boolean;\n  PMP: boolean;\n  PCP: boolean;\n  PreferredDERP: number;\n  RegionLatency: Record<string, number>;\n  RegionV4Latency: Record<string, number>;\n  RegionV6Latency: Record<string, number>;\n};\n\nexport type DerpRegion = {\n  RegionId: number;\n  RegionCode: string;\n  RegionName: string;\n  Latitude: number;\n  Longitude: number;\n  Nodes: DerpNode[];\n};\n\ntype DerpNode = {\n  Name: string;\n  RegionID: number;\n  HostName: string;\n  IPv4: string;\n  IPv6: string;\n  CanPort80: boolean;\n};\n\nexport type Derp = {\n  id: string;\n  code: string;\n  name: string;\n  latency: string | undefined;\n  latencies: {\n    v4: string | undefined;\n    v6: string | undefined;\n  };\n  nodes: DerpNode[];\n};\n\nexport function getStatus(peers = true) {\n  const resp = tailscale(`status --json --peers=${peers}`);\n  const data = JSON.parse(resp) as StatusResponse;\n  if (!data || !data.Self.Online) {\n    throw new NotConnectedError();\n  }\n  return data;\n}\n\nexport function getNetcheck() {\n  const resp = tailscale(\"netcheck --format json\");\n  return JSON.parse(resp);\n}\n\n/**\n * This funtion relies on a debug command, so it may not be stable on the returned value.\n */\nexport function getDerpMap() {\n  const resp = tailscale(\"debug netmap\");\n  return JSON.parse(resp).DERPMap.Regions as DerpRegion[];\n}\n\nexport function getDevices(status: StatusResponse) {\n  const devices: Device[] = [];\n  const self = status.Self;\n\n  const me = {\n    self: true,\n    key: self.ID,\n    name: self.DNSName.split(\".\")[0],\n    userid: self.UserID.toString(),\n    dns: self.DNSName,\n    ipv4: self.TailscaleIPs[0],\n    ipv6: self.TailscaleIPs[1],\n    os: self.OS,\n    online: self.Online,\n    lastseen: new Date(self.LastSeen),\n    exitnode: self.ExitNode,\n    exitnodeoption: self.ExitNodeOption,\n    tags: self.Tags,\n  };\n\n  devices.push(me);\n\n  for (const [, peer] of Object.entries(status.Peer)) {\n    const device = {\n      self: false,\n      key: peer.ID,\n      name: peer.DNSName.split(\".\")[0],\n      userid: peer.UserID.toString(),\n      dns: peer.DNSName,\n      ipv4: peer.TailscaleIPs[0],\n      ipv6: peer.TailscaleIPs[1],\n      os: peer.OS == \"linux\" ? \"Linux\" : peer.OS,\n      online: peer.Online,\n      lastseen: new Date(peer.LastSeen),\n      exitnode: peer.ExitNode,\n      exitnodeoption: peer.ExitNodeOption,\n      tags: peer.Tags,\n    };\n    devices.push(device);\n  }\n  return devices;\n}\n\nexport function sortDevices(devices: Device[]) {\n  devices.sort((a, b) => {\n    // self should always be first\n    if (a.self) {\n      return -1;\n    } else if (b.self) {\n      return 1;\n    }\n    // then sort by online status\n    if (a.online && !b.online) {\n      return -1;\n    } else if (!a.online && b.online) {\n      return 1;\n    }\n    // lastly, sort by name\n    return a.name.localeCompare(b.name);\n  });\n}\n\nconst prefs = getPreferenceValues();\n\nconst tailscalePath: string =\n  prefs.tailscalePath && prefs.tailscalePath.length > 0\n    ? prefs.tailscalePath\n    : \"/Applications/Tailscale.app/Contents/MacOS/Tailscale\";\n\nconst execMaxBuffersBytes: number =\n  prefs.tailscaleExecMaxBuffersMB && (prefs.tailscaleExecMaxBuffersMB as number)\n    ? prefs.tailscaleExecMaxBuffersMB * 1024 * 1024\n    : 10 * 1024 * 1024; // 10 megabytes\n\n/**\n * tailscale runs a command against the Tailscale CLI.\n */\nexport function tailscale(parameters: string): string {\n  try {\n    return execSync(`${tailscalePath} ${parameters}`, { maxBuffer: execMaxBuffersBytes }).toString().trim();\n  } catch (err) {\n    if (err instanceof Error) {\n      if (err.message.includes(\"No such file or directory\")) {\n        throw new InvalidPathError();\n      } else if (err.message.includes(\"is Tailscale running?\")) {\n        throw new NotRunningError();\n      } else if (err.message.includes(\"spawnSync /bin/sh ENOBUFS\")) {\n        throw new ENOBUFSError();\n      } else if (\n        err.message.includes(\n          'The value of \"options.maxBuffer\" is out of range. It must be a positive number. Received NaN',\n        )\n      ) {\n        throw new MaxBufferNaNError();\n      }\n    }\n    console.log(`throwing error: ${err}`);\n    throw err;\n  }\n}\n\nexport type ErrorDetails = {\n  title: string;\n  description: string;\n};\n\nexport function getErrorDetails(err: unknown, fallbackMessage: string): ErrorDetails {\n  if (err instanceof InvalidPathError) {\n    return {\n      title: \"Can\u2019t find the Tailscale CLI\",\n      description: \"Your Tailscale CLI Path is invalid.\\nUpdate your extension preferences to fix this.\",\n    };\n  } else if (err instanceof NotRunningError) {\n    return {\n      title: \"Can\u2019t connect to Tailscale\",\n      description: \"Make sure Tailscale is running and try again.\",\n    };\n  } else if (err instanceof NotConnectedError) {\n    return {\n      title: \"Not connected to a tailnet\",\n      description: \"Tailscale is running, but you\u2019re not connected to a tailnet.\\nLog in and try again.\",\n    };\n  } else if (err instanceof ENOBUFSError) {\n    return {\n      title: \"Response larger than buffer size\",\n      description: \"Increase `Max buffers ...` in the extension configuration.\",\n    };\n  } else if (err instanceof MaxBufferNaNError) {\n    return {\n      title: \"Invalid `Max buffers ...` configuration\",\n      description: \"Set `Max buffers ...` to a number in the extension configuration.\",\n    };\n  }\n  console.log(`Unhandled error: ${err}`);\n  return {\n    title: \"Something went wrong\",\n    description: fallbackMessage,\n  };\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "import { ActionPanel, Action } from \"@raycast/api\";\nimport type { Device } from \"../shared\";\n\nexport default function CopyActions({ device }: { device: Device }) {\n  return (\n    <ActionPanel>\n      <Action.CopyToClipboard content={device.ipv4} title=\"Copy IPv4\" />\n      <Action.CopyToClipboard\n        content={device.dns.endsWith(\".\") ? device.dns.slice(0, -1) : device.dns}\n        title=\"Copy MagicDNS\"\n      />\n      <Action.CopyToClipboard content={device.ipv6} title=\"Copy IPv6\" />\n    </ActionPanel>\n  );\n}\n"],
  "mappings": "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",
  "names": ["my_devices_exports", "__export", "MyDeviceList", "__toCommonJS", "import_api", "import_react", "import_api", "import_node_child_process", "InvalidPathError", "NotRunningError", "NotConnectedError", "ENOBUFSError", "MaxBufferNaNError", "getStatus", "peers", "resp", "tailscale", "data", "getDevices", "status", "devices", "self", "me", "peer", "device", "sortDevices", "a", "b", "prefs", "tailscalePath", "execMaxBuffersBytes", "tailscale", "parameters", "err", "InvalidPathError", "NotRunningError", "ENOBUFSError", "MaxBufferNaNError", "getErrorDetails", "fallbackMessage", "NotConnectedError", "import_api", "import_jsx_runtime", "CopyActions", "device", "import_jsx_runtime", "MyDeviceList", "devices", "setDevices", "error", "setError", "fetch", "status", "getStatus", "me", "_mylist", "getDevices", "device", "sortDevices", "getErrorDetails", "CopyActions"]
}

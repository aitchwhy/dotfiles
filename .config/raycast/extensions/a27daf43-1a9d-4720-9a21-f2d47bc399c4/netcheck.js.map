{
  "version": 3,
  "sources": ["../src/netcheck.tsx", "../src/shared.tsx"],
  "sourcesContent": ["import { List, Icon, ActionPanel, Action, Color } from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport { getErrorDetails, ErrorDetails, getNetcheck, getDerpMap, NetcheckResponse, Derp } from \"./shared\";\n\nconst getDerps = (netcheck: NetcheckResponse, setPreferredDERP: (derp: Derp) => void) => {\n  // the netcheck json response contains a map of region IDs to latencies, so we need to map them to the actual region data\n  // the pretty printed command does that behind the scenes\n  const _derpMap = getDerpMap();\n  return Object.keys(netcheck.RegionLatency)\n    .map((key) => {\n      const _key = parseInt(key);\n      const derp = {\n        id: key,\n        code: _derpMap[_key].RegionCode,\n        name: _derpMap[_key].RegionName,\n        latency: netcheck.RegionLatency[key] ? (netcheck.RegionLatency[key] / 1000000).toFixed(1) : undefined,\n        latencies: {\n          v4: netcheck.RegionV4Latency[key] ? (netcheck.RegionV4Latency[key] / 1000000).toFixed(1) : undefined,\n          v6: netcheck.RegionV6Latency[key] ? (netcheck.RegionV6Latency[key] / 1000000).toFixed(1) : undefined,\n        },\n        nodes: _derpMap[_key].Nodes,\n      };\n      netcheck.PreferredDERP === _key && setPreferredDERP(derp);\n      return derp;\n    })\n    .sort((a, b) => {\n      if (a.latency && b.latency) return parseFloat(a.latency) - parseFloat(b.latency);\n      if (a.latency) return 1;\n      if (b.latency) return -1;\n      return 0;\n    });\n};\n\nexport default function MyDeviceList() {\n  const [netcheck, setNetcheck] = useState<NetcheckResponse>();\n  const [portMappings, setPortMappings] = useState<string[]>([]);\n  const [derps, setDerps] = useState<Derp[]>([]);\n  const [preferredDERP, setPreferredDERP] = useState<Derp>();\n  const [error, setError] = useState<ErrorDetails>();\n\n  useEffect(() => {\n    async function fetch() {\n      try {\n        const _netcheck = getNetcheck();\n        setDerps(getDerps(_netcheck, setPreferredDERP));\n        setNetcheck(_netcheck);\n        setPortMappings(\n          [\"UPnP\", \"PMP\", \"PCP\"].reduce((acc, mapping) => {\n            _netcheck[mapping] && acc.push(mapping);\n            return acc;\n          }, [] as string[]),\n        );\n      } catch (error) {\n        setError(getErrorDetails(error, \"Couldn\u2019t load netcheck.\"));\n      }\n    }\n    fetch();\n  }, []);\n\n  return (\n    <List isLoading={!netcheck && !portMappings && !error}>\n      {error ? (\n        <List.EmptyView icon={Icon.Warning} title={error.title} description={error.description} />\n      ) : (\n        <>\n          <List.Item title=\"UDP\" subtitle={String(netcheck?.UDP)} />\n          <List.Item\n            title=\"IPv4\"\n            subtitle={`${netcheck?.IPv4 ? `yes, ${netcheck?.GlobalV4}` : \"no\"}`}\n            actions={\n              <ActionPanel>\n                {netcheck?.IPv4 && <Action.CopyToClipboard title=\"Copy IPv4\" content={netcheck?.GlobalV4} />}\n                {netcheck?.IPv4 && <Action.Paste title=\"Paste IPv4\" content={netcheck?.GlobalV4} />}\n              </ActionPanel>\n            }\n          />\n          <List.Item\n            title=\"IPv6\"\n            subtitle={`${netcheck?.IPv6 ? `yes, ${netcheck?.GlobalV6}` : \"no\"}`}\n            actions={\n              <ActionPanel>\n                {netcheck?.IPv6 && <Action.CopyToClipboard title=\"Copy IPv6\" content={netcheck?.GlobalV6} />}\n                {netcheck?.IPv6 && <Action.Paste title=\"Paste IPv6\" content={netcheck?.GlobalV6} />}\n              </ActionPanel>\n            }\n          />\n          <List.Item title=\"Mapping Varies by Destination IP\" subtitle={String(netcheck?.MappingVariesByDestIP)} />\n          <List.Item title=\"Port Mapping\" subtitle={portMappings.join(\", \")} />\n          <List.Item title=\"Nearest DERP\" subtitle={preferredDERP?.name} />\n          <List.Section title=\"DERP Regions\">\n            {derps.map((derp) => (\n              <List.Item\n                title={derp.code}\n                subtitle={`${derp.name} \u00B7 ${derp.nodes?.length} node${derp.nodes?.length === 1 ? \"\" : \"s\"}`}\n                accessories={[\n                  ...(derp.id === String(netcheck?.PreferredDERP)\n                    ? [{ icon: { source: Icon.Star, tintColor: Color.Yellow } }]\n                    : []),\n                  {\n                    text: `${derp.latency} ms`,\n                  },\n                ]}\n                keywords={[derp.id, derp.name]}\n                key={derp.id}\n                actions={\n                  <ActionPanel>\n                    <Action.Push title=\"Open Details\" target={derpDetails(derp)} />\n                    <Action.CopyToClipboard title=\"Copy Name\" content={derp.name} />\n                    <Action.CopyToClipboard title=\"Copy Code\" content={derp.code} />\n                    {derp.latency && <Action.CopyToClipboard title=\"Copy Latency\" content={derp.latency} />}\n                  </ActionPanel>\n                }\n              />\n            ))}\n          </List.Section>\n        </>\n      )}\n    </List>\n  );\n}\n\nexport function derpDetails(derp: Derp) {\n  return (\n    <List navigationTitle={`${derp.code} (${derp.name})`}>\n      <List.Item title=\"Code\" subtitle={derp.code} />\n      <List.Item title=\"Name\" subtitle={derp.name} />\n      <List.Item title=\"ID\" subtitle={derp.id} />\n      <List.Section title=\"Latencies\">\n        {derp.latencies.v4 && <List.Item title=\"IPv4\" subtitle={`${derp.latencies.v4} ms`} />}\n        {derp.latencies.v6 && <List.Item title=\"IPv6\" subtitle={`${derp.latencies.v6} ms`} />}\n      </List.Section>\n      <List.Section title=\"Servers\">\n        {derp.nodes?.map((node) => (\n          <List.Item\n            title={node.Name}\n            subtitle={node.HostName}\n            keywords={[node.HostName, node.IPv4, node.IPv6]}\n            key={node.Name}\n            actions={\n              <ActionPanel>\n                <Action.CopyToClipboard title=\"Copy Hostname\" content={node.HostName} />\n                {node.IPv4 && <Action.CopyToClipboard title=\"Copy IPv4\" content={node.IPv4} />}\n                {node.IPv6 && <Action.CopyToClipboard title=\"Copy IPv6\" content={node.IPv6} />}\n              </ActionPanel>\n            }\n          />\n        ))}\n      </List.Section>\n    </List>\n  );\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { execSync } from \"node:child_process\";\n\nexport const MULLVAD_DEVICE_TAG = \"tag:mullvad-exit-node\";\n\nexport interface Device {\n  self: boolean;\n  key: string;\n  name: string;\n  userid: string;\n  dns: string;\n  ipv4: string;\n  ipv6: string;\n  os: string;\n  online: boolean;\n  lastseen: Date;\n  exitnode: boolean;\n  exitnodeoption: boolean;\n  tags?: string[];\n}\n\nexport class InvalidPathError extends Error {}\nexport class NotRunningError extends Error {}\nexport class NotConnectedError extends Error {}\nexport class ENOBUFSError extends Error {}\nexport class MaxBufferNaNError extends Error {}\n\nexport type StatusDevice = {\n  Active: boolean;\n  ID: string;\n  DNSName: string;\n  ExitNode: boolean;\n  ExitNodeOption: boolean;\n  Online: boolean;\n  OS: string;\n  TailscaleIPs: string[];\n  LastSeen: string;\n  UserID: number;\n  HostName: string;\n  Tags?: string[];\n};\n\n/**\n * StatusResponse is a subset of the fields returned by `tailscale status --json`.\n */\nexport type StatusResponse = {\n  Version: string;\n  TailscaleIPs: string[];\n  Self: StatusDevice;\n  MagicDNSSuffix: string;\n  Peer: Record<string, StatusDevice>;\n  User: Record<\n    string,\n    {\n      ID: number;\n      DisplayName: string;\n      LoginName: string;\n      ProfilePictureURL: string;\n    }\n  >;\n};\n\n/**\n * NetcheckResponse are the fields returned by `tailscale netcheck --format json`.\n * These are mentioned to not be stable and may change in the future. Doubtful, but possible.\n */\nexport type NetcheckResponse = {\n  UDP: boolean;\n  IPv4: boolean;\n  GlobalV4: string;\n  IPv6: boolean;\n  GlobalV6: string;\n  MappingVariesByDestIP: boolean;\n  UPnP: boolean;\n  PMP: boolean;\n  PCP: boolean;\n  PreferredDERP: number;\n  RegionLatency: Record<string, number>;\n  RegionV4Latency: Record<string, number>;\n  RegionV6Latency: Record<string, number>;\n};\n\nexport type DerpRegion = {\n  RegionId: number;\n  RegionCode: string;\n  RegionName: string;\n  Latitude: number;\n  Longitude: number;\n  Nodes: DerpNode[];\n};\n\ntype DerpNode = {\n  Name: string;\n  RegionID: number;\n  HostName: string;\n  IPv4: string;\n  IPv6: string;\n  CanPort80: boolean;\n};\n\nexport type Derp = {\n  id: string;\n  code: string;\n  name: string;\n  latency: string | undefined;\n  latencies: {\n    v4: string | undefined;\n    v6: string | undefined;\n  };\n  nodes: DerpNode[];\n};\n\nexport function getStatus(peers = true) {\n  const resp = tailscale(`status --json --peers=${peers}`);\n  const data = JSON.parse(resp) as StatusResponse;\n  if (!data || !data.Self.Online) {\n    throw new NotConnectedError();\n  }\n  return data;\n}\n\nexport function getNetcheck() {\n  const resp = tailscale(\"netcheck --format json\");\n  return JSON.parse(resp);\n}\n\n/**\n * This funtion relies on a debug command, so it may not be stable on the returned value.\n */\nexport function getDerpMap() {\n  const resp = tailscale(\"debug netmap\");\n  return JSON.parse(resp).DERPMap.Regions as DerpRegion[];\n}\n\nexport function getDevices(status: StatusResponse) {\n  const devices: Device[] = [];\n  const self = status.Self;\n\n  const me = {\n    self: true,\n    key: self.ID,\n    name: self.DNSName.split(\".\")[0],\n    userid: self.UserID.toString(),\n    dns: self.DNSName,\n    ipv4: self.TailscaleIPs[0],\n    ipv6: self.TailscaleIPs[1],\n    os: self.OS,\n    online: self.Online,\n    lastseen: new Date(self.LastSeen),\n    exitnode: self.ExitNode,\n    exitnodeoption: self.ExitNodeOption,\n    tags: self.Tags,\n  };\n\n  devices.push(me);\n\n  for (const [, peer] of Object.entries(status.Peer)) {\n    const device = {\n      self: false,\n      key: peer.ID,\n      name: peer.DNSName.split(\".\")[0],\n      userid: peer.UserID.toString(),\n      dns: peer.DNSName,\n      ipv4: peer.TailscaleIPs[0],\n      ipv6: peer.TailscaleIPs[1],\n      os: peer.OS == \"linux\" ? \"Linux\" : peer.OS,\n      online: peer.Online,\n      lastseen: new Date(peer.LastSeen),\n      exitnode: peer.ExitNode,\n      exitnodeoption: peer.ExitNodeOption,\n      tags: peer.Tags,\n    };\n    devices.push(device);\n  }\n  return devices;\n}\n\nexport function sortDevices(devices: Device[]) {\n  devices.sort((a, b) => {\n    // self should always be first\n    if (a.self) {\n      return -1;\n    } else if (b.self) {\n      return 1;\n    }\n    // then sort by online status\n    if (a.online && !b.online) {\n      return -1;\n    } else if (!a.online && b.online) {\n      return 1;\n    }\n    // lastly, sort by name\n    return a.name.localeCompare(b.name);\n  });\n}\n\nconst prefs = getPreferenceValues();\n\nconst tailscalePath: string =\n  prefs.tailscalePath && prefs.tailscalePath.length > 0\n    ? prefs.tailscalePath\n    : \"/Applications/Tailscale.app/Contents/MacOS/Tailscale\";\n\nconst execMaxBuffersBytes: number =\n  prefs.tailscaleExecMaxBuffersMB && (prefs.tailscaleExecMaxBuffersMB as number)\n    ? prefs.tailscaleExecMaxBuffersMB * 1024 * 1024\n    : 10 * 1024 * 1024; // 10 megabytes\n\n/**\n * tailscale runs a command against the Tailscale CLI.\n */\nexport function tailscale(parameters: string): string {\n  try {\n    return execSync(`${tailscalePath} ${parameters}`, { maxBuffer: execMaxBuffersBytes }).toString().trim();\n  } catch (err) {\n    if (err instanceof Error) {\n      if (err.message.includes(\"No such file or directory\")) {\n        throw new InvalidPathError();\n      } else if (err.message.includes(\"is Tailscale running?\")) {\n        throw new NotRunningError();\n      } else if (err.message.includes(\"spawnSync /bin/sh ENOBUFS\")) {\n        throw new ENOBUFSError();\n      } else if (\n        err.message.includes(\n          'The value of \"options.maxBuffer\" is out of range. It must be a positive number. Received NaN',\n        )\n      ) {\n        throw new MaxBufferNaNError();\n      }\n    }\n    console.log(`throwing error: ${err}`);\n    throw err;\n  }\n}\n\nexport type ErrorDetails = {\n  title: string;\n  description: string;\n};\n\nexport function getErrorDetails(err: unknown, fallbackMessage: string): ErrorDetails {\n  if (err instanceof InvalidPathError) {\n    return {\n      title: \"Can\u2019t find the Tailscale CLI\",\n      description: \"Your Tailscale CLI Path is invalid.\\nUpdate your extension preferences to fix this.\",\n    };\n  } else if (err instanceof NotRunningError) {\n    return {\n      title: \"Can\u2019t connect to Tailscale\",\n      description: \"Make sure Tailscale is running and try again.\",\n    };\n  } else if (err instanceof NotConnectedError) {\n    return {\n      title: \"Not connected to a tailnet\",\n      description: \"Tailscale is running, but you\u2019re not connected to a tailnet.\\nLog in and try again.\",\n    };\n  } else if (err instanceof ENOBUFSError) {\n    return {\n      title: \"Response larger than buffer size\",\n      description: \"Increase `Max buffers ...` in the extension configuration.\",\n    };\n  } else if (err instanceof MaxBufferNaNError) {\n    return {\n      title: \"Invalid `Max buffers ...` configuration\",\n      description: \"Set `Max buffers ...` to a number in the extension configuration.\",\n    };\n  }\n  console.log(`Unhandled error: ${err}`);\n  return {\n    title: \"Something went wrong\",\n    description: fallbackMessage,\n  };\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],
  "mappings": "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",
  "names": ["netcheck_exports", "__export", "MyDeviceList", "derpDetails", "__toCommonJS", "import_api", "import_react", "import_api", "import_node_child_process", "InvalidPathError", "NotRunningError", "NotConnectedError", "ENOBUFSError", "MaxBufferNaNError", "getNetcheck", "resp", "tailscale", "getDerpMap", "prefs", "tailscalePath", "execMaxBuffersBytes", "tailscale", "parameters", "err", "InvalidPathError", "NotRunningError", "ENOBUFSError", "MaxBufferNaNError", "getErrorDetails", "fallbackMessage", "NotConnectedError", "import_jsx_runtime", "getDerps", "netcheck", "setPreferredDERP", "_derpMap", "getDerpMap", "key", "_key", "derp", "a", "b", "MyDeviceList", "setNetcheck", "portMappings", "setPortMappings", "derps", "setDerps", "preferredDERP", "error", "setError", "fetch", "_netcheck", "getNetcheck", "acc", "mapping", "getErrorDetails", "derpDetails", "node"]
}

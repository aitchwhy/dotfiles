{
  "version": 3,
  "sources": ["../src/connect.tsx", "../src/shared.tsx"],
  "sourcesContent": ["import { closeMainWindow, popToRoot, showHUD, showToast, Toast, updateCommandMetadata } from \"@raycast/api\";\nimport { getErrorDetails, tailscale, getStatus, sleep } from \"./shared\";\n\nexport default async function Connect() {\n  let subtitle: string;\n  try {\n    await showToast({\n      style: Toast.Style.Animated,\n      title: \"Connecting\",\n    });\n\n    await updateCommandMetadata({ subtitle: \"\" });\n\n    popToRoot();\n    closeMainWindow();\n    tailscale(\"up\");\n\n    await sleep(2000); // `up` can take some time to complete, checking status before it's done can report the device is still offline\n\n    const data = getStatus(false);\n    const magicDNSSuffix = data.MagicDNSSuffix;\n\n    subtitle = `Connected on ${magicDNSSuffix}`;\n    showHUD(subtitle);\n  } catch (err) {\n    console.error(err);\n    subtitle = getErrorDetails(err, \"\").title;\n    showHUD(`Unable to connect: ${subtitle}`);\n  }\n  await updateCommandMetadata({ subtitle });\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { execSync } from \"node:child_process\";\n\nexport const MULLVAD_DEVICE_TAG = \"tag:mullvad-exit-node\";\n\nexport interface Device {\n  self: boolean;\n  key: string;\n  name: string;\n  userid: string;\n  dns: string;\n  ipv4: string;\n  ipv6: string;\n  os: string;\n  online: boolean;\n  lastseen: Date;\n  exitnode: boolean;\n  exitnodeoption: boolean;\n  tags?: string[];\n}\n\nexport class InvalidPathError extends Error {}\nexport class NotRunningError extends Error {}\nexport class NotConnectedError extends Error {}\nexport class ENOBUFSError extends Error {}\nexport class MaxBufferNaNError extends Error {}\n\nexport type StatusDevice = {\n  Active: boolean;\n  ID: string;\n  DNSName: string;\n  ExitNode: boolean;\n  ExitNodeOption: boolean;\n  Online: boolean;\n  OS: string;\n  TailscaleIPs: string[];\n  LastSeen: string;\n  UserID: number;\n  HostName: string;\n  Tags?: string[];\n};\n\n/**\n * StatusResponse is a subset of the fields returned by `tailscale status --json`.\n */\nexport type StatusResponse = {\n  Version: string;\n  TailscaleIPs: string[];\n  Self: StatusDevice;\n  MagicDNSSuffix: string;\n  Peer: Record<string, StatusDevice>;\n  User: Record<\n    string,\n    {\n      ID: number;\n      DisplayName: string;\n      LoginName: string;\n      ProfilePictureURL: string;\n    }\n  >;\n};\n\n/**\n * NetcheckResponse are the fields returned by `tailscale netcheck --format json`.\n * These are mentioned to not be stable and may change in the future. Doubtful, but possible.\n */\nexport type NetcheckResponse = {\n  UDP: boolean;\n  IPv4: boolean;\n  GlobalV4: string;\n  IPv6: boolean;\n  GlobalV6: string;\n  MappingVariesByDestIP: boolean;\n  UPnP: boolean;\n  PMP: boolean;\n  PCP: boolean;\n  PreferredDERP: number;\n  RegionLatency: Record<string, number>;\n  RegionV4Latency: Record<string, number>;\n  RegionV6Latency: Record<string, number>;\n};\n\nexport type DerpRegion = {\n  RegionId: number;\n  RegionCode: string;\n  RegionName: string;\n  Latitude: number;\n  Longitude: number;\n  Nodes: DerpNode[];\n};\n\ntype DerpNode = {\n  Name: string;\n  RegionID: number;\n  HostName: string;\n  IPv4: string;\n  IPv6: string;\n  CanPort80: boolean;\n};\n\nexport type Derp = {\n  id: string;\n  code: string;\n  name: string;\n  latency: string | undefined;\n  latencies: {\n    v4: string | undefined;\n    v6: string | undefined;\n  };\n  nodes: DerpNode[];\n};\n\nexport function getStatus(peers = true) {\n  const resp = tailscale(`status --json --peers=${peers}`);\n  const data = JSON.parse(resp) as StatusResponse;\n  if (!data || !data.Self.Online) {\n    throw new NotConnectedError();\n  }\n  return data;\n}\n\nexport function getNetcheck() {\n  const resp = tailscale(\"netcheck --format json\");\n  return JSON.parse(resp);\n}\n\n/**\n * This funtion relies on a debug command, so it may not be stable on the returned value.\n */\nexport function getDerpMap() {\n  const resp = tailscale(\"debug netmap\");\n  return JSON.parse(resp).DERPMap.Regions as DerpRegion[];\n}\n\nexport function getDevices(status: StatusResponse) {\n  const devices: Device[] = [];\n  const self = status.Self;\n\n  const me = {\n    self: true,\n    key: self.ID,\n    name: self.DNSName.split(\".\")[0],\n    userid: self.UserID.toString(),\n    dns: self.DNSName,\n    ipv4: self.TailscaleIPs[0],\n    ipv6: self.TailscaleIPs[1],\n    os: self.OS,\n    online: self.Online,\n    lastseen: new Date(self.LastSeen),\n    exitnode: self.ExitNode,\n    exitnodeoption: self.ExitNodeOption,\n    tags: self.Tags,\n  };\n\n  devices.push(me);\n\n  for (const [, peer] of Object.entries(status.Peer)) {\n    const device = {\n      self: false,\n      key: peer.ID,\n      name: peer.DNSName.split(\".\")[0],\n      userid: peer.UserID.toString(),\n      dns: peer.DNSName,\n      ipv4: peer.TailscaleIPs[0],\n      ipv6: peer.TailscaleIPs[1],\n      os: peer.OS == \"linux\" ? \"Linux\" : peer.OS,\n      online: peer.Online,\n      lastseen: new Date(peer.LastSeen),\n      exitnode: peer.ExitNode,\n      exitnodeoption: peer.ExitNodeOption,\n      tags: peer.Tags,\n    };\n    devices.push(device);\n  }\n  return devices;\n}\n\nexport function sortDevices(devices: Device[]) {\n  devices.sort((a, b) => {\n    // self should always be first\n    if (a.self) {\n      return -1;\n    } else if (b.self) {\n      return 1;\n    }\n    // then sort by online status\n    if (a.online && !b.online) {\n      return -1;\n    } else if (!a.online && b.online) {\n      return 1;\n    }\n    // lastly, sort by name\n    return a.name.localeCompare(b.name);\n  });\n}\n\nconst prefs = getPreferenceValues();\n\nconst tailscalePath: string =\n  prefs.tailscalePath && prefs.tailscalePath.length > 0\n    ? prefs.tailscalePath\n    : \"/Applications/Tailscale.app/Contents/MacOS/Tailscale\";\n\nconst execMaxBuffersBytes: number =\n  prefs.tailscaleExecMaxBuffersMB && (prefs.tailscaleExecMaxBuffersMB as number)\n    ? prefs.tailscaleExecMaxBuffersMB * 1024 * 1024\n    : 10 * 1024 * 1024; // 10 megabytes\n\n/**\n * tailscale runs a command against the Tailscale CLI.\n */\nexport function tailscale(parameters: string): string {\n  try {\n    return execSync(`${tailscalePath} ${parameters}`, { maxBuffer: execMaxBuffersBytes }).toString().trim();\n  } catch (err) {\n    if (err instanceof Error) {\n      if (err.message.includes(\"No such file or directory\")) {\n        throw new InvalidPathError();\n      } else if (err.message.includes(\"is Tailscale running?\")) {\n        throw new NotRunningError();\n      } else if (err.message.includes(\"spawnSync /bin/sh ENOBUFS\")) {\n        throw new ENOBUFSError();\n      } else if (\n        err.message.includes(\n          'The value of \"options.maxBuffer\" is out of range. It must be a positive number. Received NaN',\n        )\n      ) {\n        throw new MaxBufferNaNError();\n      }\n    }\n    console.log(`throwing error: ${err}`);\n    throw err;\n  }\n}\n\nexport type ErrorDetails = {\n  title: string;\n  description: string;\n};\n\nexport function getErrorDetails(err: unknown, fallbackMessage: string): ErrorDetails {\n  if (err instanceof InvalidPathError) {\n    return {\n      title: \"Can\u2019t find the Tailscale CLI\",\n      description: \"Your Tailscale CLI Path is invalid.\\nUpdate your extension preferences to fix this.\",\n    };\n  } else if (err instanceof NotRunningError) {\n    return {\n      title: \"Can\u2019t connect to Tailscale\",\n      description: \"Make sure Tailscale is running and try again.\",\n    };\n  } else if (err instanceof NotConnectedError) {\n    return {\n      title: \"Not connected to a tailnet\",\n      description: \"Tailscale is running, but you\u2019re not connected to a tailnet.\\nLog in and try again.\",\n    };\n  } else if (err instanceof ENOBUFSError) {\n    return {\n      title: \"Response larger than buffer size\",\n      description: \"Increase `Max buffers ...` in the extension configuration.\",\n    };\n  } else if (err instanceof MaxBufferNaNError) {\n    return {\n      title: \"Invalid `Max buffers ...` configuration\",\n      description: \"Set `Max buffers ...` to a number in the extension configuration.\",\n    };\n  }\n  console.log(`Unhandled error: ${err}`);\n  return {\n    title: \"Something went wrong\",\n    description: fallbackMessage,\n  };\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAA6F,wBCA7F,IAAAC,EAAoC,wBACpCC,EAAyB,8BAoBlB,IAAMC,EAAN,cAA+B,KAAM,CAAC,EAChCC,EAAN,cAA8B,KAAM,CAAC,EAC/BC,EAAN,cAAgC,KAAM,CAAC,EACjCC,EAAN,cAA2B,KAAM,CAAC,EAC5BC,EAAN,cAAgC,KAAM,CAAC,EAuFvC,SAASC,EAAUC,EAAQ,GAAM,CACtC,IAAMC,EAAOC,EAAU,yBAAyBF,CAAK,EAAE,EACjDG,EAAO,KAAK,MAAMF,CAAI,EAC5B,GAAI,CAACE,GAAQ,CAACA,EAAK,KAAK,OACtB,MAAM,IAAIP,EAEZ,OAAOO,CACT,CA6EA,IAAMC,KAAQ,uBAAoB,EAE5BC,EACJD,EAAM,eAAiBA,EAAM,cAAc,OAAS,EAChDA,EAAM,cACN,uDAEAE,EACJF,EAAM,2BAA8BA,EAAM,0BACtCA,EAAM,0BAA4B,KAAO,KACzC,GAAK,KAAO,KAKX,SAASG,EAAUC,EAA4B,CACpD,GAAI,CACF,SAAO,YAAS,GAAGH,CAAa,IAAIG,CAAU,GAAI,CAAE,UAAWF,CAAoB,CAAC,EAAE,SAAS,EAAE,KAAK,CACxG,OAASG,EAAK,CACZ,GAAIA,aAAe,MAAO,CACxB,GAAIA,EAAI,QAAQ,SAAS,2BAA2B,EAClD,MAAM,IAAIC,EACL,GAAID,EAAI,QAAQ,SAAS,uBAAuB,EACrD,MAAM,IAAIE,EACL,GAAIF,EAAI,QAAQ,SAAS,2BAA2B,EACzD,MAAM,IAAIG,EACL,GACLH,EAAI,QAAQ,SACV,8FACF,EAEA,MAAM,IAAII,CAEd,CACA,cAAQ,IAAI,mBAAmBJ,CAAG,EAAE,EAC9BA,CACR,CACF,CAOO,SAASK,EAAgBL,EAAcM,EAAuC,CACnF,OAAIN,aAAeC,EACV,CACL,MAAO,oCACP,YAAa;AAAA,+CACf,EACSD,aAAeE,EACjB,CACL,MAAO,kCACP,YAAa,+CACf,EACSF,aAAeO,EACjB,CACL,MAAO,6BACP,YAAa;AAAA,sBACf,EACSP,aAAeG,EACjB,CACL,MAAO,mCACP,YAAa,4DACf,EACSH,aAAeI,EACjB,CACL,MAAO,0CACP,YAAa,mEACf,GAEF,QAAQ,IAAI,oBAAoBJ,CAAG,EAAE,EAC9B,CACL,MAAO,uBACP,YAAaM,CACf,EACF,CAEO,SAASE,EAAMC,EAAY,CAChC,OAAO,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,CACzD,CDjRA,eAAOE,GAAiC,CACtC,IAAIC,EACJ,GAAI,CACF,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,SACnB,MAAO,YACT,CAAC,EAED,QAAM,yBAAsB,CAAE,SAAU,EAAG,CAAC,KAE5C,aAAU,KACV,mBAAgB,EAChBC,EAAU,IAAI,EAEd,MAAMC,EAAM,GAAI,EAKhBF,EAAW,gBAHEG,EAAU,EAAK,EACA,cAEa,MACzC,WAAQH,CAAQ,CAClB,OAASI,EAAK,CACZ,QAAQ,MAAMA,CAAG,EACjBJ,EAAWK,EAAgBD,EAAK,EAAE,EAAE,SACpC,WAAQ,sBAAsBJ,CAAQ,EAAE,CAC1C,CACA,QAAM,yBAAsB,CAAE,SAAAA,CAAS,CAAC,CAC1C",
  "names": ["connect_exports", "__export", "Connect", "__toCommonJS", "import_api", "import_api", "import_node_child_process", "InvalidPathError", "NotRunningError", "NotConnectedError", "ENOBUFSError", "MaxBufferNaNError", "getStatus", "peers", "resp", "tailscale", "data", "prefs", "tailscalePath", "execMaxBuffersBytes", "tailscale", "parameters", "err", "InvalidPathError", "NotRunningError", "ENOBUFSError", "MaxBufferNaNError", "getErrorDetails", "fallbackMessage", "NotConnectedError", "sleep", "ms", "resolve", "Connect", "subtitle", "tailscale", "sleep", "getStatus", "err", "getErrorDetails"]
}

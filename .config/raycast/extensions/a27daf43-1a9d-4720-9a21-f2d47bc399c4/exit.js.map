{
  "version": 3,
  "sources": ["../src/exit.tsx", "../src/shared.tsx"],
  "sourcesContent": ["import { ActionPanel, List, Action, popToRoot, closeMainWindow, Image, Icon } from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport {\n  StatusResponse,\n  getStatus,\n  getDevices,\n  tailscale,\n  sortDevices,\n  ErrorDetails,\n  getErrorDetails,\n  Device,\n} from \"./shared\";\n\nfunction loadExitNodes(status: StatusResponse) {\n  const devices = getDevices(status);\n  return devices.filter((element) => {\n    return element.exitnodeoption;\n  });\n}\n\nfunction isExitNodeActive(devices: Device[]) {\n  return devices.some((d) => d.exitnode);\n}\n\nfunction setExitNode(dnsName: string, allowLAN: boolean) {\n  popToRoot();\n  closeMainWindow();\n  tailscale(`set --exit-node \"${dnsName}\"`);\n\n  if (allowLAN) {\n    tailscale(`set --exit-node-allow-lan-access`);\n  }\n}\n\nexport default function ExitNodeList() {\n  const [isActive, setIsActive] = useState<boolean>(false);\n  const [error, setError] = useState<ErrorDetails>();\n  const [exitNodes, setExitNodes] = useState<Device[]>([]);\n  useEffect(() => {\n    async function fetch() {\n      try {\n        const status = getStatus();\n        const _list = loadExitNodes(status);\n        setExitNodes(_list);\n        sortDevices(_list);\n        if (isExitNodeActive(_list)) {\n          setIsActive(true);\n        }\n      } catch (error) {\n        setError(getErrorDetails(error, \"Couldn\u2019t load exit nodes.\"));\n      }\n    }\n    fetch();\n  }, []);\n\n  return (\n    <List isLoading={!exitNodes && !error}>\n      {error ? (\n        <List.EmptyView icon={Icon.Warning} title={error.title} description={error.description} />\n      ) : (\n        <>\n          {isActive && (\n            <List.Item\n              key=\"_disable\"\n              title=\"Turn off exit node\"\n              actions={\n                <ActionPanel>\n                  <Action title=\"Turn Off Exit Node\" onAction={() => setExitNode(\"\", false)} />\n                </ActionPanel>\n              }\n            />\n          )}\n          {exitNodes?.map((exitNode) => (\n            <List.Item\n              title={exitNode.name}\n              subtitle={exitNode.ipv4 + \"    \" + exitNode.os}\n              key={exitNode.key}\n              icon={\n                exitNode.online\n                  ? {\n                      source: {\n                        light: \"connected_light.png\",\n                        dark: \"connected_dark.png\",\n                      },\n                      mask: Image.Mask.Circle,\n                    }\n                  : {\n                      source: {\n                        light: \"lastseen_light.png\",\n                        dark: \"lastseen_dark.png\",\n                      },\n                      mask: Image.Mask.Circle,\n                    }\n              }\n              accessories={[\n                {\n                  tag: exitNode.exitnode ? `Connected` : \"\",\n                },\n              ]}\n              actions={\n                <ActionPanel>\n                  <Action title=\"Use as Exit Node\" onAction={() => setExitNode(exitNode.dns, false)} />\n                  <Action\n                    title=\"Use as Exit Node and Allow LAN Access\"\n                    onAction={() => setExitNode(exitNode.dns, true)}\n                  />\n                </ActionPanel>\n              }\n            />\n          ))}\n        </>\n      )}\n    </List>\n  );\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { execSync } from \"node:child_process\";\n\nexport const MULLVAD_DEVICE_TAG = \"tag:mullvad-exit-node\";\n\nexport interface Device {\n  self: boolean;\n  key: string;\n  name: string;\n  userid: string;\n  dns: string;\n  ipv4: string;\n  ipv6: string;\n  os: string;\n  online: boolean;\n  lastseen: Date;\n  exitnode: boolean;\n  exitnodeoption: boolean;\n  tags?: string[];\n}\n\nexport class InvalidPathError extends Error {}\nexport class NotRunningError extends Error {}\nexport class NotConnectedError extends Error {}\nexport class ENOBUFSError extends Error {}\nexport class MaxBufferNaNError extends Error {}\n\nexport type StatusDevice = {\n  Active: boolean;\n  ID: string;\n  DNSName: string;\n  ExitNode: boolean;\n  ExitNodeOption: boolean;\n  Online: boolean;\n  OS: string;\n  TailscaleIPs: string[];\n  LastSeen: string;\n  UserID: number;\n  HostName: string;\n  Tags?: string[];\n};\n\n/**\n * StatusResponse is a subset of the fields returned by `tailscale status --json`.\n */\nexport type StatusResponse = {\n  Version: string;\n  TailscaleIPs: string[];\n  Self: StatusDevice;\n  MagicDNSSuffix: string;\n  Peer: Record<string, StatusDevice>;\n  User: Record<\n    string,\n    {\n      ID: number;\n      DisplayName: string;\n      LoginName: string;\n      ProfilePictureURL: string;\n    }\n  >;\n};\n\n/**\n * NetcheckResponse are the fields returned by `tailscale netcheck --format json`.\n * These are mentioned to not be stable and may change in the future. Doubtful, but possible.\n */\nexport type NetcheckResponse = {\n  UDP: boolean;\n  IPv4: boolean;\n  GlobalV4: string;\n  IPv6: boolean;\n  GlobalV6: string;\n  MappingVariesByDestIP: boolean;\n  UPnP: boolean;\n  PMP: boolean;\n  PCP: boolean;\n  PreferredDERP: number;\n  RegionLatency: Record<string, number>;\n  RegionV4Latency: Record<string, number>;\n  RegionV6Latency: Record<string, number>;\n};\n\nexport type DerpRegion = {\n  RegionId: number;\n  RegionCode: string;\n  RegionName: string;\n  Latitude: number;\n  Longitude: number;\n  Nodes: DerpNode[];\n};\n\ntype DerpNode = {\n  Name: string;\n  RegionID: number;\n  HostName: string;\n  IPv4: string;\n  IPv6: string;\n  CanPort80: boolean;\n};\n\nexport type Derp = {\n  id: string;\n  code: string;\n  name: string;\n  latency: string | undefined;\n  latencies: {\n    v4: string | undefined;\n    v6: string | undefined;\n  };\n  nodes: DerpNode[];\n};\n\nexport function getStatus(peers = true) {\n  const resp = tailscale(`status --json --peers=${peers}`);\n  const data = JSON.parse(resp) as StatusResponse;\n  if (!data || !data.Self.Online) {\n    throw new NotConnectedError();\n  }\n  return data;\n}\n\nexport function getNetcheck() {\n  const resp = tailscale(\"netcheck --format json\");\n  return JSON.parse(resp);\n}\n\n/**\n * This funtion relies on a debug command, so it may not be stable on the returned value.\n */\nexport function getDerpMap() {\n  const resp = tailscale(\"debug netmap\");\n  return JSON.parse(resp).DERPMap.Regions as DerpRegion[];\n}\n\nexport function getDevices(status: StatusResponse) {\n  const devices: Device[] = [];\n  const self = status.Self;\n\n  const me = {\n    self: true,\n    key: self.ID,\n    name: self.DNSName.split(\".\")[0],\n    userid: self.UserID.toString(),\n    dns: self.DNSName,\n    ipv4: self.TailscaleIPs[0],\n    ipv6: self.TailscaleIPs[1],\n    os: self.OS,\n    online: self.Online,\n    lastseen: new Date(self.LastSeen),\n    exitnode: self.ExitNode,\n    exitnodeoption: self.ExitNodeOption,\n    tags: self.Tags,\n  };\n\n  devices.push(me);\n\n  for (const [, peer] of Object.entries(status.Peer)) {\n    const device = {\n      self: false,\n      key: peer.ID,\n      name: peer.DNSName.split(\".\")[0],\n      userid: peer.UserID.toString(),\n      dns: peer.DNSName,\n      ipv4: peer.TailscaleIPs[0],\n      ipv6: peer.TailscaleIPs[1],\n      os: peer.OS == \"linux\" ? \"Linux\" : peer.OS,\n      online: peer.Online,\n      lastseen: new Date(peer.LastSeen),\n      exitnode: peer.ExitNode,\n      exitnodeoption: peer.ExitNodeOption,\n      tags: peer.Tags,\n    };\n    devices.push(device);\n  }\n  return devices;\n}\n\nexport function sortDevices(devices: Device[]) {\n  devices.sort((a, b) => {\n    // self should always be first\n    if (a.self) {\n      return -1;\n    } else if (b.self) {\n      return 1;\n    }\n    // then sort by online status\n    if (a.online && !b.online) {\n      return -1;\n    } else if (!a.online && b.online) {\n      return 1;\n    }\n    // lastly, sort by name\n    return a.name.localeCompare(b.name);\n  });\n}\n\nconst prefs = getPreferenceValues();\n\nconst tailscalePath: string =\n  prefs.tailscalePath && prefs.tailscalePath.length > 0\n    ? prefs.tailscalePath\n    : \"/Applications/Tailscale.app/Contents/MacOS/Tailscale\";\n\nconst execMaxBuffersBytes: number =\n  prefs.tailscaleExecMaxBuffersMB && (prefs.tailscaleExecMaxBuffersMB as number)\n    ? prefs.tailscaleExecMaxBuffersMB * 1024 * 1024\n    : 10 * 1024 * 1024; // 10 megabytes\n\n/**\n * tailscale runs a command against the Tailscale CLI.\n */\nexport function tailscale(parameters: string): string {\n  try {\n    return execSync(`${tailscalePath} ${parameters}`, { maxBuffer: execMaxBuffersBytes }).toString().trim();\n  } catch (err) {\n    if (err instanceof Error) {\n      if (err.message.includes(\"No such file or directory\")) {\n        throw new InvalidPathError();\n      } else if (err.message.includes(\"is Tailscale running?\")) {\n        throw new NotRunningError();\n      } else if (err.message.includes(\"spawnSync /bin/sh ENOBUFS\")) {\n        throw new ENOBUFSError();\n      } else if (\n        err.message.includes(\n          'The value of \"options.maxBuffer\" is out of range. It must be a positive number. Received NaN',\n        )\n      ) {\n        throw new MaxBufferNaNError();\n      }\n    }\n    console.log(`throwing error: ${err}`);\n    throw err;\n  }\n}\n\nexport type ErrorDetails = {\n  title: string;\n  description: string;\n};\n\nexport function getErrorDetails(err: unknown, fallbackMessage: string): ErrorDetails {\n  if (err instanceof InvalidPathError) {\n    return {\n      title: \"Can\u2019t find the Tailscale CLI\",\n      description: \"Your Tailscale CLI Path is invalid.\\nUpdate your extension preferences to fix this.\",\n    };\n  } else if (err instanceof NotRunningError) {\n    return {\n      title: \"Can\u2019t connect to Tailscale\",\n      description: \"Make sure Tailscale is running and try again.\",\n    };\n  } else if (err instanceof NotConnectedError) {\n    return {\n      title: \"Not connected to a tailnet\",\n      description: \"Tailscale is running, but you\u2019re not connected to a tailnet.\\nLog in and try again.\",\n    };\n  } else if (err instanceof ENOBUFSError) {\n    return {\n      title: \"Response larger than buffer size\",\n      description: \"Increase `Max buffers ...` in the extension configuration.\",\n    };\n  } else if (err instanceof MaxBufferNaNError) {\n    return {\n      title: \"Invalid `Max buffers ...` configuration\",\n      description: \"Set `Max buffers ...` to a number in the extension configuration.\",\n    };\n  }\n  console.log(`Unhandled error: ${err}`);\n  return {\n    title: \"Something went wrong\",\n    description: fallbackMessage,\n  };\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],
  "mappings": "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",
  "names": ["exit_exports", "__export", "ExitNodeList", "__toCommonJS", "import_api", "import_react", "import_api", "import_node_child_process", "InvalidPathError", "NotRunningError", "NotConnectedError", "ENOBUFSError", "MaxBufferNaNError", "getStatus", "peers", "resp", "tailscale", "data", "getDevices", "status", "devices", "self", "me", "peer", "device", "sortDevices", "a", "b", "prefs", "tailscalePath", "execMaxBuffersBytes", "tailscale", "parameters", "err", "InvalidPathError", "NotRunningError", "ENOBUFSError", "MaxBufferNaNError", "getErrorDetails", "fallbackMessage", "NotConnectedError", "import_jsx_runtime", "loadExitNodes", "status", "getDevices", "element", "isExitNodeActive", "devices", "d", "setExitNode", "dnsName", "allowLAN", "tailscale", "ExitNodeList", "isActive", "setIsActive", "error", "setError", "exitNodes", "setExitNodes", "fetch", "getStatus", "_list", "sortDevices", "getErrorDetails", "exitNode"]
}

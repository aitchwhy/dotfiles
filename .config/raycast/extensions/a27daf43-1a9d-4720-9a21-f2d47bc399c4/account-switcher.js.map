{
  "version": 3,
  "sources": ["../src/account-switcher.tsx", "../src/shared.tsx"],
  "sourcesContent": ["import {\n  ActionPanel,\n  List,\n  Action,\n  popToRoot,\n  closeMainWindow,\n  Color,\n  Icon,\n  showHUD,\n  showToast,\n  Toast,\n} from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport { ErrorDetails, getErrorDetails, tailscale } from \"./shared\";\n\ninterface User {\n  active: boolean;\n  name: string;\n}\n\nfunction loadUsers(unparsedUsers: string[]) {\n  const users: User[] = [];\n\n  if (unparsedUsers[0]?.startsWith(\"ID\")) {\n    // skip 'ID Tailnet Account' header if present\n    unparsedUsers = unparsedUsers.slice(1);\n  }\n\n  for (const unparsedUser of unparsedUsers as string[]) {\n    const unparsedUserList: string[] = unparsedUser.split(\" \").filter(Boolean);\n    let user = {} as User;\n\n    if (unparsedUserList.length == 3) {\n      // accounts with 'ID Tailnet Account'\n      user = {\n        name: unparsedUserList[1],\n        active: unparsedUserList[2].includes(\"*\"),\n      };\n    } else if (unparsedUserList.length == 2) {\n      // accounts with empty tailnet name\n      user = {\n        name: unparsedUserList[1].replace(/\\*$/, \"\"),\n        active: unparsedUserList[1].includes(\"*\"),\n      };\n    }\n    if (unparsedUserList.length == 1) {\n      // older clients\n      user = {\n        name: unparsedUserList[0].replace(/\\*$/, \"\"),\n        active: unparsedUserList[0].includes(\"*\"),\n      };\n    }\n\n    users.push(user);\n  }\n  return users;\n}\n\nexport default function AccountSwitchList() {\n  const [users, setUsers] = useState<User[]>();\n  const [error, setError] = useState<ErrorDetails>();\n  useEffect(() => {\n    async function fetch() {\n      try {\n        const ret = tailscale(`switch --list`);\n        const data = ret.split(\"\\n\");\n        const _list = loadUsers(data);\n        setUsers(_list);\n      } catch (error) {\n        setError(getErrorDetails(error, \"Couldn\u2019t load users.\"));\n      }\n    }\n    fetch();\n  }, []);\n\n  const activeUserIcon = { source: Icon.PersonCircle, tintColor: Color.Green };\n  const inactiveUserIcon = { source: Icon.PersonCircle };\n\n  // return a list of users, starting with all of the inactive users.\n  // output the active user last.\n  return (\n    <List isLoading={!users && !error}>\n      {error ? (\n        <List.EmptyView icon={Icon.Warning} title={error.title} description={error.description} />\n      ) : (\n        users\n          ?.sort((a, b) => +a.active - +b.active)\n          .map((user) => (\n            <List.Item\n              title={user.name}\n              key={user.name}\n              icon={user.active ? activeUserIcon : inactiveUserIcon}\n              subtitle={user.active ? \"Active user\" : \"\"}\n              actions={\n                <ActionPanel>\n                  <Action\n                    title=\"Switch to User\"\n                    onAction={async () => {\n                      await showToast({\n                        style: Toast.Style.Animated,\n                        title: \"Switching user account\",\n                        message: `${user.name}`,\n                      });\n                      popToRoot();\n                      closeMainWindow();\n                      const ret = tailscale(`switch ${user.name}`);\n\n                      if (ret.includes(\"Success\") || ret.includes(\"Already\")) {\n                        showHUD(`Active Tailscale user is ${user.name}`);\n                      } else {\n                        showHUD(`Tailscale user failed to switch to ${user.name}`);\n                      }\n                    }}\n                  />\n                </ActionPanel>\n              }\n            />\n          ))\n      )}\n    </List>\n  );\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { execSync } from \"node:child_process\";\n\nexport const MULLVAD_DEVICE_TAG = \"tag:mullvad-exit-node\";\n\nexport interface Device {\n  self: boolean;\n  key: string;\n  name: string;\n  userid: string;\n  dns: string;\n  ipv4: string;\n  ipv6: string;\n  os: string;\n  online: boolean;\n  lastseen: Date;\n  exitnode: boolean;\n  exitnodeoption: boolean;\n  tags?: string[];\n}\n\nexport class InvalidPathError extends Error {}\nexport class NotRunningError extends Error {}\nexport class NotConnectedError extends Error {}\nexport class ENOBUFSError extends Error {}\nexport class MaxBufferNaNError extends Error {}\n\nexport type StatusDevice = {\n  Active: boolean;\n  ID: string;\n  DNSName: string;\n  ExitNode: boolean;\n  ExitNodeOption: boolean;\n  Online: boolean;\n  OS: string;\n  TailscaleIPs: string[];\n  LastSeen: string;\n  UserID: number;\n  HostName: string;\n  Tags?: string[];\n};\n\n/**\n * StatusResponse is a subset of the fields returned by `tailscale status --json`.\n */\nexport type StatusResponse = {\n  Version: string;\n  TailscaleIPs: string[];\n  Self: StatusDevice;\n  MagicDNSSuffix: string;\n  Peer: Record<string, StatusDevice>;\n  User: Record<\n    string,\n    {\n      ID: number;\n      DisplayName: string;\n      LoginName: string;\n      ProfilePictureURL: string;\n    }\n  >;\n};\n\n/**\n * NetcheckResponse are the fields returned by `tailscale netcheck --format json`.\n * These are mentioned to not be stable and may change in the future. Doubtful, but possible.\n */\nexport type NetcheckResponse = {\n  UDP: boolean;\n  IPv4: boolean;\n  GlobalV4: string;\n  IPv6: boolean;\n  GlobalV6: string;\n  MappingVariesByDestIP: boolean;\n  UPnP: boolean;\n  PMP: boolean;\n  PCP: boolean;\n  PreferredDERP: number;\n  RegionLatency: Record<string, number>;\n  RegionV4Latency: Record<string, number>;\n  RegionV6Latency: Record<string, number>;\n};\n\nexport type DerpRegion = {\n  RegionId: number;\n  RegionCode: string;\n  RegionName: string;\n  Latitude: number;\n  Longitude: number;\n  Nodes: DerpNode[];\n};\n\ntype DerpNode = {\n  Name: string;\n  RegionID: number;\n  HostName: string;\n  IPv4: string;\n  IPv6: string;\n  CanPort80: boolean;\n};\n\nexport type Derp = {\n  id: string;\n  code: string;\n  name: string;\n  latency: string | undefined;\n  latencies: {\n    v4: string | undefined;\n    v6: string | undefined;\n  };\n  nodes: DerpNode[];\n};\n\nexport function getStatus(peers = true) {\n  const resp = tailscale(`status --json --peers=${peers}`);\n  const data = JSON.parse(resp) as StatusResponse;\n  if (!data || !data.Self.Online) {\n    throw new NotConnectedError();\n  }\n  return data;\n}\n\nexport function getNetcheck() {\n  const resp = tailscale(\"netcheck --format json\");\n  return JSON.parse(resp);\n}\n\n/**\n * This funtion relies on a debug command, so it may not be stable on the returned value.\n */\nexport function getDerpMap() {\n  const resp = tailscale(\"debug netmap\");\n  return JSON.parse(resp).DERPMap.Regions as DerpRegion[];\n}\n\nexport function getDevices(status: StatusResponse) {\n  const devices: Device[] = [];\n  const self = status.Self;\n\n  const me = {\n    self: true,\n    key: self.ID,\n    name: self.DNSName.split(\".\")[0],\n    userid: self.UserID.toString(),\n    dns: self.DNSName,\n    ipv4: self.TailscaleIPs[0],\n    ipv6: self.TailscaleIPs[1],\n    os: self.OS,\n    online: self.Online,\n    lastseen: new Date(self.LastSeen),\n    exitnode: self.ExitNode,\n    exitnodeoption: self.ExitNodeOption,\n    tags: self.Tags,\n  };\n\n  devices.push(me);\n\n  for (const [, peer] of Object.entries(status.Peer)) {\n    const device = {\n      self: false,\n      key: peer.ID,\n      name: peer.DNSName.split(\".\")[0],\n      userid: peer.UserID.toString(),\n      dns: peer.DNSName,\n      ipv4: peer.TailscaleIPs[0],\n      ipv6: peer.TailscaleIPs[1],\n      os: peer.OS == \"linux\" ? \"Linux\" : peer.OS,\n      online: peer.Online,\n      lastseen: new Date(peer.LastSeen),\n      exitnode: peer.ExitNode,\n      exitnodeoption: peer.ExitNodeOption,\n      tags: peer.Tags,\n    };\n    devices.push(device);\n  }\n  return devices;\n}\n\nexport function sortDevices(devices: Device[]) {\n  devices.sort((a, b) => {\n    // self should always be first\n    if (a.self) {\n      return -1;\n    } else if (b.self) {\n      return 1;\n    }\n    // then sort by online status\n    if (a.online && !b.online) {\n      return -1;\n    } else if (!a.online && b.online) {\n      return 1;\n    }\n    // lastly, sort by name\n    return a.name.localeCompare(b.name);\n  });\n}\n\nconst prefs = getPreferenceValues();\n\nconst tailscalePath: string =\n  prefs.tailscalePath && prefs.tailscalePath.length > 0\n    ? prefs.tailscalePath\n    : \"/Applications/Tailscale.app/Contents/MacOS/Tailscale\";\n\nconst execMaxBuffersBytes: number =\n  prefs.tailscaleExecMaxBuffersMB && (prefs.tailscaleExecMaxBuffersMB as number)\n    ? prefs.tailscaleExecMaxBuffersMB * 1024 * 1024\n    : 10 * 1024 * 1024; // 10 megabytes\n\n/**\n * tailscale runs a command against the Tailscale CLI.\n */\nexport function tailscale(parameters: string): string {\n  try {\n    return execSync(`${tailscalePath} ${parameters}`, { maxBuffer: execMaxBuffersBytes }).toString().trim();\n  } catch (err) {\n    if (err instanceof Error) {\n      if (err.message.includes(\"No such file or directory\")) {\n        throw new InvalidPathError();\n      } else if (err.message.includes(\"is Tailscale running?\")) {\n        throw new NotRunningError();\n      } else if (err.message.includes(\"spawnSync /bin/sh ENOBUFS\")) {\n        throw new ENOBUFSError();\n      } else if (\n        err.message.includes(\n          'The value of \"options.maxBuffer\" is out of range. It must be a positive number. Received NaN',\n        )\n      ) {\n        throw new MaxBufferNaNError();\n      }\n    }\n    console.log(`throwing error: ${err}`);\n    throw err;\n  }\n}\n\nexport type ErrorDetails = {\n  title: string;\n  description: string;\n};\n\nexport function getErrorDetails(err: unknown, fallbackMessage: string): ErrorDetails {\n  if (err instanceof InvalidPathError) {\n    return {\n      title: \"Can\u2019t find the Tailscale CLI\",\n      description: \"Your Tailscale CLI Path is invalid.\\nUpdate your extension preferences to fix this.\",\n    };\n  } else if (err instanceof NotRunningError) {\n    return {\n      title: \"Can\u2019t connect to Tailscale\",\n      description: \"Make sure Tailscale is running and try again.\",\n    };\n  } else if (err instanceof NotConnectedError) {\n    return {\n      title: \"Not connected to a tailnet\",\n      description: \"Tailscale is running, but you\u2019re not connected to a tailnet.\\nLog in and try again.\",\n    };\n  } else if (err instanceof ENOBUFSError) {\n    return {\n      title: \"Response larger than buffer size\",\n      description: \"Increase `Max buffers ...` in the extension configuration.\",\n    };\n  } else if (err instanceof MaxBufferNaNError) {\n    return {\n      title: \"Invalid `Max buffers ...` configuration\",\n      description: \"Set `Max buffers ...` to a number in the extension configuration.\",\n    };\n  }\n  console.log(`Unhandled error: ${err}`);\n  return {\n    title: \"Something went wrong\",\n    description: fallbackMessage,\n  };\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],
  "mappings": "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",
  "names": ["account_switcher_exports", "__export", "AccountSwitchList", "__toCommonJS", "import_api", "import_react", "import_api", "import_node_child_process", "InvalidPathError", "NotRunningError", "NotConnectedError", "ENOBUFSError", "MaxBufferNaNError", "prefs", "tailscalePath", "execMaxBuffersBytes", "tailscale", "parameters", "err", "InvalidPathError", "NotRunningError", "ENOBUFSError", "MaxBufferNaNError", "getErrorDetails", "fallbackMessage", "NotConnectedError", "import_jsx_runtime", "loadUsers", "unparsedUsers", "users", "unparsedUser", "unparsedUserList", "user", "AccountSwitchList", "setUsers", "error", "setError", "fetch", "data", "tailscale", "_list", "getErrorDetails", "activeUserIcon", "inactiveUserIcon", "a", "b", "ret"]
}

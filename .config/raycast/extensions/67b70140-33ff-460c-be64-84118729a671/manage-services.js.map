{
  "version": 3,
  "sources": ["../node_modules/isexe/windows.js", "../node_modules/isexe/mode.js", "../node_modules/isexe/index.js", "../node_modules/which/which.js", "../node_modules/path-key/index.js", "../node_modules/cross-spawn/lib/util/resolveCommand.js", "../node_modules/cross-spawn/lib/util/escape.js", "../node_modules/shebang-regex/index.js", "../node_modules/shebang-command/index.js", "../node_modules/cross-spawn/lib/util/readShebang.js", "../node_modules/cross-spawn/lib/parse.js", "../node_modules/cross-spawn/lib/enoent.js", "../node_modules/cross-spawn/index.js", "../src/manage-services.tsx", "../src/services.tsx", "../src/utils.ts", "../node_modules/is-plain-obj/index.js", "../node_modules/execa/lib/arguments/file-url.js", "../node_modules/execa/lib/methods/parameters.js", "../node_modules/execa/lib/methods/template.js", "../node_modules/execa/lib/utils/uint-array.js", "../node_modules/execa/lib/methods/main-sync.js", "../node_modules/execa/lib/arguments/specific.js", "../node_modules/execa/lib/utils/standard-stream.js", "../node_modules/execa/lib/verbose/values.js", "../node_modules/execa/lib/verbose/log.js", "../node_modules/execa/lib/arguments/escape.js", "../node_modules/is-unicode-supported/index.js", "../node_modules/figures/index.js", "../node_modules/yoctocolors/base.js", "../node_modules/execa/lib/verbose/default.js", "../node_modules/execa/lib/verbose/custom.js", "../node_modules/execa/lib/verbose/start.js", "../node_modules/execa/lib/verbose/info.js", "../node_modules/execa/lib/return/duration.js", "../node_modules/execa/lib/arguments/command.js", "../node_modules/execa/lib/arguments/options.js", "../node_modules/npm-run-path/index.js", "../node_modules/npm-run-path/node_modules/path-key/index.js", "../node_modules/unicorn-magic/node.js", "../node_modules/execa/lib/terminate/kill.js", "../node_modules/execa/lib/return/final-error.js", "../node_modules/execa/lib/terminate/signal.js", "../node_modules/human-signals/build/src/main.js", "../node_modules/human-signals/build/src/realtime.js", "../node_modules/human-signals/build/src/signals.js", "../node_modules/human-signals/build/src/core.js", "../node_modules/execa/lib/utils/abort-signal.js", "../node_modules/execa/lib/terminate/cancel.js", "../node_modules/execa/lib/ipc/graceful.js", "../node_modules/execa/lib/ipc/send.js", "../node_modules/execa/lib/ipc/validation.js", "../node_modules/execa/lib/utils/deferred.js", "../node_modules/execa/lib/arguments/fd-options.js", "../node_modules/execa/lib/ipc/strict.js", "../node_modules/execa/lib/utils/max-listeners.js", "../node_modules/execa/lib/ipc/forward.js", "../node_modules/execa/lib/ipc/incoming.js", "../node_modules/execa/lib/ipc/reference.js", "../node_modules/execa/lib/ipc/outgoing.js", "../node_modules/execa/lib/terminate/graceful.js", "../node_modules/execa/lib/terminate/timeout.js", "../node_modules/execa/lib/methods/node.js", "../node_modules/execa/lib/ipc/ipc-input.js", "../node_modules/execa/lib/arguments/encoding-option.js", "../node_modules/execa/lib/arguments/cwd.js", "../node_modules/execa/lib/return/message.js", "../node_modules/strip-final-newline/index.js", "../node_modules/get-stream/source/index.js", "../node_modules/is-stream/index.js", "../node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js", "../node_modules/get-stream/source/stream.js", "../node_modules/get-stream/source/contents.js", "../node_modules/get-stream/source/utils.js", "../node_modules/get-stream/source/array.js", "../node_modules/get-stream/source/array-buffer.js", "../node_modules/get-stream/source/string.js", "../node_modules/execa/lib/io/max-buffer.js", "../node_modules/execa/lib/return/result.js", "../node_modules/parse-ms/index.js", "../node_modules/pretty-ms/index.js", "../node_modules/execa/lib/verbose/error.js", "../node_modules/execa/lib/verbose/complete.js", "../node_modules/execa/lib/return/reject.js", "../node_modules/execa/lib/stdio/handle-sync.js", "../node_modules/execa/lib/stdio/type.js", "../node_modules/execa/lib/transform/object-mode.js", "../node_modules/execa/lib/transform/normalize.js", "../node_modules/execa/lib/stdio/direction.js", "../node_modules/execa/lib/ipc/array.js", "../node_modules/execa/lib/stdio/stdio-option.js", "../node_modules/execa/lib/stdio/native.js", "../node_modules/execa/lib/stdio/input-option.js", "../node_modules/execa/lib/stdio/duplicate.js", "../node_modules/execa/lib/stdio/handle.js", "../node_modules/execa/lib/io/strip-newline.js", "../node_modules/execa/lib/transform/generator.js", "../node_modules/execa/lib/transform/split.js", "../node_modules/execa/lib/transform/validate.js", "../node_modules/execa/lib/transform/encoding-transform.js", "../node_modules/execa/lib/transform/run-async.js", "../node_modules/execa/lib/transform/run-sync.js", "../node_modules/execa/lib/io/input-sync.js", "../node_modules/execa/lib/io/output-sync.js", "../node_modules/execa/lib/verbose/output.js", "../node_modules/execa/lib/resolve/all-sync.js", "../node_modules/execa/lib/resolve/exit-async.js", "../node_modules/execa/lib/resolve/exit-sync.js", "../node_modules/execa/lib/methods/main-async.js", "../node_modules/execa/lib/ipc/methods.js", "../node_modules/execa/lib/ipc/get-one.js", "../node_modules/execa/lib/ipc/get-each.js", "../node_modules/execa/lib/return/early-error.js", "../node_modules/execa/lib/stdio/handle-async.js", "../node_modules/@sindresorhus/merge-streams/index.js", "../node_modules/execa/lib/io/pipeline.js", "../node_modules/execa/lib/io/output-async.js", "../node_modules/execa/lib/terminate/cleanup.js", "../node_modules/signal-exit/src/signals.ts", "../node_modules/signal-exit/src/index.ts", "../node_modules/execa/lib/pipe/pipe-arguments.js", "../node_modules/execa/lib/pipe/throw.js", "../node_modules/execa/lib/pipe/sequence.js", "../node_modules/execa/lib/pipe/streaming.js", "../node_modules/execa/lib/pipe/abort.js", "../node_modules/execa/lib/pipe/setup.js", "../node_modules/execa/lib/io/contents.js", "../node_modules/execa/lib/io/iterate.js", "../node_modules/execa/lib/resolve/wait-stream.js", "../node_modules/execa/lib/resolve/stdio.js", "../node_modules/execa/lib/resolve/all-async.js", "../node_modules/execa/lib/resolve/wait-subprocess.js", "../node_modules/execa/lib/verbose/ipc.js", "../node_modules/execa/lib/ipc/buffer-messages.js", "../node_modules/execa/lib/convert/concurrent.js", "../node_modules/execa/lib/convert/readable.js", "../node_modules/execa/lib/convert/shared.js", "../node_modules/execa/lib/convert/writable.js", "../node_modules/execa/lib/convert/duplex.js", "../node_modules/execa/lib/convert/iterable.js", "../node_modules/execa/lib/convert/add.js", "../node_modules/execa/lib/methods/promise.js", "../node_modules/execa/lib/methods/bind.js", "../node_modules/execa/lib/methods/create.js", "../node_modules/execa/lib/methods/command.js", "../node_modules/execa/lib/methods/script.js", "../node_modules/execa/index.js", "../src/actions.tsx"],
  "sourcesContent": ["module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n", "module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n", "var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n", "const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n", "'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n", "'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n", "'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n", "'use strict';\nmodule.exports = /^#!(.*)/;\n", "'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n", "'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n", "'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n", "'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed, 'spawn');\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n", "'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n", "import { useEffect, useState } from \"react\";\nimport { getServices, Service } from \"./services\";\nimport { List, Icon } from \"@raycast/api\";\nimport { BrewActions } from \"./actions\";\nimport { createIcon } from \"./utils\";\n\nexport default function Command() {\n  const [services, setServices] = useState<Service[]>();\n\n  useEffect(() => {\n    getServices().then((service) => setServices(service));\n  });\n\n  return (\n    <List isLoading={!services} searchBarPlaceholder=\"Search for services...\">\n      {(services ?? []).map((d) => (\n        <List.Item\n          title={d.name}\n          subtitle={d.status}\n          accessories={d.user ? [{ text: d.user, icon: Icon.Person }] : undefined}\n          icon={createIcon(d.status)}\n          actions={<BrewActions data={d} />}\n        />\n      ))}\n    </List>\n  );\n}\n", "import { getPreferenceValues, showToast, Toast } from \"@raycast/api\";\nimport fs from \"fs\";\nimport { cpus } from \"os\";\nimport { runShellScript } from \"./utils\";\n\nexport type ServiceStatus = string;\n\nexport type Service = {\n  name: string;\n  status: ServiceStatus;\n  user: string;\n  path: string;\n};\n\nconst preferences: { brewPath: string } = getPreferenceValues();\n\nconst brewPath: string =\n  preferences.brewPath && preferences.brewPath.length > 0\n    ? preferences.brewPath\n    : cpus()[0].model.includes(\"Apple\")\n      ? \"/opt/homebrew/bin/brew\"\n      : \"/usr/local/bin/brew\";\n\nexport async function getServices(): Promise<Service[]> {\n  // make sure that brewPath exists, is a file, and is executable\n  // after this, we can assume that brewPath is valid (unless the user modifies the executable at brewPath)\n  if (!fs.existsSync(brewPath)) {\n    await showToast(Toast.Style.Failure, \"Brew Executable Not Found\", `Is brew installed at ${brewPath}?`);\n    return [];\n  }\n\n  let data = \"\";\n  try {\n    data = await runShellScript(`${brewPath} services list`);\n  } catch (e) {\n    await showToast(Toast.Style.Failure, \"Error Fetching Service Data\", `Is brew installed at ${brewPath}?`);\n    return [];\n  }\n\n  if (data === undefined) {\n    showToast(Toast.Style.Failure, \"Error Parsing Service Data\", \"Service data could not be parsed.\");\n  }\n\n  const lines = data!.split(\"\\n\");\n  if (lines.length <= 1) {\n    showToast(Toast.Style.Failure, \"Error Parsing Service Data\", \"There are no services.\");\n    return [];\n  }\n  for (let i = 0; i < lines.length - 1; i++) {\n    if (lines[i].startsWith(\"Name\")) {\n      lines.splice(0, i + 1);\n      break;\n    }\n  }\n\n  const res: Service[] = [];\n  for (const line of lines) {\n    const split = line.trim().split(/ +/g);\n    if (split.length < 2) {\n      showToast(Toast.Style.Failure, \"Error Parsing Service Data\", \"Service data could not be parsed.\");\n      return [];\n    }\n\n    const status = split[1] as ServiceStatus;\n\n    res.push({\n      name: split[0],\n      status: status,\n      user: (split.length >= 4 && split.at(-2)) || \"\",\n      path: split.at(-1) ?? \"\",\n    });\n  }\n  return res;\n}\n\nexport async function stopService(service: string) {\n  const toast = new Toast({\n    style: Toast.Style.Animated,\n    title: \"Stopping Service\",\n    message: `Stopping ${service == \"--all\" ? \"all services\" : service}`,\n  });\n  toast.show();\n\n  await runShellScript(`${brewPath} services stop ${service}`);\n\n  if (service === \"--all\") {\n    toast.style = Toast.Style.Success;\n    toast.title = \"Stopped All Services\";\n    toast.message = \"Stopped all services\";\n    return;\n  }\n\n  const data = await getServices();\n  for (const d of data) {\n    if (d.name === service) {\n      if (d.status === \"stopped\") {\n        toast.style = Toast.Style.Success;\n        toast.title = \"Stopped Service\";\n        toast.message = `Stopped ${service}`;\n      } else {\n        toast.style = Toast.Style.Failure;\n        toast.title = \"Error Stopping Service\";\n        toast.message = `${service} could not be stopped properly`;\n      }\n    }\n  }\n}\n\nexport async function startService(service: string) {\n  const toast = new Toast({\n    style: Toast.Style.Animated,\n    title: \"Starting Service\",\n    message: `Starting ${service == \"--all\" ? \"all services\" : service}`,\n  });\n  toast.show();\n\n  await runShellScript(`${brewPath} services start ${service}`);\n\n  if (service === \"--all\") {\n    toast.style = Toast.Style.Success;\n    toast.title = \"Started All Services\";\n    toast.message = \"Started all services\";\n    return;\n  }\n\n  const data = await getServices();\n  for (const d of data) {\n    if (d.name === service) {\n      if (d.status === \"started\") {\n        toast.style = Toast.Style.Success;\n        toast.title = \"Started Service\";\n        toast.message = `Started ${service}`;\n      } else {\n        toast.style = Toast.Style.Failure;\n        toast.title = \"Error Starting Service\";\n        toast.message = `${service} could not be started properly`;\n      }\n    }\n  }\n}\n\nexport async function restartService(service: string) {\n  const toast = new Toast({\n    style: Toast.Style.Animated,\n    title: \"Restarting Service\",\n    message: `Restarting ${service == \"--all\" ? \"all services\" : service}`,\n  });\n  toast.show();\n\n  await runShellScript(`${brewPath} services restart ${service}`);\n\n  if (service === \"--all\") {\n    toast.style = Toast.Style.Success;\n    toast.title = \"Restarted All Services\";\n    toast.message = \"Restarted all services\";\n    return;\n  }\n\n  const data = await getServices();\n  for (const d of data) {\n    if (d.name === service) {\n      if (d.status === \"started\" || d.status === \"running\") {\n        toast.style = Toast.Style.Success;\n        toast.title = \"Restarted Service\";\n        toast.message = `Restarted ${service}`;\n      } else {\n        toast.style = Toast.Style.Failure;\n        toast.title = \"Error Restarting Service\";\n        toast.message = `${service} could not be restarted properly`;\n      }\n    }\n  }\n}\n\nexport async function runService(service: string) {\n  const toast = new Toast({\n    style: Toast.Style.Animated,\n    title: \"Running Service\",\n    message: `Running ${service == \"--all\" ? \"all services\" : service}`,\n  });\n  toast.show();\n\n  await runShellScript(`${brewPath} services run ${service}`);\n\n  const services = await getServices();\n\n  if (service === \"--all\") {\n    toast.style = Toast.Style.Success;\n    toast.title = \"Ran All Services\";\n    toast.message = \"Ran all services\";\n    return;\n  }\n\n  const s = services.find((s) => s.name === service)!;\n  if (s.status === \"running\") {\n    toast.style = Toast.Style.Success;\n    toast.title = \"Ran Service\";\n    toast.message = `Ran ${service}`;\n  } else {\n    toast.style = Toast.Style.Failure;\n    toast.title = \"Error Running Service\";\n    toast.message = `${service} could not be run properly`;\n  }\n}\n", "import { Image, Icon, Color } from \"@raycast/api\";\nimport { execaCommand } from \"execa\";\n\nexport function createIcon(status: string): Image.ImageLike {\n  switch (status) {\n    case \"started\":\n      return { source: Icon.Play, tintColor: Color.Green };\n    case \"running\":\n      return { source: Icon.PlayFilled, tintColor: Color.Green };\n    case \"error\":\n      return { source: Icon.ExclamationMark, tintColor: Color.Yellow };\n    case \"none\":\n      return { source: Icon.Stop, tintColor: Color.PrimaryText };\n    default:\n      return { source: Icon.QuestionMark, tintColor: Color.Red };\n  }\n}\n\nexport async function runShellScript(command: string) {\n  const { stdout } = await execaCommand(command);\n  return stdout;\n}\n", "export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n", "import {fileURLToPath} from 'node:url';\n\n// Allow some arguments/options to be either a file path string or a file URL\nexport const safeNormalizeFileUrl = (file, name) => {\n\tconst fileString = normalizeFileUrl(file);\n\n\tif (typeof fileString !== 'string') {\n\t\tthrow new TypeError(`${name} must be a string or a file URL: ${fileString}.`);\n\t}\n\n\treturn fileString;\n};\n\n// Same but also allows other values, e.g. `boolean` for the `shell` option\nexport const normalizeFileUrl = file => file instanceof URL ? fileURLToPath(file) : file;\n", "import isPlainObject from 'is-plain-obj';\nimport {safeNormalizeFileUrl} from '../arguments/file-url.js';\n\n// The command `arguments` and `options` are both optional.\n// This also does basic validation on them and on the command file.\nexport const normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {\n\tconst filePath = safeNormalizeFileUrl(rawFile, 'First argument');\n\tconst [commandArguments, options] = isPlainObject(rawArguments)\n\t\t? [[], rawArguments]\n\t\t: [rawArguments, rawOptions];\n\n\tif (!Array.isArray(commandArguments)) {\n\t\tthrow new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);\n\t}\n\n\tif (commandArguments.some(commandArgument => typeof commandArgument === 'object' && commandArgument !== null)) {\n\t\tthrow new TypeError(`Second argument must be an array of strings: ${commandArguments}`);\n\t}\n\n\tconst normalizedArguments = commandArguments.map(String);\n\tconst nullByteArgument = normalizedArguments.find(normalizedArgument => normalizedArgument.includes('\\0'));\n\tif (nullByteArgument !== undefined) {\n\t\tthrow new TypeError(`Arguments cannot contain null bytes (\"\\\\0\"): ${nullByteArgument}`);\n\t}\n\n\tif (!isPlainObject(options)) {\n\t\tthrow new TypeError(`Last argument must be an options object: ${options}`);\n\t}\n\n\treturn [filePath, normalizedArguments, options];\n};\n", "import {ChildProcess} from 'node:child_process';\nimport isPlainObject from 'is-plain-obj';\nimport {isUint8Array, uint8ArrayToString} from '../utils/uint-array.js';\n\n// Check whether the template string syntax is being used\nexport const isTemplateString = templates => Array.isArray(templates) && Array.isArray(templates.raw);\n\n// Convert execa`file ...commandArguments` to execa(file, commandArguments)\nexport const parseTemplates = (templates, expressions) => {\n\tlet tokens = [];\n\n\tfor (const [index, template] of templates.entries()) {\n\t\ttokens = parseTemplate({\n\t\t\ttemplates,\n\t\t\texpressions,\n\t\t\ttokens,\n\t\t\tindex,\n\t\t\ttemplate,\n\t\t});\n\t}\n\n\tif (tokens.length === 0) {\n\t\tthrow new TypeError('Template script must not be empty');\n\t}\n\n\tconst [file, ...commandArguments] = tokens;\n\treturn [file, commandArguments, {}];\n};\n\nconst parseTemplate = ({templates, expressions, tokens, index, template}) => {\n\tif (template === undefined) {\n\t\tthrow new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);\n\t}\n\n\tconst {nextTokens, leadingWhitespaces, trailingWhitespaces} = splitByWhitespaces(template, templates.raw[index]);\n\tconst newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);\n\n\tif (index === expressions.length) {\n\t\treturn newTokens;\n\t}\n\n\tconst expression = expressions[index];\n\tconst expressionTokens = Array.isArray(expression)\n\t\t? expression.map(expression => parseExpression(expression))\n\t\t: [parseExpression(expression)];\n\treturn concatTokens(newTokens, expressionTokens, trailingWhitespaces);\n};\n\n// Like `string.split(/[ \\t\\r\\n]+/)` except newlines and tabs are:\n//  - ignored when input as a backslash sequence like: `echo foo\\n bar`\n//  - not ignored when input directly\n// The only way to distinguish those in JavaScript is to use a tagged template and compare:\n//  - the first array argument, which does not escape backslash sequences\n//  - its `raw` property, which escapes them\nconst splitByWhitespaces = (template, rawTemplate) => {\n\tif (rawTemplate.length === 0) {\n\t\treturn {nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false};\n\t}\n\n\tconst nextTokens = [];\n\tlet templateStart = 0;\n\tconst leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);\n\n\tfor (\n\t\tlet templateIndex = 0, rawIndex = 0;\n\t\ttemplateIndex < template.length;\n\t\ttemplateIndex += 1, rawIndex += 1\n\t) {\n\t\tconst rawCharacter = rawTemplate[rawIndex];\n\t\tif (DELIMITERS.has(rawCharacter)) {\n\t\t\tif (templateStart !== templateIndex) {\n\t\t\t\tnextTokens.push(template.slice(templateStart, templateIndex));\n\t\t\t}\n\n\t\t\ttemplateStart = templateIndex + 1;\n\t\t} else if (rawCharacter === '\\\\') {\n\t\t\tconst nextRawCharacter = rawTemplate[rawIndex + 1];\n\t\t\tif (nextRawCharacter === 'u' && rawTemplate[rawIndex + 2] === '{') {\n\t\t\t\trawIndex = rawTemplate.indexOf('}', rawIndex + 3);\n\t\t\t} else {\n\t\t\t\trawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst trailingWhitespaces = templateStart === template.length;\n\tif (!trailingWhitespaces) {\n\t\tnextTokens.push(template.slice(templateStart));\n\t}\n\n\treturn {nextTokens, leadingWhitespaces, trailingWhitespaces};\n};\n\nconst DELIMITERS = new Set([' ', '\\t', '\\r', '\\n']);\n\n// Number of characters in backslash escape sequences: \\0 \\xXX or \\uXXXX\n// \\cX is allowed in RegExps but not in strings\n// Octal sequences are not allowed in strict mode\nconst ESCAPE_LENGTH = {x: 3, u: 5};\n\nconst concatTokens = (tokens, nextTokens, isSeparated) => isSeparated\n\t|| tokens.length === 0\n\t|| nextTokens.length === 0\n\t? [...tokens, ...nextTokens]\n\t: [\n\t\t...tokens.slice(0, -1),\n\t\t`${tokens.at(-1)}${nextTokens[0]}`,\n\t\t...nextTokens.slice(1),\n\t];\n\n// Handle `${expression}` inside the template string syntax\nconst parseExpression = expression => {\n\tconst typeOfExpression = typeof expression;\n\n\tif (typeOfExpression === 'string') {\n\t\treturn expression;\n\t}\n\n\tif (typeOfExpression === 'number') {\n\t\treturn String(expression);\n\t}\n\n\tif (isPlainObject(expression) && ('stdout' in expression || 'isMaxBuffer' in expression)) {\n\t\treturn getSubprocessResult(expression);\n\t}\n\n\tif (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === '[object Promise]') {\n\t\t// eslint-disable-next-line no-template-curly-in-string\n\t\tthrow new TypeError('Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.');\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeOfExpression}\" in template expression`);\n};\n\nconst getSubprocessResult = ({stdout}) => {\n\tif (typeof stdout === 'string') {\n\t\treturn stdout;\n\t}\n\n\tif (isUint8Array(stdout)) {\n\t\treturn uint8ArrayToString(stdout);\n\t}\n\n\tif (stdout === undefined) {\n\t\tthrow new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\\' \"stdout\" option.');\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeof stdout}\" stdout in template expression`);\n};\n", "import {StringDecoder} from 'node:string_decoder';\n\nconst {toString: objectToString} = Object.prototype;\n\nexport const isArrayBuffer = value => objectToString.call(value) === '[object ArrayBuffer]';\n\n// Is either Uint8Array or Buffer\nexport const isUint8Array = value => objectToString.call(value) === '[object Uint8Array]';\n\nexport const bufferToUint8Array = buffer => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\nconst textEncoder = new TextEncoder();\nconst stringToUint8Array = string => textEncoder.encode(string);\n\nconst textDecoder = new TextDecoder();\nexport const uint8ArrayToString = uint8Array => textDecoder.decode(uint8Array);\n\nexport const joinToString = (uint8ArraysOrStrings, encoding) => {\n\tconst strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);\n\treturn strings.join('');\n};\n\nconst uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {\n\tif (encoding === 'utf8' && uint8ArraysOrStrings.every(uint8ArrayOrString => typeof uint8ArrayOrString === 'string')) {\n\t\treturn uint8ArraysOrStrings;\n\t}\n\n\tconst decoder = new StringDecoder(encoding);\n\tconst strings = uint8ArraysOrStrings\n\t\t.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'\n\t\t\t? stringToUint8Array(uint8ArrayOrString)\n\t\t\t: uint8ArrayOrString)\n\t\t.map(uint8Array => decoder.write(uint8Array));\n\tconst finalString = decoder.end();\n\treturn finalString === '' ? strings : [...strings, finalString];\n};\n\nexport const joinToUint8Array = uint8ArraysOrStrings => {\n\tif (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {\n\t\treturn uint8ArraysOrStrings[0];\n\t}\n\n\treturn concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));\n};\n\nconst stringsToUint8Arrays = uint8ArraysOrStrings => uint8ArraysOrStrings.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'\n\t? stringToUint8Array(uint8ArrayOrString)\n\t: uint8ArrayOrString);\n\nexport const concatUint8Arrays = uint8Arrays => {\n\tconst result = new Uint8Array(getJoinLength(uint8Arrays));\n\n\tlet index = 0;\n\tfor (const uint8Array of uint8Arrays) {\n\t\tresult.set(uint8Array, index);\n\t\tindex += uint8Array.length;\n\t}\n\n\treturn result;\n};\n\nconst getJoinLength = uint8Arrays => {\n\tlet joinLength = 0;\n\tfor (const uint8Array of uint8Arrays) {\n\t\tjoinLength += uint8Array.length;\n\t}\n\n\treturn joinLength;\n};\n", "import {spawnSync} from 'node:child_process';\nimport {handleCommand} from '../arguments/command.js';\nimport {normalizeOptions} from '../arguments/options.js';\nimport {makeError, makeEarlyError, makeSuccessResult} from '../return/result.js';\nimport {handleResult} from '../return/reject.js';\nimport {handleStdioSync} from '../stdio/handle-sync.js';\nimport {stripNewline} from '../io/strip-newline.js';\nimport {addInputOptionsSync} from '../io/input-sync.js';\nimport {transformOutputSync} from '../io/output-sync.js';\nimport {getMaxBufferSync} from '../io/max-buffer.js';\nimport {getAllSync} from '../resolve/all-sync.js';\nimport {getExitResultSync} from '../resolve/exit-sync.js';\n\n// Main shared logic for all sync methods: `execaSync()`, `$.sync()`\nexport const execaCoreSync = (rawFile, rawArguments, rawOptions) => {\n\tconst {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleSyncArguments(rawFile, rawArguments, rawOptions);\n\tconst result = spawnSubprocessSync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t});\n\treturn handleResult(result, verboseInfo, options);\n};\n\n// Compute arguments to pass to `child_process.spawnSync()`\nconst handleSyncArguments = (rawFile, rawArguments, rawOptions) => {\n\tconst {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);\n\tconst syncOptions = normalizeSyncOptions(rawOptions);\n\tconst {file, commandArguments, options} = normalizeOptions(rawFile, rawArguments, syncOptions);\n\tvalidateSyncOptions(options);\n\tconst fileDescriptors = handleStdioSync(options, verboseInfo);\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\toptions,\n\t\tfileDescriptors,\n\t};\n};\n\n// Options normalization logic specific to sync methods\nconst normalizeSyncOptions = options => options.node && !options.ipc ? {...options, ipc: false} : options;\n\n// Options validation logic specific to sync methods\nconst validateSyncOptions = ({ipc, ipcInput, detached, cancelSignal}) => {\n\tif (ipcInput) {\n\t\tthrowInvalidSyncOption('ipcInput');\n\t}\n\n\tif (ipc) {\n\t\tthrowInvalidSyncOption('ipc: true');\n\t}\n\n\tif (detached) {\n\t\tthrowInvalidSyncOption('detached: true');\n\t}\n\n\tif (cancelSignal) {\n\t\tthrowInvalidSyncOption('cancelSignal');\n\t}\n};\n\nconst throwInvalidSyncOption = value => {\n\tthrow new TypeError(`The \"${value}\" option cannot be used with synchronous methods.`);\n};\n\nconst spawnSubprocessSync = ({file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime}) => {\n\tconst syncResult = runSubprocessSync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t});\n\tif (syncResult.failed) {\n\t\treturn syncResult;\n\t}\n\n\tconst {resultError, exitCode, signal, timedOut, isMaxBuffer} = getExitResultSync(syncResult, options);\n\tconst {output, error = resultError} = transformOutputSync({\n\t\tfileDescriptors,\n\t\tsyncResult,\n\t\toptions,\n\t\tisMaxBuffer,\n\t\tverboseInfo,\n\t});\n\tconst stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));\n\tconst all = stripNewline(getAllSync(output, options), options, 'all');\n\treturn getSyncResult({\n\t\terror,\n\t\texitCode,\n\t\tsignal,\n\t\ttimedOut,\n\t\tisMaxBuffer,\n\t\tstdio,\n\t\tall,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t});\n};\n\nconst runSubprocessSync = ({file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime}) => {\n\ttry {\n\t\taddInputOptionsSync(fileDescriptors, options);\n\t\tconst normalizedOptions = normalizeSpawnSyncOptions(options);\n\t\treturn spawnSync(file, commandArguments, normalizedOptions);\n\t} catch (error) {\n\t\treturn makeEarlyError({\n\t\t\terror,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tfileDescriptors,\n\t\t\toptions,\n\t\t\tstartTime,\n\t\t\tisSync: true,\n\t\t});\n\t}\n};\n\n// The `encoding` option is handled by Execa, not by `child_process.spawnSync()`\nconst normalizeSpawnSyncOptions = ({encoding, maxBuffer, ...options}) => ({...options, encoding: 'buffer', maxBuffer: getMaxBufferSync(maxBuffer)});\n\nconst getSyncResult = ({error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime}) => error === undefined\n\t? makeSuccessResult({\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput: [],\n\t\toptions,\n\t\tstartTime,\n\t})\n\t: makeError({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\ttimedOut,\n\t\tisCanceled: false,\n\t\tisGracefullyCanceled: false,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated: false,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput: [],\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: true,\n\t});\n", "import {debuglog} from 'node:util';\nimport isPlainObject from 'is-plain-obj';\nimport {STANDARD_STREAMS_ALIASES} from '../utils/standard-stream.js';\n\n// Some options can have different values for `stdout`/`stderr`/`fd3`.\n// This normalizes those to array of values.\n// For example, `{verbose: {stdout: 'none', stderr: 'full'}}` becomes `{verbose: ['none', 'none', 'full']}`\nexport const normalizeFdSpecificOptions = options => {\n\tconst optionsCopy = {...options};\n\n\tfor (const optionName of FD_SPECIFIC_OPTIONS) {\n\t\toptionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);\n\t}\n\n\treturn optionsCopy;\n};\n\nexport const normalizeFdSpecificOption = (options, optionName) => {\n\tconst optionBaseArray = Array.from({length: getStdioLength(options) + 1});\n\tconst optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);\n\treturn addDefaultValue(optionArray, optionName);\n};\n\nconst getStdioLength = ({stdio}) => Array.isArray(stdio)\n\t? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length)\n\t: STANDARD_STREAMS_ALIASES.length;\n\nconst normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue)\n\t? normalizeOptionObject(optionValue, optionArray, optionName)\n\t: optionArray.fill(optionValue);\n\nconst normalizeOptionObject = (optionValue, optionArray, optionName) => {\n\tfor (const fdName of Object.keys(optionValue).sort(compareFdName)) {\n\t\tfor (const fdNumber of parseFdName(fdName, optionName, optionArray)) {\n\t\t\toptionArray[fdNumber] = optionValue[fdName];\n\t\t}\n\t}\n\n\treturn optionArray;\n};\n\n// Ensure priority order when setting both `stdout`/`stderr`, `fd1`/`fd2`, and `all`\nconst compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;\n\nconst getFdNameOrder = fdName => {\n\tif (fdName === 'stdout' || fdName === 'stderr') {\n\t\treturn 0;\n\t}\n\n\treturn fdName === 'all' ? 2 : 1;\n};\n\nconst parseFdName = (fdName, optionName, optionArray) => {\n\tif (fdName === 'ipc') {\n\t\treturn [optionArray.length - 1];\n\t}\n\n\tconst fdNumber = parseFd(fdName);\n\tif (fdNumber === undefined || fdNumber === 0) {\n\t\tthrow new TypeError(`\"${optionName}.${fdName}\" is invalid.\nIt must be \"${optionName}.stdout\", \"${optionName}.stderr\", \"${optionName}.all\", \"${optionName}.ipc\", or \"${optionName}.fd3\", \"${optionName}.fd4\" (and so on).`);\n\t}\n\n\tif (fdNumber >= optionArray.length) {\n\t\tthrow new TypeError(`\"${optionName}.${fdName}\" is invalid: that file descriptor does not exist.\nPlease set the \"stdio\" option to ensure that file descriptor exists.`);\n\t}\n\n\treturn fdNumber === 'all' ? [1, 2] : [fdNumber];\n};\n\n// Use the same syntax for fd-specific options and the `from`/`to` options\nexport const parseFd = fdName => {\n\tif (fdName === 'all') {\n\t\treturn fdName;\n\t}\n\n\tif (STANDARD_STREAMS_ALIASES.includes(fdName)) {\n\t\treturn STANDARD_STREAMS_ALIASES.indexOf(fdName);\n\t}\n\n\tconst regexpResult = FD_REGEXP.exec(fdName);\n\tif (regexpResult !== null) {\n\t\treturn Number(regexpResult[1]);\n\t}\n};\n\nconst FD_REGEXP = /^fd(\\d+)$/;\n\nconst addDefaultValue = (optionArray, optionName) => optionArray.map(optionValue => optionValue === undefined\n\t? DEFAULT_OPTIONS[optionName]\n\t: optionValue);\n\n// Default value for the `verbose` option\nconst verboseDefault = debuglog('execa').enabled ? 'full' : 'none';\n\nconst DEFAULT_OPTIONS = {\n\tlines: false,\n\tbuffer: true,\n\tmaxBuffer: 1000 * 1000 * 100,\n\tverbose: verboseDefault,\n\tstripFinalNewline: true,\n};\n\n// List of options which can have different values for `stdout`/`stderr`\nexport const FD_SPECIFIC_OPTIONS = ['lines', 'buffer', 'maxBuffer', 'verbose', 'stripFinalNewline'];\n\n// Retrieve fd-specific option\nexport const getFdSpecificValue = (optionArray, fdNumber) => fdNumber === 'ipc'\n\t? optionArray.at(-1)\n\t: optionArray[fdNumber];\n", "import process from 'node:process';\n\nexport const isStandardStream = stream => STANDARD_STREAMS.includes(stream);\nexport const STANDARD_STREAMS = [process.stdin, process.stdout, process.stderr];\nexport const STANDARD_STREAMS_ALIASES = ['stdin', 'stdout', 'stderr'];\nexport const getStreamName = fdNumber => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;\n", "import {getFdSpecificValue} from '../arguments/specific.js';\n\n// The `verbose` option can have different values for `stdout`/`stderr`\nexport const isVerbose = ({verbose}, fdNumber) => getFdVerbose(verbose, fdNumber) !== 'none';\n\n// Whether IPC and output and logged\nexport const isFullVerbose = ({verbose}, fdNumber) => !['none', 'short'].includes(getFdVerbose(verbose, fdNumber));\n\n// The `verbose` option can be a function to customize logging\nexport const getVerboseFunction = ({verbose}, fdNumber) => {\n\tconst fdVerbose = getFdVerbose(verbose, fdNumber);\n\treturn isVerboseFunction(fdVerbose) ? fdVerbose : undefined;\n};\n\n// When using `verbose: {stdout, stderr, fd3, ipc}`:\n//  - `verbose.stdout|stderr|fd3` is used for 'output'\n//  - `verbose.ipc` is only used for 'ipc'\n//  - highest `verbose.*` value is used for 'command', 'error' and 'duration'\nconst getFdVerbose = (verbose, fdNumber) => fdNumber === undefined\n\t? getFdGenericVerbose(verbose)\n\t: getFdSpecificValue(verbose, fdNumber);\n\n// When using `verbose: {stdout, stderr, fd3, ipc}` and logging is not specific to a file descriptor.\n// We then use the highest `verbose.*` value, using the following order:\n//  - function > 'full' > 'short' > 'none'\n//  - if several functions are defined: stdout > stderr > fd3 > ipc\nconst getFdGenericVerbose = verbose => verbose.find(fdVerbose => isVerboseFunction(fdVerbose))\n\t?? VERBOSE_VALUES.findLast(fdVerbose => verbose.includes(fdVerbose));\n\n// Whether the `verbose` option is customized using a function\nexport const isVerboseFunction = fdVerbose => typeof fdVerbose === 'function';\n\nexport const VERBOSE_VALUES = ['none', 'short', 'full'];\n", "import {writeFileSync} from 'node:fs';\nimport {inspect} from 'node:util';\nimport {escapeLines} from '../arguments/escape.js';\nimport {defaultVerboseFunction} from './default.js';\nimport {applyVerboseOnLines} from './custom.js';\n\n// Write synchronously to ensure lines are properly ordered and not interleaved with `stdout`\nexport const verboseLog = ({type, verboseMessage, fdNumber, verboseInfo, result}) => {\n\tconst verboseObject = getVerboseObject({type, result, verboseInfo});\n\tconst printedLines = getPrintedLines(verboseMessage, verboseObject);\n\tconst finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);\n\twriteFileSync(STDERR_FD, finalLines);\n};\n\nconst getVerboseObject = ({\n\ttype,\n\tresult,\n\tverboseInfo: {escapedCommand, commandId, rawOptions: {piped = false, ...options}},\n}) => ({\n\ttype,\n\tescapedCommand,\n\tcommandId: `${commandId}`,\n\ttimestamp: new Date(),\n\tpiped,\n\tresult,\n\toptions,\n});\n\nconst getPrintedLines = (verboseMessage, verboseObject) => verboseMessage\n\t.split('\\n')\n\t.map(message => getPrintedLine({...verboseObject, message}));\n\nconst getPrintedLine = verboseObject => {\n\tconst verboseLine = defaultVerboseFunction(verboseObject);\n\treturn {verboseLine, verboseObject};\n};\n\n// Unless a `verbose` function is used, print all logs on `stderr`\nconst STDERR_FD = 2;\n\n// Serialize any type to a line string, for logging\nexport const serializeVerboseMessage = message => {\n\tconst messageString = typeof message === 'string' ? message : inspect(message);\n\tconst escapedMessage = escapeLines(messageString);\n\treturn escapedMessage.replaceAll('\\t', ' '.repeat(TAB_SIZE));\n};\n\n// Same as `util.inspect()`\nconst TAB_SIZE = 2;\n", "import {platform} from 'node:process';\nimport {stripVTControlCharacters} from 'node:util';\n\n// Compute `result.command` and `result.escapedCommand`\nexport const joinCommand = (filePath, rawArguments) => {\n\tconst fileAndArguments = [filePath, ...rawArguments];\n\tconst command = fileAndArguments.join(' ');\n\tconst escapedCommand = fileAndArguments\n\t\t.map(fileAndArgument => quoteString(escapeControlCharacters(fileAndArgument)))\n\t\t.join(' ');\n\treturn {command, escapedCommand};\n};\n\n// Remove ANSI sequences and escape control characters and newlines\nexport const escapeLines = lines => stripVTControlCharacters(lines)\n\t.split('\\n')\n\t.map(line => escapeControlCharacters(line))\n\t.join('\\n');\n\nconst escapeControlCharacters = line => line.replaceAll(SPECIAL_CHAR_REGEXP, character => escapeControlCharacter(character));\n\nconst escapeControlCharacter = character => {\n\tconst commonEscape = COMMON_ESCAPES[character];\n\tif (commonEscape !== undefined) {\n\t\treturn commonEscape;\n\t}\n\n\tconst codepoint = character.codePointAt(0);\n\tconst codepointHex = codepoint.toString(16);\n\treturn codepoint <= ASTRAL_START\n\t\t? `\\\\u${codepointHex.padStart(4, '0')}`\n\t\t: `\\\\U${codepointHex}`;\n};\n\n// Characters that would create issues when printed are escaped using the \\u or \\U notation.\n// Those include control characters and newlines.\n// The \\u and \\U notation is Bash specific, but there is no way to do this in a shell-agnostic way.\n// Some shells do not even have a way to print those characters in an escaped fashion.\n// Therefore, we prioritize printing those safely, instead of allowing those to be copy-pasted.\n// List of Unicode character categories: https://www.fileformat.info/info/unicode/category/index.htm\nconst getSpecialCharRegExp = () => {\n\ttry {\n\t\t// This throws when using Node.js without ICU support.\n\t\t// When using a RegExp literal, this would throw at parsing-time, instead of runtime.\n\t\t// eslint-disable-next-line prefer-regex-literals\n\t\treturn new RegExp('\\\\p{Separator}|\\\\p{Other}', 'gu');\n\t} catch {\n\t\t// Similar to the above RegExp, but works even when Node.js has been built without ICU support.\n\t\t// Unlike the above RegExp, it only covers whitespaces and C0/C1 control characters.\n\t\t// It does not cover some edge cases, such as Unicode reserved characters.\n\t\t// See https://github.com/sindresorhus/execa/issues/1143\n\t\t// eslint-disable-next-line no-control-regex\n\t\treturn /[\\s\\u0000-\\u001F\\u007F-\\u009F\\u00AD]/g;\n\t}\n};\n\nconst SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();\n\n// Accepted by $'...' in Bash.\n// Exclude \\a \\e \\v which are accepted in Bash but not in JavaScript (except \\v) and JSON.\nconst COMMON_ESCAPES = {\n\t' ': ' ',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t',\n};\n\n// Up until that codepoint, \\u notation can be used instead of \\U\nconst ASTRAL_START = 65_535;\n\n// Some characters are shell-specific, i.e. need to be escaped when the command is copy-pasted then run.\n// Escaping is shell-specific. We cannot know which shell is used: `process.platform` detection is not enough.\n// For example, Windows users could be using `cmd.exe`, Powershell or Bash for Windows which all use different escaping.\n// We use '...' on Unix, which is POSIX shell compliant and escape all characters but ' so this is fairly safe.\n// On Windows, we assume cmd.exe is used and escape with \"...\", which also works with Powershell.\nconst quoteString = escapedArgument => {\n\tif (NO_ESCAPE_REGEXP.test(escapedArgument)) {\n\t\treturn escapedArgument;\n\t}\n\n\treturn platform === 'win32'\n\t\t? `\"${escapedArgument.replaceAll('\"', '\"\"')}\"`\n\t\t: `'${escapedArgument.replaceAll('\\'', '\\'\\\\\\'\\'')}'`;\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w./-]+$/;\n", "import process from 'node:process';\n\nexport default function isUnicodeSupported() {\n\tconst {env} = process;\n\tconst {TERM, TERM_PROGRAM} = env;\n\n\tif (process.platform !== 'win32') {\n\t\treturn TERM !== 'linux'; // Linux console (kernel)\n\t}\n\n\treturn Boolean(env.WT_SESSION) // Windows Terminal\n\t\t|| Boolean(env.TERMINUS_SUBLIME) // Terminus (<0.2.27)\n\t\t|| env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder\n\t\t|| TERM_PROGRAM === 'Terminus-Sublime'\n\t\t|| TERM_PROGRAM === 'vscode'\n\t\t|| TERM === 'xterm-256color'\n\t\t|| TERM === 'alacritty'\n\t\t|| TERM === 'rxvt-unicode'\n\t\t|| TERM === 'rxvt-unicode-256color'\n\t\t|| env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';\n}\n", "import isUnicodeSupported from 'is-unicode-supported';\n\nconst common = {\n\tcircleQuestionMark: '(?)',\n\tquestionMarkPrefix: '(?)',\n\tsquare: '\u2588',\n\tsquareDarkShade: '\u2593',\n\tsquareMediumShade: '\u2592',\n\tsquareLightShade: '\u2591',\n\tsquareTop: '\u2580',\n\tsquareBottom: '\u2584',\n\tsquareLeft: '\u258C',\n\tsquareRight: '\u2590',\n\tsquareCenter: '\u25A0',\n\tbullet: '\u25CF',\n\tdot: '\u2024',\n\tellipsis: '\u2026',\n\tpointerSmall: '\u203A',\n\ttriangleUp: '\u25B2',\n\ttriangleUpSmall: '\u25B4',\n\ttriangleDown: '\u25BC',\n\ttriangleDownSmall: '\u25BE',\n\ttriangleLeftSmall: '\u25C2',\n\ttriangleRightSmall: '\u25B8',\n\thome: '\u2302',\n\theart: '\u2665',\n\tmusicNote: '\u266A',\n\tmusicNoteBeamed: '\u266B',\n\tarrowUp: '\u2191',\n\tarrowDown: '\u2193',\n\tarrowLeft: '\u2190',\n\tarrowRight: '\u2192',\n\tarrowLeftRight: '\u2194',\n\tarrowUpDown: '\u2195',\n\talmostEqual: '\u2248',\n\tnotEqual: '\u2260',\n\tlessOrEqual: '\u2264',\n\tgreaterOrEqual: '\u2265',\n\tidentical: '\u2261',\n\tinfinity: '\u221E',\n\tsubscriptZero: '\u2080',\n\tsubscriptOne: '\u2081',\n\tsubscriptTwo: '\u2082',\n\tsubscriptThree: '\u2083',\n\tsubscriptFour: '\u2084',\n\tsubscriptFive: '\u2085',\n\tsubscriptSix: '\u2086',\n\tsubscriptSeven: '\u2087',\n\tsubscriptEight: '\u2088',\n\tsubscriptNine: '\u2089',\n\toneHalf: '\u00BD',\n\toneThird: '\u2153',\n\toneQuarter: '\u00BC',\n\toneFifth: '\u2155',\n\toneSixth: '\u2159',\n\toneEighth: '\u215B',\n\ttwoThirds: '\u2154',\n\ttwoFifths: '\u2156',\n\tthreeQuarters: '\u00BE',\n\tthreeFifths: '\u2157',\n\tthreeEighths: '\u215C',\n\tfourFifths: '\u2158',\n\tfiveSixths: '\u215A',\n\tfiveEighths: '\u215D',\n\tsevenEighths: '\u215E',\n\tline: '\u2500',\n\tlineBold: '\u2501',\n\tlineDouble: '\u2550',\n\tlineDashed0: '\u2504',\n\tlineDashed1: '\u2505',\n\tlineDashed2: '\u2508',\n\tlineDashed3: '\u2509',\n\tlineDashed4: '\u254C',\n\tlineDashed5: '\u254D',\n\tlineDashed6: '\u2574',\n\tlineDashed7: '\u2576',\n\tlineDashed8: '\u2578',\n\tlineDashed9: '\u257A',\n\tlineDashed10: '\u257C',\n\tlineDashed11: '\u257E',\n\tlineDashed12: '\u2212',\n\tlineDashed13: '\u2013',\n\tlineDashed14: '\u2010',\n\tlineDashed15: '\u2043',\n\tlineVertical: '\u2502',\n\tlineVerticalBold: '\u2503',\n\tlineVerticalDouble: '\u2551',\n\tlineVerticalDashed0: '\u2506',\n\tlineVerticalDashed1: '\u2507',\n\tlineVerticalDashed2: '\u250A',\n\tlineVerticalDashed3: '\u250B',\n\tlineVerticalDashed4: '\u254E',\n\tlineVerticalDashed5: '\u254F',\n\tlineVerticalDashed6: '\u2575',\n\tlineVerticalDashed7: '\u2577',\n\tlineVerticalDashed8: '\u2579',\n\tlineVerticalDashed9: '\u257B',\n\tlineVerticalDashed10: '\u257D',\n\tlineVerticalDashed11: '\u257F',\n\tlineDownLeft: '\u2510',\n\tlineDownLeftArc: '\u256E',\n\tlineDownBoldLeftBold: '\u2513',\n\tlineDownBoldLeft: '\u2512',\n\tlineDownLeftBold: '\u2511',\n\tlineDownDoubleLeftDouble: '\u2557',\n\tlineDownDoubleLeft: '\u2556',\n\tlineDownLeftDouble: '\u2555',\n\tlineDownRight: '\u250C',\n\tlineDownRightArc: '\u256D',\n\tlineDownBoldRightBold: '\u250F',\n\tlineDownBoldRight: '\u250E',\n\tlineDownRightBold: '\u250D',\n\tlineDownDoubleRightDouble: '\u2554',\n\tlineDownDoubleRight: '\u2553',\n\tlineDownRightDouble: '\u2552',\n\tlineUpLeft: '\u2518',\n\tlineUpLeftArc: '\u256F',\n\tlineUpBoldLeftBold: '\u251B',\n\tlineUpBoldLeft: '\u251A',\n\tlineUpLeftBold: '\u2519',\n\tlineUpDoubleLeftDouble: '\u255D',\n\tlineUpDoubleLeft: '\u255C',\n\tlineUpLeftDouble: '\u255B',\n\tlineUpRight: '\u2514',\n\tlineUpRightArc: '\u2570',\n\tlineUpBoldRightBold: '\u2517',\n\tlineUpBoldRight: '\u2516',\n\tlineUpRightBold: '\u2515',\n\tlineUpDoubleRightDouble: '\u255A',\n\tlineUpDoubleRight: '\u2559',\n\tlineUpRightDouble: '\u2558',\n\tlineUpDownLeft: '\u2524',\n\tlineUpBoldDownBoldLeftBold: '\u252B',\n\tlineUpBoldDownBoldLeft: '\u2528',\n\tlineUpDownLeftBold: '\u2525',\n\tlineUpBoldDownLeftBold: '\u2529',\n\tlineUpDownBoldLeftBold: '\u252A',\n\tlineUpDownBoldLeft: '\u2527',\n\tlineUpBoldDownLeft: '\u2526',\n\tlineUpDoubleDownDoubleLeftDouble: '\u2563',\n\tlineUpDoubleDownDoubleLeft: '\u2562',\n\tlineUpDownLeftDouble: '\u2561',\n\tlineUpDownRight: '\u251C',\n\tlineUpBoldDownBoldRightBold: '\u2523',\n\tlineUpBoldDownBoldRight: '\u2520',\n\tlineUpDownRightBold: '\u251D',\n\tlineUpBoldDownRightBold: '\u2521',\n\tlineUpDownBoldRightBold: '\u2522',\n\tlineUpDownBoldRight: '\u251F',\n\tlineUpBoldDownRight: '\u251E',\n\tlineUpDoubleDownDoubleRightDouble: '\u2560',\n\tlineUpDoubleDownDoubleRight: '\u255F',\n\tlineUpDownRightDouble: '\u255E',\n\tlineDownLeftRight: '\u252C',\n\tlineDownBoldLeftBoldRightBold: '\u2533',\n\tlineDownLeftBoldRightBold: '\u252F',\n\tlineDownBoldLeftRight: '\u2530',\n\tlineDownBoldLeftBoldRight: '\u2531',\n\tlineDownBoldLeftRightBold: '\u2532',\n\tlineDownLeftRightBold: '\u252E',\n\tlineDownLeftBoldRight: '\u252D',\n\tlineDownDoubleLeftDoubleRightDouble: '\u2566',\n\tlineDownDoubleLeftRight: '\u2565',\n\tlineDownLeftDoubleRightDouble: '\u2564',\n\tlineUpLeftRight: '\u2534',\n\tlineUpBoldLeftBoldRightBold: '\u253B',\n\tlineUpLeftBoldRightBold: '\u2537',\n\tlineUpBoldLeftRight: '\u2538',\n\tlineUpBoldLeftBoldRight: '\u2539',\n\tlineUpBoldLeftRightBold: '\u253A',\n\tlineUpLeftRightBold: '\u2536',\n\tlineUpLeftBoldRight: '\u2535',\n\tlineUpDoubleLeftDoubleRightDouble: '\u2569',\n\tlineUpDoubleLeftRight: '\u2568',\n\tlineUpLeftDoubleRightDouble: '\u2567',\n\tlineUpDownLeftRight: '\u253C',\n\tlineUpBoldDownBoldLeftBoldRightBold: '\u254B',\n\tlineUpDownBoldLeftBoldRightBold: '\u2548',\n\tlineUpBoldDownLeftBoldRightBold: '\u2547',\n\tlineUpBoldDownBoldLeftRightBold: '\u254A',\n\tlineUpBoldDownBoldLeftBoldRight: '\u2549',\n\tlineUpBoldDownLeftRight: '\u2540',\n\tlineUpDownBoldLeftRight: '\u2541',\n\tlineUpDownLeftBoldRight: '\u253D',\n\tlineUpDownLeftRightBold: '\u253E',\n\tlineUpBoldDownBoldLeftRight: '\u2542',\n\tlineUpDownLeftBoldRightBold: '\u253F',\n\tlineUpBoldDownLeftBoldRight: '\u2543',\n\tlineUpBoldDownLeftRightBold: '\u2544',\n\tlineUpDownBoldLeftBoldRight: '\u2545',\n\tlineUpDownBoldLeftRightBold: '\u2546',\n\tlineUpDoubleDownDoubleLeftDoubleRightDouble: '\u256C',\n\tlineUpDoubleDownDoubleLeftRight: '\u256B',\n\tlineUpDownLeftDoubleRightDouble: '\u256A',\n\tlineCross: '\u2573',\n\tlineBackslash: '\u2572',\n\tlineSlash: '\u2571',\n};\n\nconst specialMainSymbols = {\n\ttick: '\u2714',\n\tinfo: '\u2139',\n\twarning: '\u26A0',\n\tcross: '\u2718',\n\tsquareSmall: '\u25FB',\n\tsquareSmallFilled: '\u25FC',\n\tcircle: '\u25EF',\n\tcircleFilled: '\u25C9',\n\tcircleDotted: '\u25CC',\n\tcircleDouble: '\u25CE',\n\tcircleCircle: '\u24DE',\n\tcircleCross: '\u24E7',\n\tcirclePipe: '\u24BE',\n\tradioOn: '\u25C9',\n\tradioOff: '\u25EF',\n\tcheckboxOn: '\u2612',\n\tcheckboxOff: '\u2610',\n\tcheckboxCircleOn: '\u24E7',\n\tcheckboxCircleOff: '\u24BE',\n\tpointer: '\u276F',\n\ttriangleUpOutline: '\u25B3',\n\ttriangleLeft: '\u25C0',\n\ttriangleRight: '\u25B6',\n\tlozenge: '\u25C6',\n\tlozengeOutline: '\u25C7',\n\thamburger: '\u2630',\n\tsmiley: '\u32E1',\n\tmustache: '\u0DF4',\n\tstar: '\u2605',\n\tplay: '\u25B6',\n\tnodejs: '\u2B22',\n\toneSeventh: '\u2150',\n\toneNinth: '\u2151',\n\toneTenth: '\u2152',\n};\n\nconst specialFallbackSymbols = {\n\ttick: '\u221A',\n\tinfo: 'i',\n\twarning: '\u203C',\n\tcross: '\u00D7',\n\tsquareSmall: '\u25A1',\n\tsquareSmallFilled: '\u25A0',\n\tcircle: '( )',\n\tcircleFilled: '(*)',\n\tcircleDotted: '( )',\n\tcircleDouble: '( )',\n\tcircleCircle: '(\u25CB)',\n\tcircleCross: '(\u00D7)',\n\tcirclePipe: '(\u2502)',\n\tradioOn: '(*)',\n\tradioOff: '( )',\n\tcheckboxOn: '[\u00D7]',\n\tcheckboxOff: '[ ]',\n\tcheckboxCircleOn: '(\u00D7)',\n\tcheckboxCircleOff: '( )',\n\tpointer: '>',\n\ttriangleUpOutline: '\u2206',\n\ttriangleLeft: '\u25C4',\n\ttriangleRight: '\u25BA',\n\tlozenge: '\u2666',\n\tlozengeOutline: '\u25CA',\n\thamburger: '\u2261',\n\tsmiley: '\u263A',\n\tmustache: '\u250C\u2500\u2510',\n\tstar: '\u2736',\n\tplay: '\u25BA',\n\tnodejs: '\u2666',\n\toneSeventh: '1/7',\n\toneNinth: '1/9',\n\toneTenth: '1/10',\n};\n\nexport const mainSymbols = {...common, ...specialMainSymbols};\nexport const fallbackSymbols = {...common, ...specialFallbackSymbols};\n\nconst shouldUseMain = isUnicodeSupported();\nconst figures = shouldUseMain ? mainSymbols : fallbackSymbols;\nexport default figures;\n\nconst replacements = Object.entries(specialMainSymbols);\n\n// On terminals which do not support Unicode symbols, substitute them to other symbols\nexport const replaceSymbols = (string, {useFallback = !shouldUseMain} = {}) => {\n\tif (useFallback) {\n\t\tfor (const [key, mainSymbol] of replacements) {\n\t\t\tstring = string.replaceAll(mainSymbol, fallbackSymbols[key]);\n\t\t}\n\t}\n\n\treturn string;\n};\n", "import tty from 'node:tty';\n\n// eslint-disable-next-line no-warning-comments\n// TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)\n// Lots of optionals here to support Deno.\nconst hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;\n\nconst format = (open, close) => {\n\tif (!hasColors) {\n\t\treturn input => input;\n\t}\n\n\tconst openCode = `\\u001B[${open}m`;\n\tconst closeCode = `\\u001B[${close}m`;\n\n\treturn input => {\n\t\tconst string = input + ''; // eslint-disable-line no-implicit-coercion -- This is faster.\n\t\tlet index = string.indexOf(closeCode);\n\n\t\tif (index === -1) {\n\t\t\t// Note: Intentionally not using string interpolation for performance reasons.\n\t\t\treturn openCode + string + closeCode;\n\t\t}\n\n\t\t// Handle nested colors.\n\n\t\t// We could have done this, but it's too slow (as of Node.js 22).\n\t\t// return openCode + string.replaceAll(closeCode, openCode) + closeCode;\n\n\t\tlet result = openCode;\n\t\tlet lastIndex = 0;\n\n\t\twhile (index !== -1) {\n\t\t\tresult += string.slice(lastIndex, index) + openCode;\n\t\t\tlastIndex = index + closeCode.length;\n\t\t\tindex = string.indexOf(closeCode, lastIndex);\n\t\t}\n\n\t\tresult += string.slice(lastIndex) + closeCode;\n\n\t\treturn result;\n\t};\n};\n\nexport const reset = format(0, 0);\nexport const bold = format(1, 22);\nexport const dim = format(2, 22);\nexport const italic = format(3, 23);\nexport const underline = format(4, 24);\nexport const overline = format(53, 55);\nexport const inverse = format(7, 27);\nexport const hidden = format(8, 28);\nexport const strikethrough = format(9, 29);\n\nexport const black = format(30, 39);\nexport const red = format(31, 39);\nexport const green = format(32, 39);\nexport const yellow = format(33, 39);\nexport const blue = format(34, 39);\nexport const magenta = format(35, 39);\nexport const cyan = format(36, 39);\nexport const white = format(37, 39);\nexport const gray = format(90, 39);\n\nexport const bgBlack = format(40, 49);\nexport const bgRed = format(41, 49);\nexport const bgGreen = format(42, 49);\nexport const bgYellow = format(43, 49);\nexport const bgBlue = format(44, 49);\nexport const bgMagenta = format(45, 49);\nexport const bgCyan = format(46, 49);\nexport const bgWhite = format(47, 49);\nexport const bgGray = format(100, 49);\n\nexport const redBright = format(91, 39);\nexport const greenBright = format(92, 39);\nexport const yellowBright = format(93, 39);\nexport const blueBright = format(94, 39);\nexport const magentaBright = format(95, 39);\nexport const cyanBright = format(96, 39);\nexport const whiteBright = format(97, 39);\n\nexport const bgRedBright = format(101, 49);\nexport const bgGreenBright = format(102, 49);\nexport const bgYellowBright = format(103, 49);\nexport const bgBlueBright = format(104, 49);\nexport const bgMagentaBright = format(105, 49);\nexport const bgCyanBright = format(106, 49);\nexport const bgWhiteBright = format(107, 49);\n", "import figures from 'figures';\nimport {\n\tgray,\n\tbold,\n\tredBright,\n\tyellowBright,\n} from 'yoctocolors';\n\n// Default when `verbose` is not a function\nexport const defaultVerboseFunction = ({\n\ttype,\n\tmessage,\n\ttimestamp,\n\tpiped,\n\tcommandId,\n\tresult: {failed = false} = {},\n\toptions: {reject = true},\n}) => {\n\tconst timestampString = serializeTimestamp(timestamp);\n\tconst icon = ICONS[type]({failed, reject, piped});\n\tconst color = COLORS[type]({reject});\n\treturn `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;\n};\n\n// Prepending the timestamp allows debugging the slow paths of a subprocess\nconst serializeTimestamp = timestamp => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;\n\nconst padField = (field, padding) => String(field).padStart(padding, '0');\n\nconst getFinalIcon = ({failed, reject}) => {\n\tif (!failed) {\n\t\treturn figures.tick;\n\t}\n\n\treturn reject ? figures.cross : figures.warning;\n};\n\nconst ICONS = {\n\tcommand: ({piped}) => piped ? '|' : '$',\n\toutput: () => ' ',\n\tipc: () => '*',\n\terror: getFinalIcon,\n\tduration: getFinalIcon,\n};\n\nconst identity = string => string;\n\nconst COLORS = {\n\tcommand: () => bold,\n\toutput: () => identity,\n\tipc: () => identity,\n\terror: ({reject}) => reject ? redBright : yellowBright,\n\tduration: () => gray,\n};\n", "import {getVerboseFunction} from './values.js';\n\n// Apply the `verbose` function on each line\nexport const applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {\n\tconst verboseFunction = getVerboseFunction(verboseInfo, fdNumber);\n\treturn printedLines\n\t\t.map(({verboseLine, verboseObject}) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction))\n\t\t.filter(printedLine => printedLine !== undefined)\n\t\t.map(printedLine => appendNewline(printedLine))\n\t\t.join('');\n};\n\nconst applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {\n\tif (verboseFunction === undefined) {\n\t\treturn verboseLine;\n\t}\n\n\tconst printedLine = verboseFunction(verboseLine, verboseObject);\n\tif (typeof printedLine === 'string') {\n\t\treturn printedLine;\n\t}\n};\n\nconst appendNewline = printedLine => printedLine.endsWith('\\n')\n\t? printedLine\n\t: `${printedLine}\\n`;\n", "import {isVerbose} from './values.js';\nimport {verboseLog} from './log.js';\n\n// When `verbose` is `short|full|custom`, print each command\nexport const logCommand = (escapedCommand, verboseInfo) => {\n\tif (!isVerbose(verboseInfo)) {\n\t\treturn;\n\t}\n\n\tverboseLog({\n\t\ttype: 'command',\n\t\tverboseMessage: escapedCommand,\n\t\tverboseInfo,\n\t});\n};\n", "import {isVerbose, VERBOSE_VALUES, isVerboseFunction} from './values.js';\n\n// Information computed before spawning, used by the `verbose` option\nexport const getVerboseInfo = (verbose, escapedCommand, rawOptions) => {\n\tvalidateVerbose(verbose);\n\tconst commandId = getCommandId(verbose);\n\treturn {\n\t\tverbose,\n\t\tescapedCommand,\n\t\tcommandId,\n\t\trawOptions,\n\t};\n};\n\nconst getCommandId = verbose => isVerbose({verbose}) ? COMMAND_ID++ : undefined;\n\n// Prepending the `pid` is useful when multiple commands print their output at the same time.\n// However, we cannot use the real PID since this is not available with `child_process.spawnSync()`.\n// Also, we cannot use the real PID if we want to print it before `child_process.spawn()` is run.\n// As a pro, it is shorter than a normal PID and never re-uses the same id.\n// As a con, it cannot be used to send signals.\nlet COMMAND_ID = 0n;\n\nconst validateVerbose = verbose => {\n\tfor (const fdVerbose of verbose) {\n\t\tif (fdVerbose === false) {\n\t\t\tthrow new TypeError('The \"verbose: false\" option was renamed to \"verbose: \\'none\\'\".');\n\t\t}\n\n\t\tif (fdVerbose === true) {\n\t\t\tthrow new TypeError('The \"verbose: true\" option was renamed to \"verbose: \\'short\\'\".');\n\t\t}\n\n\t\tif (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {\n\t\t\tconst allowedValues = VERBOSE_VALUES.map(allowedValue => `'${allowedValue}'`).join(', ');\n\t\t\tthrow new TypeError(`The \"verbose\" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);\n\t\t}\n\t}\n};\n", "import {hrtime} from 'node:process';\n\n// Start counting time before spawning the subprocess\nexport const getStartTime = () => hrtime.bigint();\n\n// Compute duration after the subprocess ended.\n// Printed by the `verbose` option.\nexport const getDurationMs = startTime => Number(hrtime.bigint() - startTime) / 1e6;\n", "import {logCommand} from '../verbose/start.js';\nimport {getVerboseInfo} from '../verbose/info.js';\nimport {getStartTime} from '../return/duration.js';\nimport {joinCommand} from './escape.js';\nimport {normalizeFdSpecificOption} from './specific.js';\n\n// Compute `result.command`, `result.escapedCommand` and `verbose`-related information\nexport const handleCommand = (filePath, rawArguments, rawOptions) => {\n\tconst startTime = getStartTime();\n\tconst {command, escapedCommand} = joinCommand(filePath, rawArguments);\n\tconst verbose = normalizeFdSpecificOption(rawOptions, 'verbose');\n\tconst verboseInfo = getVerboseInfo(verbose, escapedCommand, {...rawOptions});\n\tlogCommand(escapedCommand, verboseInfo);\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t};\n};\n", "import path from 'node:path';\nimport process from 'node:process';\nimport crossSpawn from 'cross-spawn';\nimport {npmRunPathEnv} from 'npm-run-path';\nimport {normalizeForceKillAfterDelay} from '../terminate/kill.js';\nimport {normalizeKillSignal} from '../terminate/signal.js';\nimport {validateCancelSignal} from '../terminate/cancel.js';\nimport {validateGracefulCancel} from '../terminate/graceful.js';\nimport {validateTimeout} from '../terminate/timeout.js';\nimport {handleNodeOption} from '../methods/node.js';\nimport {validateIpcInputOption} from '../ipc/ipc-input.js';\nimport {validateEncoding, BINARY_ENCODINGS} from './encoding-option.js';\nimport {normalizeCwd} from './cwd.js';\nimport {normalizeFileUrl} from './file-url.js';\nimport {normalizeFdSpecificOptions} from './specific.js';\n\n// Normalize the options object, and sometimes also the file paths and arguments.\n// Applies default values, validate allowed options, normalize them.\nexport const normalizeOptions = (filePath, rawArguments, rawOptions) => {\n\trawOptions.cwd = normalizeCwd(rawOptions.cwd);\n\tconst [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);\n\n\tconst {command: file, args: commandArguments, options: initialOptions} = crossSpawn._parse(processedFile, processedArguments, processedOptions);\n\n\tconst fdOptions = normalizeFdSpecificOptions(initialOptions);\n\tconst options = addDefaultOptions(fdOptions);\n\tvalidateTimeout(options);\n\tvalidateEncoding(options);\n\tvalidateIpcInputOption(options);\n\tvalidateCancelSignal(options);\n\tvalidateGracefulCancel(options);\n\toptions.shell = normalizeFileUrl(options.shell);\n\toptions.env = getEnv(options);\n\toptions.killSignal = normalizeKillSignal(options.killSignal);\n\toptions.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);\n\toptions.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\tcommandArguments.unshift('/q');\n\t}\n\n\treturn {file, commandArguments, options};\n};\n\nconst addDefaultOptions = ({\n\textendEnv = true,\n\tpreferLocal = false,\n\tcwd,\n\tlocalDir: localDirectory = cwd,\n\tencoding = 'utf8',\n\treject = true,\n\tcleanup = true,\n\tall = false,\n\twindowsHide = true,\n\tkillSignal = 'SIGTERM',\n\tforceKillAfterDelay = true,\n\tgracefulCancel = false,\n\tipcInput,\n\tipc = ipcInput !== undefined || gracefulCancel,\n\tserialization = 'advanced',\n\t...options\n}) => ({\n\t...options,\n\textendEnv,\n\tpreferLocal,\n\tcwd,\n\tlocalDirectory,\n\tencoding,\n\treject,\n\tcleanup,\n\tall,\n\twindowsHide,\n\tkillSignal,\n\tforceKillAfterDelay,\n\tgracefulCancel,\n\tipcInput,\n\tipc,\n\tserialization,\n});\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal || node) {\n\t\treturn npmRunPathEnv({\n\t\t\tenv,\n\t\t\tcwd: localDirectory,\n\t\t\texecPath: nodePath,\n\t\t\tpreferLocal,\n\t\t\taddExecPath: node,\n\t\t});\n\t}\n\n\treturn env;\n};\n", "import process from 'node:process';\nimport path from 'node:path';\nimport pathKey from 'path-key';\nimport {toPath, traversePathUp} from 'unicorn-magic';\n\nexport const npmRunPath = ({\n\tcwd = process.cwd(),\n\tpath: pathOption = process.env[pathKey()],\n\tpreferLocal = true,\n\texecPath = process.execPath,\n\taddExecPath = true,\n} = {}) => {\n\tconst cwdPath = path.resolve(toPath(cwd));\n\tconst result = [];\n\tconst pathParts = pathOption.split(path.delimiter);\n\n\tif (preferLocal) {\n\t\tapplyPreferLocal(result, pathParts, cwdPath);\n\t}\n\n\tif (addExecPath) {\n\t\tapplyExecPath(result, pathParts, execPath, cwdPath);\n\t}\n\n\treturn pathOption === '' || pathOption === path.delimiter\n\t\t? `${result.join(path.delimiter)}${pathOption}`\n\t\t: [...result, pathOption].join(path.delimiter);\n};\n\nconst applyPreferLocal = (result, pathParts, cwdPath) => {\n\tfor (const directory of traversePathUp(cwdPath)) {\n\t\tconst pathPart = path.join(directory, 'node_modules/.bin');\n\t\tif (!pathParts.includes(pathPart)) {\n\t\t\tresult.push(pathPart);\n\t\t}\n\t}\n};\n\n// Ensure the running `node` binary is used\nconst applyExecPath = (result, pathParts, execPath, cwdPath) => {\n\tconst pathPart = path.resolve(cwdPath, toPath(execPath), '..');\n\tif (!pathParts.includes(pathPart)) {\n\t\tresult.push(pathPart);\n\t}\n};\n\nexport const npmRunPathEnv = ({env = process.env, ...options} = {}) => {\n\tenv = {...env};\n\n\tconst pathName = pathKey({env});\n\toptions.path = env[pathName];\n\tenv[pathName] = npmRunPath(options);\n\n\treturn env;\n};\n", "export default function pathKey(options = {}) {\n\tconst {\n\t\tenv = process.env,\n\t\tplatform = process.platform\n\t} = options;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(env).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n}\n", "import {promisify} from 'node:util';\nimport {execFile as execFileCallback, execFileSync as execFileSyncOriginal} from 'node:child_process';\nimport path from 'node:path';\nimport {fileURLToPath} from 'node:url';\n\nconst execFileOriginal = promisify(execFileCallback);\n\nexport function toPath(urlOrPath) {\n\treturn urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;\n}\n\nexport function rootDirectory(pathInput) {\n\treturn path.parse(toPath(pathInput)).root;\n}\n\nexport function traversePathUp(startPath) {\n\treturn {\n\t\t* [Symbol.iterator]() {\n\t\t\tlet currentPath = path.resolve(toPath(startPath));\n\t\t\tlet previousPath;\n\n\t\t\twhile (previousPath !== currentPath) {\n\t\t\t\tyield currentPath;\n\t\t\t\tpreviousPath = currentPath;\n\t\t\t\tcurrentPath = path.resolve(currentPath, '..');\n\t\t\t}\n\t\t},\n\t};\n}\n\nconst TEN_MEGABYTES_IN_BYTES = 10 * 1024 * 1024;\n\nexport async function execFile(file, arguments_, options = {}) {\n\treturn execFileOriginal(file, arguments_, {\n\t\tmaxBuffer: TEN_MEGABYTES_IN_BYTES,\n\t\t...options,\n\t});\n}\n\nexport function execFileSync(file, arguments_ = [], options = {}) {\n\treturn execFileSyncOriginal(file, arguments_, {\n\t\tmaxBuffer: TEN_MEGABYTES_IN_BYTES,\n\t\tencoding: 'utf8',\n\t\tstdio: 'pipe',\n\t\t...options,\n\t});\n}\n\nexport * from './default.js';\n", "import {setTimeout} from 'node:timers/promises';\nimport {isErrorInstance} from '../return/final-error.js';\nimport {normalizeSignalArgument} from './signal.js';\n\n// Normalize the `forceKillAfterDelay` option\nexport const normalizeForceKillAfterDelay = forceKillAfterDelay => {\n\tif (forceKillAfterDelay === false) {\n\t\treturn forceKillAfterDelay;\n\t}\n\n\tif (forceKillAfterDelay === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterDelay\\` option to be a non-negative integer, got \\`${forceKillAfterDelay}\\` (${typeof forceKillAfterDelay})`);\n\t}\n\n\treturn forceKillAfterDelay;\n};\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `subprocess.kill()` to add `forceKillAfterDelay` behavior and `.kill(error)`\nexport const subprocessKill = (\n\t{kill, options: {forceKillAfterDelay, killSignal}, onInternalError, context, controller},\n\tsignalOrError,\n\terrorArgument,\n) => {\n\tconst {signal, error} = parseKillArguments(signalOrError, errorArgument, killSignal);\n\temitKillError(error, onInternalError);\n\tconst killResult = kill(signal);\n\tsetKillTimeout({\n\t\tkill,\n\t\tsignal,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tkillResult,\n\t\tcontext,\n\t\tcontroller,\n\t});\n\treturn killResult;\n};\n\nconst parseKillArguments = (signalOrError, errorArgument, killSignal) => {\n\tconst [signal = killSignal, error] = isErrorInstance(signalOrError)\n\t\t? [undefined, signalOrError]\n\t\t: [signalOrError, errorArgument];\n\n\tif (typeof signal !== 'string' && !Number.isInteger(signal)) {\n\t\tthrow new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);\n\t}\n\n\tif (error !== undefined && !isErrorInstance(error)) {\n\t\tthrow new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);\n\t}\n\n\treturn {signal: normalizeSignalArgument(signal), error};\n};\n\n// Fails right away when calling `subprocess.kill(error)`.\n// Does not wait for actual signal termination.\n// Uses a deferred promise instead of the `error` event on the subprocess, as this is less intrusive.\nconst emitKillError = (error, onInternalError) => {\n\tif (error !== undefined) {\n\t\tonInternalError.reject(error);\n\t}\n};\n\nconst setKillTimeout = async ({kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller}) => {\n\tif (signal === killSignal && killResult) {\n\t\tkillOnTimeout({\n\t\t\tkill,\n\t\t\tforceKillAfterDelay,\n\t\t\tcontext,\n\t\t\tcontrollerSignal: controller.signal,\n\t\t});\n\t}\n};\n\n// Forcefully terminate a subprocess after a timeout\nexport const killOnTimeout = async ({kill, forceKillAfterDelay, context, controllerSignal}) => {\n\tif (forceKillAfterDelay === false) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait setTimeout(forceKillAfterDelay, undefined, {signal: controllerSignal});\n\t\tif (kill('SIGKILL')) {\n\t\t\tcontext.isForcefullyTerminated ??= true;\n\t\t}\n\t} catch {}\n};\n", "// When the subprocess fails, this is the error instance being returned.\n// If another error instance is being thrown, it is kept as `error.cause`.\nexport const getFinalError = (originalError, message, isSync) => {\n\tconst ErrorClass = isSync ? ExecaSyncError : ExecaError;\n\tconst options = originalError instanceof DiscardedError ? {} : {cause: originalError};\n\treturn new ErrorClass(message, options);\n};\n\n// Indicates that the error is used only to interrupt control flow, but not in the return value\nexport class DiscardedError extends Error {}\n\n// Proper way to set `error.name`: it should be inherited and non-enumerable\nconst setErrorName = (ErrorClass, value) => {\n\tObject.defineProperty(ErrorClass.prototype, 'name', {\n\t\tvalue,\n\t\twritable: true,\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t});\n\tObject.defineProperty(ErrorClass.prototype, execaErrorSymbol, {\n\t\tvalue: true,\n\t\twritable: false,\n\t\tenumerable: false,\n\t\tconfigurable: false,\n\t});\n};\n\n// Unlike `instanceof`, this works across realms\nexport const isExecaError = error => isErrorInstance(error) && execaErrorSymbol in error;\n\nconst execaErrorSymbol = Symbol('isExecaError');\n\nexport const isErrorInstance = value => Object.prototype.toString.call(value) === '[object Error]';\n\n// We use two different Error classes for async/sync methods since they have slightly different shape and types\nexport class ExecaError extends Error {}\nsetErrorName(ExecaError, ExecaError.name);\n\nexport class ExecaSyncError extends Error {}\nsetErrorName(ExecaSyncError, ExecaSyncError.name);\n", "import {constants} from 'node:os';\nimport {signalsByName} from 'human-signals';\n\n// Normalize signals for comparison purpose.\n// Also validate the signal exists.\nexport const normalizeKillSignal = killSignal => {\n\tconst optionName = 'option `killSignal`';\n\tif (killSignal === 0) {\n\t\tthrow new TypeError(`Invalid ${optionName}: 0 cannot be used.`);\n\t}\n\n\treturn normalizeSignal(killSignal, optionName);\n};\n\nexport const normalizeSignalArgument = signal => signal === 0\n\t? signal\n\t: normalizeSignal(signal, '`subprocess.kill()`\\'s argument');\n\nconst normalizeSignal = (signalNameOrInteger, optionName) => {\n\tif (Number.isInteger(signalNameOrInteger)) {\n\t\treturn normalizeSignalInteger(signalNameOrInteger, optionName);\n\t}\n\n\tif (typeof signalNameOrInteger === 'string') {\n\t\treturn normalizeSignalName(signalNameOrInteger, optionName);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\\n${getAvailableSignals()}`);\n};\n\nconst normalizeSignalInteger = (signalInteger, optionName) => {\n\tif (signalsIntegerToName.has(signalInteger)) {\n\t\treturn signalsIntegerToName.get(signalInteger);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\\n${getAvailableSignals()}`);\n};\n\nconst getSignalsIntegerToName = () => new Map(Object.entries(constants.signals)\n\t.reverse()\n\t.map(([signalName, signalInteger]) => [signalInteger, signalName]));\n\nconst signalsIntegerToName = getSignalsIntegerToName();\n\nconst normalizeSignalName = (signalName, optionName) => {\n\tif (signalName in constants.signals) {\n\t\treturn signalName;\n\t}\n\n\tif (signalName.toUpperCase() in constants.signals) {\n\t\tthrow new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\\n${getAvailableSignals()}`);\n};\n\nconst getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.\nAvailable signal numbers: ${getAvailableSignalIntegers()}.`;\n\nconst getAvailableSignalNames = () => Object.keys(constants.signals)\n\t.sort()\n\t.map(signalName => `'${signalName}'`)\n\t.join(', ');\n\nconst getAvailableSignalIntegers = () => [...new Set(Object.values(constants.signals)\n\t.sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))]\n\t.join(', ');\n\n// Human-friendly description of a signal\nexport const getSignalDescription = signal => signalsByName[signal].description;\n", "import{constants}from\"node:os\";\n\nimport{SIGRTMAX}from\"./realtime.js\";\nimport{getSignals}from\"./signals.js\";\n\n\n\nconst getSignalsByName=()=>{\nconst signals=getSignals();\nreturn Object.fromEntries(signals.map(getSignalByName))\n};\n\nconst getSignalByName=({\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard\n})=>[name,{name,number,description,supported,action,forced,standard}];\n\nexport const signalsByName=getSignalsByName();\n\n\n\n\nconst getSignalsByNumber=()=>{\nconst signals=getSignals();\nconst length=SIGRTMAX+1;\nconst signalsA=Array.from({length},(value,number)=>\ngetSignalByNumber(number,signals)\n);\nreturn Object.assign({},...signalsA)\n};\n\nconst getSignalByNumber=(number,signals)=>{\nconst signal=findSignalByNumber(number,signals);\n\nif(signal===undefined){\nreturn{}\n}\n\nconst{name,description,supported,action,forced,standard}=signal;\nreturn{\n[number]:{\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard\n}\n}\n};\n\n\n\nconst findSignalByNumber=(number,signals)=>{\nconst signal=signals.find(({name})=>constants.signals[name]===number);\n\nif(signal!==undefined){\nreturn signal\n}\n\nreturn signals.find((signalA)=>signalA.number===number)\n};\n\nexport const signalsByNumber=getSignalsByNumber();", "\nexport const getRealtimeSignals=()=>{\nconst length=SIGRTMAX-SIGRTMIN+1;\nreturn Array.from({length},getRealtimeSignal)\n};\n\nconst getRealtimeSignal=(value,index)=>({\nname:`SIGRT${index+1}`,\nnumber:SIGRTMIN+index,\naction:\"terminate\",\ndescription:\"Application-specific signal (realtime)\",\nstandard:\"posix\"\n});\n\nconst SIGRTMIN=34;\nexport const SIGRTMAX=64;", "import{constants}from\"node:os\";\n\nimport{SIGNALS}from\"./core.js\";\nimport{getRealtimeSignals}from\"./realtime.js\";\n\n\n\nexport const getSignals=()=>{\nconst realtimeSignals=getRealtimeSignals();\nconst signals=[...SIGNALS,...realtimeSignals].map(normalizeSignal);\nreturn signals\n};\n\n\n\n\n\n\n\nconst normalizeSignal=({\nname,\nnumber:defaultNumber,\ndescription,\naction,\nforced=false,\nstandard\n})=>{\nconst{\nsignals:{[name]:constantSignal}\n}=constants;\nconst supported=constantSignal!==undefined;\nconst number=supported?constantSignal:defaultNumber;\nreturn{name,number,description,supported,action,forced,standard}\n};", "\n\nexport const SIGNALS=[\n{\nname:\"SIGHUP\",\nnumber:1,\naction:\"terminate\",\ndescription:\"Terminal closed\",\nstandard:\"posix\"\n},\n{\nname:\"SIGINT\",\nnumber:2,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-C\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGQUIT\",\nnumber:3,\naction:\"core\",\ndescription:\"User interruption with CTRL-\\\\\",\nstandard:\"posix\"\n},\n{\nname:\"SIGILL\",\nnumber:4,\naction:\"core\",\ndescription:\"Invalid machine instruction\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGTRAP\",\nnumber:5,\naction:\"core\",\ndescription:\"Debugger breakpoint\",\nstandard:\"posix\"\n},\n{\nname:\"SIGABRT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGIOT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGBUS\",\nnumber:7,\naction:\"core\",\ndescription:\n\"Bus error due to misaligned, non-existing address or paging error\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGEMT\",\nnumber:7,\naction:\"terminate\",\ndescription:\"Command should be emulated but is not implemented\",\nstandard:\"other\"\n},\n{\nname:\"SIGFPE\",\nnumber:8,\naction:\"core\",\ndescription:\"Floating point arithmetic error\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGKILL\",\nnumber:9,\naction:\"terminate\",\ndescription:\"Forced termination\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGUSR1\",\nnumber:10,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"\n},\n{\nname:\"SIGSEGV\",\nnumber:11,\naction:\"core\",\ndescription:\"Segmentation fault\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGUSR2\",\nnumber:12,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"\n},\n{\nname:\"SIGPIPE\",\nnumber:13,\naction:\"terminate\",\ndescription:\"Broken pipe or socket\",\nstandard:\"posix\"\n},\n{\nname:\"SIGALRM\",\nnumber:14,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"posix\"\n},\n{\nname:\"SIGTERM\",\nnumber:15,\naction:\"terminate\",\ndescription:\"Termination\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGSTKFLT\",\nnumber:16,\naction:\"terminate\",\ndescription:\"Stack is empty or overflowed\",\nstandard:\"other\"\n},\n{\nname:\"SIGCHLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"posix\"\n},\n{\nname:\"SIGCLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"other\"\n},\n{\nname:\"SIGCONT\",\nnumber:18,\naction:\"unpause\",\ndescription:\"Unpaused\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGSTOP\",\nnumber:19,\naction:\"pause\",\ndescription:\"Paused\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGTSTP\",\nnumber:20,\naction:\"pause\",\ndescription:\"Paused using CTRL-Z or \\\"suspend\\\"\",\nstandard:\"posix\"\n},\n{\nname:\"SIGTTIN\",\nnumber:21,\naction:\"pause\",\ndescription:\"Background process cannot read terminal input\",\nstandard:\"posix\"\n},\n{\nname:\"SIGBREAK\",\nnumber:21,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-BREAK\",\nstandard:\"other\"\n},\n{\nname:\"SIGTTOU\",\nnumber:22,\naction:\"pause\",\ndescription:\"Background process cannot write to terminal output\",\nstandard:\"posix\"\n},\n{\nname:\"SIGURG\",\nnumber:23,\naction:\"ignore\",\ndescription:\"Socket received out-of-band data\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGXCPU\",\nnumber:24,\naction:\"core\",\ndescription:\"Process timed out\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGXFSZ\",\nnumber:25,\naction:\"core\",\ndescription:\"File too big\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGVTALRM\",\nnumber:26,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGPROF\",\nnumber:27,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGWINCH\",\nnumber:28,\naction:\"ignore\",\ndescription:\"Terminal window size changed\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGIO\",\nnumber:29,\naction:\"terminate\",\ndescription:\"I/O is available\",\nstandard:\"other\"\n},\n{\nname:\"SIGPOLL\",\nnumber:29,\naction:\"terminate\",\ndescription:\"Watched event\",\nstandard:\"other\"\n},\n{\nname:\"SIGINFO\",\nnumber:29,\naction:\"ignore\",\ndescription:\"Request for process information\",\nstandard:\"other\"\n},\n{\nname:\"SIGPWR\",\nnumber:30,\naction:\"terminate\",\ndescription:\"Device running out of power\",\nstandard:\"systemv\"\n},\n{\nname:\"SIGSYS\",\nnumber:31,\naction:\"core\",\ndescription:\"Invalid system call\",\nstandard:\"other\"\n},\n{\nname:\"SIGUNUSED\",\nnumber:31,\naction:\"terminate\",\ndescription:\"Invalid system call\",\nstandard:\"other\"\n}];", "import {once} from 'node:events';\n\n// Combines `util.aborted()` and `events.addAbortListener()`: promise-based and cleaned up with a stop signal\nexport const onAbortedSignal = async (mainSignal, stopSignal) => {\n\tif (!mainSignal.aborted) {\n\t\tawait once(mainSignal, 'abort', {signal: stopSignal});\n\t}\n};\n", "import {onAbortedSignal} from '../utils/abort-signal.js';\n\n// Validate the `cancelSignal` option\nexport const validateCancelSignal = ({cancelSignal}) => {\n\tif (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== '[object AbortSignal]') {\n\t\tthrow new Error(`The \\`cancelSignal\\` option must be an AbortSignal: ${String(cancelSignal)}`);\n\t}\n};\n\n// Terminate the subprocess when aborting the `cancelSignal` option and `gracefulSignal` is `false`\nexport const throwOnCancel = ({subprocess, cancelSignal, gracefulCancel, context, controller}) => cancelSignal === undefined || gracefulCancel\n\t? []\n\t: [terminateOnCancel(subprocess, cancelSignal, context, controller)];\n\nconst terminateOnCancel = async (subprocess, cancelSignal, context, {signal}) => {\n\tawait onAbortedSignal(cancelSignal, signal);\n\tcontext.terminationReason ??= 'cancel';\n\tsubprocess.kill();\n\tthrow cancelSignal.reason;\n};\n", "import {scheduler} from 'node:timers/promises';\nimport {sendOneMessage} from './send.js';\nimport {getIpcEmitter} from './forward.js';\nimport {validateConnection, getAbortDisconnectError, throwOnMissingParent} from './validation.js';\n\n// Send an IPC message so the subprocess performs a graceful termination\nexport const sendAbort = (subprocess, message) => {\n\tconst methodName = 'cancelSignal';\n\tvalidateConnection(methodName, false, subprocess.connected);\n\treturn sendOneMessage({\n\t\tanyProcess: subprocess,\n\t\tmethodName,\n\t\tisSubprocess: false,\n\t\twrappedMessage: {type: GRACEFUL_CANCEL_TYPE, message},\n\t\tmessage,\n\t});\n};\n\n// When the signal is being used, start listening for incoming messages.\n// Unbuffering messages takes one microtask to complete, so this must be async.\nexport const getCancelSignal = async ({anyProcess, channel, isSubprocess, ipc}) => {\n\tawait startIpc({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipc,\n\t});\n\treturn cancelController.signal;\n};\n\nconst startIpc = async ({anyProcess, channel, isSubprocess, ipc}) => {\n\tif (cancelListening) {\n\t\treturn;\n\t}\n\n\tcancelListening = true;\n\n\tif (!ipc) {\n\t\tthrowOnMissingParent();\n\t\treturn;\n\t}\n\n\tif (channel === null) {\n\t\tabortOnDisconnect();\n\t\treturn;\n\t}\n\n\tgetIpcEmitter(anyProcess, channel, isSubprocess);\n\tawait scheduler.yield();\n};\n\nlet cancelListening = false;\n\n// Reception of IPC message to perform a graceful termination\nexport const handleAbort = wrappedMessage => {\n\tif (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {\n\t\treturn false;\n\t}\n\n\tcancelController.abort(wrappedMessage.message);\n\treturn true;\n};\n\nconst GRACEFUL_CANCEL_TYPE = 'execa:ipc:cancel';\n\n// When the current process disconnects early, the subprocess `cancelSignal` is aborted.\n// Otherwise, the signal would never be able to be aborted later on.\nexport const abortOnDisconnect = () => {\n\tcancelController.abort(getAbortDisconnectError());\n};\n\nconst cancelController = new AbortController();\n", "import {promisify} from 'node:util';\nimport {\n\tvalidateIpcMethod,\n\thandleEpipeError,\n\thandleSerializationError,\n\tdisconnect,\n} from './validation.js';\nimport {startSendMessage, endSendMessage} from './outgoing.js';\nimport {handleSendStrict, waitForStrictResponse} from './strict.js';\n\n// Like `[sub]process.send()` but promise-based.\n// We do not `await subprocess` during `.sendMessage()` nor `.getOneMessage()` since those methods are transient.\n// Users would still need to `await subprocess` after the method is done.\n// Also, this would prevent `unhandledRejection` event from being emitted, making it silent.\nexport const sendMessage = ({anyProcess, channel, isSubprocess, ipc}, message, {strict = false} = {}) => {\n\tconst methodName = 'sendMessage';\n\tvalidateIpcMethod({\n\t\tmethodName,\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: anyProcess.connected,\n\t});\n\n\treturn sendMessageAsync({\n\t\tanyProcess,\n\t\tchannel,\n\t\tmethodName,\n\t\tisSubprocess,\n\t\tmessage,\n\t\tstrict,\n\t});\n};\n\nconst sendMessageAsync = async ({anyProcess, channel, methodName, isSubprocess, message, strict}) => {\n\tconst wrappedMessage = handleSendStrict({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tmessage,\n\t\tstrict,\n\t});\n\tconst outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);\n\ttry {\n\t\tawait sendOneMessage({\n\t\t\tanyProcess,\n\t\t\tmethodName,\n\t\t\tisSubprocess,\n\t\t\twrappedMessage,\n\t\t\tmessage,\n\t\t});\n\t} catch (error) {\n\t\tdisconnect(anyProcess);\n\t\tthrow error;\n\t} finally {\n\t\tendSendMessage(outgoingMessagesState);\n\t}\n};\n\n// Used internally by `cancelSignal`\nexport const sendOneMessage = async ({anyProcess, methodName, isSubprocess, wrappedMessage, message}) => {\n\tconst sendMethod = getSendMethod(anyProcess);\n\n\ttry {\n\t\tawait Promise.all([\n\t\t\twaitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),\n\t\t\tsendMethod(wrappedMessage),\n\t\t]);\n\t} catch (error) {\n\t\thandleEpipeError({error, methodName, isSubprocess});\n\t\thandleSerializationError({\n\t\t\terror,\n\t\t\tmethodName,\n\t\t\tisSubprocess,\n\t\t\tmessage,\n\t\t});\n\t\tthrow error;\n\t}\n};\n\n// [sub]process.send() promisified, memoized\nconst getSendMethod = anyProcess => {\n\tif (PROCESS_SEND_METHODS.has(anyProcess)) {\n\t\treturn PROCESS_SEND_METHODS.get(anyProcess);\n\t}\n\n\tconst sendMethod = promisify(anyProcess.send.bind(anyProcess));\n\tPROCESS_SEND_METHODS.set(anyProcess, sendMethod);\n\treturn sendMethod;\n};\n\nconst PROCESS_SEND_METHODS = new WeakMap();\n", "// Validate the IPC channel is connected before receiving/sending messages\nexport const validateIpcMethod = ({methodName, isSubprocess, ipc, isConnected}) => {\n\tvalidateIpcOption(methodName, isSubprocess, ipc);\n\tvalidateConnection(methodName, isSubprocess, isConnected);\n};\n\n// Better error message when forgetting to set `ipc: true` and using the IPC methods\nconst validateIpcOption = (methodName, isSubprocess, ipc) => {\n\tif (!ipc) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \\`ipc\\` option is \\`true\\`.`);\n\t}\n};\n\n// Better error message when one process does not send/receive messages once the other process has disconnected.\n// This also makes it clear that any buffered messages are lost once either process has disconnected.\n// Also when aborting `cancelSignal` after disconnecting the IPC.\nexport const validateConnection = (methodName, isSubprocess, isConnected) => {\n\tif (!isConnected) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);\n\t}\n};\n\n// When `getOneMessage()` could not complete due to an early disconnection\nexport const throwOnEarlyDisconnect = isSubprocess => {\n\tthrow new Error(`${getMethodName('getOneMessage', isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);\n};\n\n// When both processes use `sendMessage()` with `strict` at the same time\nexport const throwOnStrictDeadlockError = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.\nThis can be fixed by both sending a message and listening to incoming messages at the same time:\n\nconst [receivedMessage] = await Promise.all([\n\t${getMethodName('getOneMessage', isSubprocess)},\n\t${getMethodName('sendMessage', isSubprocess, 'message, {strict: true}')},\n]);`);\n};\n\n// When the other process used `strict` but the current process had I/O error calling `sendMessage()` for the response\nexport const getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName('sendMessage', isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, {cause: error});\n\n// When using `strict` but the other process was not listening for messages\nexport const throwOnMissingStrict = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);\n};\n\n// When using `strict` but the other process disconnected before receiving the message\nexport const throwOnStrictDisconnect = isSubprocess => {\n\tthrow new Error(`${getMethodName('sendMessage', isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);\n};\n\n// When the current process disconnects while the subprocess is listening to `cancelSignal`\nexport const getAbortDisconnectError = () => new Error(`\\`cancelSignal\\` aborted: the ${getOtherProcessName(true)} disconnected.`);\n\n// When the subprocess uses `cancelSignal` but not the current process\nexport const throwOnMissingParent = () => {\n\tthrow new Error('`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.');\n};\n\n// EPIPE can happen when sending a message to a subprocess that is closing but has not disconnected yet\nexport const handleEpipeError = ({error, methodName, isSubprocess}) => {\n\tif (error.code === 'EPIPE') {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, {cause: error});\n\t}\n};\n\n// Better error message when sending messages which cannot be serialized.\n// Works with both `serialization: 'advanced'` and `serialization: 'json'`.\nexport const handleSerializationError = ({error, methodName, isSubprocess, message}) => {\n\tif (isSerializationError(error)) {\n\t\tthrow new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, {cause: error});\n\t}\n};\n\nconst isSerializationError = ({code, message}) => SERIALIZATION_ERROR_CODES.has(code)\n\t|| SERIALIZATION_ERROR_MESSAGES.some(serializationErrorMessage => message.includes(serializationErrorMessage));\n\n// `error.code` set by Node.js when it failed to serialize the message\nconst SERIALIZATION_ERROR_CODES = new Set([\n\t// Message is `undefined`\n\t'ERR_MISSING_ARGS',\n\t// Message is a function, a bigint, a symbol\n\t'ERR_INVALID_ARG_TYPE',\n]);\n\n// `error.message` set by Node.js when it failed to serialize the message\nconst SERIALIZATION_ERROR_MESSAGES = [\n\t// Message is a promise or a proxy, with `serialization: 'advanced'`\n\t'could not be cloned',\n\t// Message has cycles, with `serialization: 'json'`\n\t'circular structure',\n\t// Message has cycles inside toJSON(), with `serialization: 'json'`\n\t'call stack size exceeded',\n];\n\nconst getMethodName = (methodName, isSubprocess, parameters = '') => methodName === 'cancelSignal'\n\t? '`cancelSignal`\\'s `controller.abort()`'\n\t: `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;\n\nconst getNamespaceName = isSubprocess => isSubprocess ? '' : 'subprocess.';\n\nconst getOtherProcessName = isSubprocess => isSubprocess ? 'parent process' : 'subprocess';\n\n// When any error arises, we disconnect the IPC.\n// Otherwise, it is likely that one of the processes will stop sending/receiving messages.\n// This would leave the other process hanging.\nexport const disconnect = anyProcess => {\n\tif (anyProcess.connected) {\n\t\tanyProcess.disconnect();\n\t}\n};\n", "export const createDeferred = () => {\n\tconst methods = {};\n\tconst promise = new Promise((resolve, reject) => {\n\t\tObject.assign(methods, {resolve, reject});\n\t});\n\treturn Object.assign(promise, methods);\n};\n", "import {parseFd} from './specific.js';\n\n// Retrieve stream targeted by the `to` option\nexport const getToStream = (destination, to = 'stdin') => {\n\tconst isWritable = true;\n\tconst {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(destination);\n\tconst fdNumber = getFdNumber(fileDescriptors, to, isWritable);\n\tconst destinationStream = destination.stdio[fdNumber];\n\n\tif (destinationStream === null) {\n\t\tthrow new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));\n\t}\n\n\treturn destinationStream;\n};\n\n// Retrieve stream targeted by the `from` option\nexport const getFromStream = (source, from = 'stdout') => {\n\tconst isWritable = false;\n\tconst {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);\n\tconst fdNumber = getFdNumber(fileDescriptors, from, isWritable);\n\tconst sourceStream = fdNumber === 'all' ? source.all : source.stdio[fdNumber];\n\n\tif (sourceStream === null || sourceStream === undefined) {\n\t\tthrow new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));\n\t}\n\n\treturn sourceStream;\n};\n\n// Keeps track of the options passed to each Execa call\nexport const SUBPROCESS_OPTIONS = new WeakMap();\n\nconst getFdNumber = (fileDescriptors, fdName, isWritable) => {\n\tconst fdNumber = parseFdNumber(fdName, isWritable);\n\tvalidateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);\n\treturn fdNumber;\n};\n\nconst parseFdNumber = (fdName, isWritable) => {\n\tconst fdNumber = parseFd(fdName);\n\tif (fdNumber !== undefined) {\n\t\treturn fdNumber;\n\t}\n\n\tconst {validOptions, defaultValue} = isWritable\n\t\t? {validOptions: '\"stdin\"', defaultValue: 'stdin'}\n\t\t: {validOptions: '\"stdout\", \"stderr\", \"all\"', defaultValue: 'stdout'};\n\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be \"${fdName}\".\nIt must be ${validOptions} or \"fd3\", \"fd4\" (and so on).\nIt is optional and defaults to \"${defaultValue}\".`);\n};\n\nconst validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {\n\tconst fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];\n\tif (fileDescriptor === undefined) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. That file descriptor does not exist.\nPlease set the \"stdio\" option to ensure that file descriptor exists.`);\n\t}\n\n\tif (fileDescriptor.direction === 'input' && !isWritable) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. It must be a readable stream, not writable.`);\n\t}\n\n\tif (fileDescriptor.direction !== 'input' && isWritable) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. It must be a writable stream, not readable.`);\n\t}\n};\n\nconst getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {\n\tif (fdNumber === 'all' && !options.all) {\n\t\treturn 'The \"all\" option must be true to use \"from: \\'all\\'\".';\n\t}\n\n\tconst {optionName, optionValue} = getInvalidStdioOption(fdNumber, options);\n\treturn `The \"${optionName}: ${serializeOptionValue(optionValue)}\" option is incompatible with using \"${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}\".\nPlease set this option with \"pipe\" instead.`;\n};\n\nconst getInvalidStdioOption = (fdNumber, {stdin, stdout, stderr, stdio}) => {\n\tconst usedDescriptor = getUsedDescriptor(fdNumber);\n\n\tif (usedDescriptor === 0 && stdin !== undefined) {\n\t\treturn {optionName: 'stdin', optionValue: stdin};\n\t}\n\n\tif (usedDescriptor === 1 && stdout !== undefined) {\n\t\treturn {optionName: 'stdout', optionValue: stdout};\n\t}\n\n\tif (usedDescriptor === 2 && stderr !== undefined) {\n\t\treturn {optionName: 'stderr', optionValue: stderr};\n\t}\n\n\treturn {optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor]};\n};\n\nconst getUsedDescriptor = fdNumber => fdNumber === 'all' ? 1 : fdNumber;\n\nconst getOptionName = isWritable => isWritable ? 'to' : 'from';\n\nexport const serializeOptionValue = value => {\n\tif (typeof value === 'string') {\n\t\treturn `'${value}'`;\n\t}\n\n\treturn typeof value === 'number' ? `${value}` : 'Stream';\n};\n", "import {once} from 'node:events';\nimport {createDeferred} from '../utils/deferred.js';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {sendMessage} from './send.js';\nimport {throwOnMissingStrict, throwOnStrictDisconnect, throwOnStrictDeadlockError} from './validation.js';\nimport {getIpcEmitter} from './forward.js';\nimport {hasMessageListeners} from './outgoing.js';\n\n// When using the `strict` option, wrap the message with metadata during `sendMessage()`\nexport const handleSendStrict = ({anyProcess, channel, isSubprocess, message, strict}) => {\n\tif (!strict) {\n\t\treturn message;\n\t}\n\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst hasListeners = hasMessageListeners(anyProcess, ipcEmitter);\n\treturn {\n\t\tid: count++,\n\t\ttype: REQUEST_TYPE,\n\t\tmessage,\n\t\thasListeners,\n\t};\n};\n\nlet count = 0n;\n\n// Handles when both processes are calling `sendMessage()` with `strict` at the same time.\n// If neither process is listening, this would create a deadlock. We detect it and throw.\nexport const validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {\n\t\treturn;\n\t}\n\n\tfor (const {id} of outgoingMessages) {\n\t\tif (id !== undefined) {\n\t\t\tSTRICT_RESPONSES[id].resolve({isDeadlock: true, hasListeners: false});\n\t\t}\n\t}\n};\n\n// The other process then sends the acknowledgment back as a response\nexport const handleStrictRequest = async ({wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter}) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {\n\t\treturn wrappedMessage;\n\t}\n\n\tconst {id, message} = wrappedMessage;\n\tconst response = {id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter)};\n\n\ttry {\n\t\tawait sendMessage({\n\t\t\tanyProcess,\n\t\t\tchannel,\n\t\t\tisSubprocess,\n\t\t\tipc: true,\n\t\t}, response);\n\t} catch (error) {\n\t\tipcEmitter.emit('strict:error', error);\n\t}\n\n\treturn message;\n};\n\n// Reception of the acknowledgment response\nexport const handleStrictResponse = wrappedMessage => {\n\tif (wrappedMessage?.type !== RESPONSE_TYPE) {\n\t\treturn false;\n\t}\n\n\tconst {id, message: hasListeners} = wrappedMessage;\n\tSTRICT_RESPONSES[id]?.resolve({isDeadlock: false, hasListeners});\n\treturn true;\n};\n\n// Wait for the other process to receive the message from `sendMessage()`\nexport const waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {\n\tif (wrappedMessage?.type !== REQUEST_TYPE) {\n\t\treturn;\n\t}\n\n\tconst deferred = createDeferred();\n\tSTRICT_RESPONSES[wrappedMessage.id] = deferred;\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tconst {isDeadlock, hasListeners} = await Promise.race([\n\t\t\tdeferred,\n\t\t\tthrowOnDisconnect(anyProcess, isSubprocess, controller),\n\t\t]);\n\n\t\tif (isDeadlock) {\n\t\t\tthrowOnStrictDeadlockError(isSubprocess);\n\t\t}\n\n\t\tif (!hasListeners) {\n\t\t\tthrowOnMissingStrict(isSubprocess);\n\t\t}\n\t} finally {\n\t\tcontroller.abort();\n\t\tdelete STRICT_RESPONSES[wrappedMessage.id];\n\t}\n};\n\nconst STRICT_RESPONSES = {};\n\nconst throwOnDisconnect = async (anyProcess, isSubprocess, {signal}) => {\n\tincrementMaxListeners(anyProcess, 1, signal);\n\tawait once(anyProcess, 'disconnect', {signal});\n\tthrowOnStrictDisconnect(isSubprocess);\n};\n\nconst REQUEST_TYPE = 'execa:ipc:request';\nconst RESPONSE_TYPE = 'execa:ipc:response';\n", "import {addAbortListener} from 'node:events';\n\n// Temporarily increase the maximum number of listeners on an eventEmitter\nexport const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {\n\tconst maxListeners = eventEmitter.getMaxListeners();\n\tif (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {\n\t\treturn;\n\t}\n\n\teventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);\n\taddAbortListener(signal, () => {\n\t\teventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);\n\t});\n};\n", "import {EventEmitter} from 'node:events';\nimport {onMessage, onDisconnect} from './incoming.js';\nimport {undoAddedReferences} from './reference.js';\n\n// Forward the `message` and `disconnect` events from the process and subprocess to a proxy emitter.\n// This prevents the `error` event from stopping IPC.\n// This also allows debouncing the `message` event.\nexport const getIpcEmitter = (anyProcess, channel, isSubprocess) => {\n\tif (IPC_EMITTERS.has(anyProcess)) {\n\t\treturn IPC_EMITTERS.get(anyProcess);\n\t}\n\n\t// Use an `EventEmitter`, like the `process` that is being proxied\n\t// eslint-disable-next-line unicorn/prefer-event-target\n\tconst ipcEmitter = new EventEmitter();\n\tipcEmitter.connected = true;\n\tIPC_EMITTERS.set(anyProcess, ipcEmitter);\n\tforwardEvents({\n\t\tipcEmitter,\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t});\n\treturn ipcEmitter;\n};\n\nconst IPC_EMITTERS = new WeakMap();\n\n// The `message` and `disconnect` events are buffered in the subprocess until the first listener is setup.\n// However, unbuffering happens after one tick, so this give enough time for the caller to setup the listener on the proxy emitter first.\n// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L721\nconst forwardEvents = ({ipcEmitter, anyProcess, channel, isSubprocess}) => {\n\tconst boundOnMessage = onMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipcEmitter,\n\t});\n\tanyProcess.on('message', boundOnMessage);\n\tanyProcess.once('disconnect', onDisconnect.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tipcEmitter,\n\t\tboundOnMessage,\n\t}));\n\tundoAddedReferences(channel, isSubprocess);\n};\n\n// Check whether there might still be some `message` events to receive\nexport const isConnected = anyProcess => {\n\tconst ipcEmitter = IPC_EMITTERS.get(anyProcess);\n\treturn ipcEmitter === undefined\n\t\t? anyProcess.channel !== null\n\t\t: ipcEmitter.connected;\n};\n", "import {once} from 'node:events';\nimport {scheduler} from 'node:timers/promises';\nimport {waitForOutgoingMessages} from './outgoing.js';\nimport {redoAddedReferences} from './reference.js';\nimport {handleStrictRequest, handleStrictResponse} from './strict.js';\nimport {handleAbort, abortOnDisconnect} from './graceful.js';\n\n// By default, Node.js buffers `message` events.\n//  - Buffering happens when there is a `message` event is emitted but there is no handler.\n//  - As soon as a `message` event handler is set, all buffered `message` events are emitted, emptying the buffer.\n//  - This happens both in the current process and the subprocess.\n//  - See https://github.com/nodejs/node/blob/501546e8f37059cd577041e23941b640d0d4d406/lib/internal/child_process.js#L719\n// This is helpful. Notably, this allows sending messages to a subprocess that's still initializing.\n// However, it has several problems.\n//  - This works with `events.on()` but not `events.once()` since all buffered messages are emitted at once.\n//    For example, users cannot call `await getOneMessage()`/`getEachMessage()` multiple times in a row.\n//  - When a user intentionally starts listening to `message` at a specific point in time, past `message` events are replayed, which might be unexpected.\n//  - Buffering is unlimited, which might lead to an out-of-memory crash.\n//  - This does not work well with multiple consumers.\n//    For example, Execa consumes events with both `result.ipcOutput` and manual IPC calls like `getOneMessage()`.\n//    Since `result.ipcOutput` reads all incoming messages, no buffering happens for manual IPC calls.\n//  - Forgetting to setup a `message` listener, or setting it up too late, is a programming mistake.\n//    The default behavior does not allow users to realize they made that mistake.\n// To solve those problems, instead of buffering messages, we debounce them.\n// The `message` event so it is emitted at most once per macrotask.\nexport const onMessage = async ({anyProcess, channel, isSubprocess, ipcEmitter}, wrappedMessage) => {\n\tif (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {\n\t\treturn;\n\t}\n\n\tif (!INCOMING_MESSAGES.has(anyProcess)) {\n\t\tINCOMING_MESSAGES.set(anyProcess, []);\n\t}\n\n\tconst incomingMessages = INCOMING_MESSAGES.get(anyProcess);\n\tincomingMessages.push(wrappedMessage);\n\n\tif (incomingMessages.length > 1) {\n\t\treturn;\n\t}\n\n\twhile (incomingMessages.length > 0) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait scheduler.yield();\n\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tconst message = await handleStrictRequest({\n\t\t\twrappedMessage: incomingMessages[0],\n\t\t\tanyProcess,\n\t\t\tchannel,\n\t\t\tisSubprocess,\n\t\t\tipcEmitter,\n\t\t});\n\n\t\tincomingMessages.shift();\n\t\tipcEmitter.emit('message', message);\n\t\tipcEmitter.emit('message:done');\n\t}\n};\n\n// If the `message` event is currently debounced, the `disconnect` event must wait for it\nexport const onDisconnect = async ({anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage}) => {\n\tabortOnDisconnect();\n\n\tconst incomingMessages = INCOMING_MESSAGES.get(anyProcess);\n\twhile (incomingMessages?.length > 0) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait once(ipcEmitter, 'message:done');\n\t}\n\n\tanyProcess.removeListener('message', boundOnMessage);\n\tredoAddedReferences(channel, isSubprocess);\n\tipcEmitter.connected = false;\n\tipcEmitter.emit('disconnect');\n};\n\nconst INCOMING_MESSAGES = new WeakMap();\n", "// By default, Node.js keeps the subprocess alive while it has a `message` or `disconnect` listener.\n// We replicate the same logic for the events that we proxy.\n// This ensures the subprocess is kept alive while `getOneMessage()` and `getEachMessage()` are ongoing.\n// This is not a problem with `sendMessage()` since Node.js handles that method automatically.\n// We do not use `anyProcess.channel.ref()` since this would prevent the automatic `.channel.refCounted()` Node.js is doing.\n// We keep a reference to `anyProcess.channel` since it might be `null` while `getOneMessage()` or `getEachMessage()` is still processing debounced messages.\n// See https://github.com/nodejs/node/blob/2aaeaa863c35befa2ebaa98fb7737ec84df4d8e9/lib/internal/child_process.js#L547\nexport const addReference = (channel, reference) => {\n\tif (reference) {\n\t\taddReferenceCount(channel);\n\t}\n};\n\nconst addReferenceCount = channel => {\n\tchannel.refCounted();\n};\n\nexport const removeReference = (channel, reference) => {\n\tif (reference) {\n\t\tremoveReferenceCount(channel);\n\t}\n};\n\nconst removeReferenceCount = channel => {\n\tchannel.unrefCounted();\n};\n\n// To proxy events, we setup some global listeners on the `message` and `disconnect` events.\n// Those should not keep the subprocess alive, so we remove the automatic counting that Node.js is doing.\n// See https://github.com/nodejs/node/blob/1b965270a9c273d4cf70e8808e9d28b9ada7844f/lib/child_process.js#L180\nexport const undoAddedReferences = (channel, isSubprocess) => {\n\tif (isSubprocess) {\n\t\tremoveReferenceCount(channel);\n\t\tremoveReferenceCount(channel);\n\t}\n};\n\n// Reverse it during `disconnect`\nexport const redoAddedReferences = (channel, isSubprocess) => {\n\tif (isSubprocess) {\n\t\taddReferenceCount(channel);\n\t\taddReferenceCount(channel);\n\t}\n};\n", "import {createDeferred} from '../utils/deferred.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\nimport {SUBPROCESS_OPTIONS} from '../arguments/fd-options.js';\nimport {validateStrictDeadlock} from './strict.js';\n\n// When `sendMessage()` is ongoing, any `message` being received waits before being emitted.\n// This allows calling one or multiple `await sendMessage()` followed by `await getOneMessage()`/`await getEachMessage()`.\n// Without running into a race condition when the other process sends a response too fast, before the current process set up a listener.\nexport const startSendMessage = (anyProcess, wrappedMessage, strict) => {\n\tif (!OUTGOING_MESSAGES.has(anyProcess)) {\n\t\tOUTGOING_MESSAGES.set(anyProcess, new Set());\n\t}\n\n\tconst outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);\n\tconst onMessageSent = createDeferred();\n\tconst id = strict ? wrappedMessage.id : undefined;\n\tconst outgoingMessage = {onMessageSent, id};\n\toutgoingMessages.add(outgoingMessage);\n\treturn {outgoingMessages, outgoingMessage};\n};\n\nexport const endSendMessage = ({outgoingMessages, outgoingMessage}) => {\n\toutgoingMessages.delete(outgoingMessage);\n\toutgoingMessage.onMessageSent.resolve();\n};\n\n// Await while `sendMessage()` is ongoing, unless there is already a `message` listener\nexport const waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {\n\twhile (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {\n\t\tconst outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];\n\t\tvalidateStrictDeadlock(outgoingMessages, wrappedMessage);\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tawait Promise.all(outgoingMessages.map(({onMessageSent}) => onMessageSent));\n\t}\n};\n\nconst OUTGOING_MESSAGES = new WeakMap();\n\n// Whether any `message` listener is setup\nexport const hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount('message') > getMinListenerCount(anyProcess);\n\n// When `buffer` is `false`, we set up a `message` listener that should be ignored.\n// That listener is only meant to intercept `strict` acknowledgement responses.\nconst getMinListenerCount = anyProcess => SUBPROCESS_OPTIONS.has(anyProcess)\n\t&& !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, 'ipc')\n\t? 1\n\t: 0;\n", "import {onAbortedSignal} from '../utils/abort-signal.js';\nimport {sendAbort} from '../ipc/graceful.js';\nimport {killOnTimeout} from './kill.js';\n\n// Validate the `gracefulCancel` option\nexport const validateGracefulCancel = ({gracefulCancel, cancelSignal, ipc, serialization}) => {\n\tif (!gracefulCancel) {\n\t\treturn;\n\t}\n\n\tif (cancelSignal === undefined) {\n\t\tthrow new Error('The `cancelSignal` option must be defined when setting the `gracefulCancel` option.');\n\t}\n\n\tif (!ipc) {\n\t\tthrow new Error('The `ipc` option cannot be false when setting the `gracefulCancel` option.');\n\t}\n\n\tif (serialization === 'json') {\n\t\tthrow new Error('The `serialization` option cannot be \\'json\\' when setting the `gracefulCancel` option.');\n\t}\n};\n\n// Send abort reason to the subprocess when aborting the `cancelSignal` option and `gracefulCancel` is `true`\nexport const throwOnGracefulCancel = ({\n\tsubprocess,\n\tcancelSignal,\n\tgracefulCancel,\n\tforceKillAfterDelay,\n\tcontext,\n\tcontroller,\n}) => gracefulCancel\n\t? [sendOnAbort({\n\t\tsubprocess,\n\t\tcancelSignal,\n\t\tforceKillAfterDelay,\n\t\tcontext,\n\t\tcontroller,\n\t})]\n\t: [];\n\nconst sendOnAbort = async ({subprocess, cancelSignal, forceKillAfterDelay, context, controller: {signal}}) => {\n\tawait onAbortedSignal(cancelSignal, signal);\n\tconst reason = getReason(cancelSignal);\n\tawait sendAbort(subprocess, reason);\n\tkillOnTimeout({\n\t\tkill: subprocess.kill,\n\t\tforceKillAfterDelay,\n\t\tcontext,\n\t\tcontrollerSignal: signal,\n\t});\n\tcontext.terminationReason ??= 'gracefulCancel';\n\tthrow cancelSignal.reason;\n};\n\n// The default `reason` is a DOMException, which is not serializable with V8\n// See https://github.com/nodejs/node/issues/53225\nconst getReason = ({reason}) => {\n\tif (!(reason instanceof DOMException)) {\n\t\treturn reason;\n\t}\n\n\tconst error = new Error(reason.message);\n\tObject.defineProperty(error, 'stack', {\n\t\tvalue: reason.stack,\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t\twritable: true,\n\t});\n\treturn error;\n};\n", "import {setTimeout} from 'node:timers/promises';\nimport {DiscardedError} from '../return/final-error.js';\n\n// Validate `timeout` option\nexport const validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// Fails when the `timeout` option is exceeded\nexport const throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === undefined\n\t? []\n\t: [killAfterTimeout(subprocess, timeout, context, controller)];\n\nconst killAfterTimeout = async (subprocess, timeout, context, {signal}) => {\n\tawait setTimeout(timeout, undefined, {signal});\n\tcontext.terminationReason ??= 'timeout';\n\tsubprocess.kill();\n\tthrow new DiscardedError();\n};\n", "import {execPath, execArgv} from 'node:process';\nimport path from 'node:path';\nimport {safeNormalizeFileUrl} from '../arguments/file-url.js';\n\n// `execaNode()` is a shortcut for `execa(..., {node: true})`\nexport const mapNode = ({options}) => {\n\tif (options.node === false) {\n\t\tthrow new TypeError('The \"node\" option cannot be false with `execaNode()`.');\n\t}\n\n\treturn {options: {...options, node: true}};\n};\n\n// Applies the `node: true` option, and the related `nodePath`/`nodeOptions` options.\n// Modifies the file commands/arguments to ensure the same Node binary and flags are re-used.\n// Also adds `ipc: true` and `shell: false`.\nexport const handleNodeOption = (file, commandArguments, {\n\tnode: shouldHandleNode = false,\n\tnodePath = execPath,\n\tnodeOptions = execArgv.filter(nodeOption => !nodeOption.startsWith('--inspect')),\n\tcwd,\n\texecPath: formerNodePath,\n\t...options\n}) => {\n\tif (formerNodePath !== undefined) {\n\t\tthrow new TypeError('The \"execPath\" option has been removed. Please use the \"nodePath\" option instead.');\n\t}\n\n\tconst normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The \"nodePath\" option');\n\tconst resolvedNodePath = path.resolve(cwd, normalizedNodePath);\n\tconst newOptions = {\n\t\t...options,\n\t\tnodePath: resolvedNodePath,\n\t\tnode: shouldHandleNode,\n\t\tcwd,\n\t};\n\n\tif (!shouldHandleNode) {\n\t\treturn [file, commandArguments, newOptions];\n\t}\n\n\tif (path.basename(file, '.exe') === 'node') {\n\t\tthrow new TypeError('When the \"node\" option is true, the first argument does not need to be \"node\".');\n\t}\n\n\treturn [\n\t\tresolvedNodePath,\n\t\t[...nodeOptions, file, ...commandArguments],\n\t\t{ipc: true, ...newOptions, shell: false},\n\t];\n};\n", "import {serialize} from 'node:v8';\n\n// Validate the `ipcInput` option\nexport const validateIpcInputOption = ({ipcInput, ipc, serialization}) => {\n\tif (ipcInput === undefined) {\n\t\treturn;\n\t}\n\n\tif (!ipc) {\n\t\tthrow new Error('The `ipcInput` option cannot be set unless the `ipc` option is `true`.');\n\t}\n\n\tvalidateIpcInput[serialization](ipcInput);\n};\n\nconst validateAdvancedInput = ipcInput => {\n\ttry {\n\t\tserialize(ipcInput);\n\t} catch (error) {\n\t\tthrow new Error('The `ipcInput` option is not serializable with a structured clone.', {cause: error});\n\t}\n};\n\nconst validateJsonInput = ipcInput => {\n\ttry {\n\t\tJSON.stringify(ipcInput);\n\t} catch (error) {\n\t\tthrow new Error('The `ipcInput` option is not serializable with JSON.', {cause: error});\n\t}\n};\n\nconst validateIpcInput = {\n\tadvanced: validateAdvancedInput,\n\tjson: validateJsonInput,\n};\n\n// When the `ipcInput` option is set, it is sent as an initial IPC message to the subprocess\nexport const sendIpcInput = async (subprocess, ipcInput) => {\n\tif (ipcInput === undefined) {\n\t\treturn;\n\t}\n\n\tawait subprocess.sendMessage(ipcInput);\n};\n", "// Validate `encoding` option\nexport const validateEncoding = ({encoding}) => {\n\tif (ENCODINGS.has(encoding)) {\n\t\treturn;\n\t}\n\n\tconst correctEncoding = getCorrectEncoding(encoding);\n\tif (correctEncoding !== undefined) {\n\t\tthrow new TypeError(`Invalid option \\`encoding: ${serializeEncoding(encoding)}\\`.\nPlease rename it to ${serializeEncoding(correctEncoding)}.`);\n\t}\n\n\tconst correctEncodings = [...ENCODINGS].map(correctEncoding => serializeEncoding(correctEncoding)).join(', ');\n\tthrow new TypeError(`Invalid option \\`encoding: ${serializeEncoding(encoding)}\\`.\nPlease rename it to one of: ${correctEncodings}.`);\n};\n\nconst TEXT_ENCODINGS = new Set(['utf8', 'utf16le']);\nexport const BINARY_ENCODINGS = new Set(['buffer', 'hex', 'base64', 'base64url', 'latin1', 'ascii']);\nconst ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);\n\nconst getCorrectEncoding = encoding => {\n\tif (encoding === null) {\n\t\treturn 'buffer';\n\t}\n\n\tif (typeof encoding !== 'string') {\n\t\treturn;\n\t}\n\n\tconst lowerEncoding = encoding.toLowerCase();\n\tif (lowerEncoding in ENCODING_ALIASES) {\n\t\treturn ENCODING_ALIASES[lowerEncoding];\n\t}\n\n\tif (ENCODINGS.has(lowerEncoding)) {\n\t\treturn lowerEncoding;\n\t}\n};\n\nconst ENCODING_ALIASES = {\n\t// eslint-disable-next-line unicorn/text-encoding-identifier-case\n\t'utf-8': 'utf8',\n\t'utf-16le': 'utf16le',\n\t'ucs-2': 'utf16le',\n\tucs2: 'utf16le',\n\tbinary: 'latin1',\n};\n\nconst serializeEncoding = encoding => typeof encoding === 'string' ? `\"${encoding}\"` : String(encoding);\n", "import {statSync} from 'node:fs';\nimport path from 'node:path';\nimport process from 'node:process';\nimport {safeNormalizeFileUrl} from './file-url.js';\n\n// Normalize `cwd` option\nexport const normalizeCwd = (cwd = getDefaultCwd()) => {\n\tconst cwdString = safeNormalizeFileUrl(cwd, 'The \"cwd\" option');\n\treturn path.resolve(cwdString);\n};\n\nconst getDefaultCwd = () => {\n\ttry {\n\t\treturn process.cwd();\n\t} catch (error) {\n\t\terror.message = `The current directory does not exist.\\n${error.message}`;\n\t\tthrow error;\n\t}\n};\n\n// When `cwd` option has an invalid value, provide with a better error message\nexport const fixCwdError = (originalMessage, cwd) => {\n\tif (cwd === getDefaultCwd()) {\n\t\treturn originalMessage;\n\t}\n\n\tlet cwdStat;\n\ttry {\n\t\tcwdStat = statSync(cwd);\n\t} catch (error) {\n\t\treturn `The \"cwd\" option is invalid: ${cwd}.\\n${error.message}\\n${originalMessage}`;\n\t}\n\n\tif (!cwdStat.isDirectory()) {\n\t\treturn `The \"cwd\" option is not a directory: ${cwd}.\\n${originalMessage}`;\n\t}\n\n\treturn originalMessage;\n};\n", "import {inspect} from 'node:util';\nimport stripFinalNewline from 'strip-final-newline';\nimport {isUint8Array, uint8ArrayToString} from '../utils/uint-array.js';\nimport {fixCwdError} from '../arguments/cwd.js';\nimport {escapeLines} from '../arguments/escape.js';\nimport {getMaxBufferMessage} from '../io/max-buffer.js';\nimport {getSignalDescription} from '../terminate/signal.js';\nimport {DiscardedError, isExecaError} from './final-error.js';\n\n// Computes `error.message`, `error.shortMessage` and `error.originalMessage`\nexport const createMessages = ({\n\tstdio,\n\tall,\n\tipcOutput,\n\toriginalError,\n\tsignal,\n\tsignalDescription,\n\texitCode,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\tforceKillAfterDelay,\n\tkillSignal,\n\tmaxBuffer,\n\ttimeout,\n\tcwd,\n}) => {\n\tconst errorCode = originalError?.code;\n\tconst prefix = getErrorPrefix({\n\t\toriginalError,\n\t\ttimedOut,\n\t\ttimeout,\n\t\tisMaxBuffer,\n\t\tmaxBuffer,\n\t\terrorCode,\n\t\tsignal,\n\t\tsignalDescription,\n\t\texitCode,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisForcefullyTerminated,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t});\n\tconst originalMessage = getOriginalMessage(originalError, cwd);\n\tconst suffix = originalMessage === undefined ? '' : `\\n${originalMessage}`;\n\tconst shortMessage = `${prefix}: ${escapedCommand}${suffix}`;\n\tconst messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];\n\tconst message = [\n\t\tshortMessage,\n\t\t...messageStdio,\n\t\t...stdio.slice(3),\n\t\tipcOutput.map(ipcMessage => serializeIpcMessage(ipcMessage)).join('\\n'),\n\t]\n\t\t.map(messagePart => escapeLines(stripFinalNewline(serializeMessagePart(messagePart))))\n\t\t.filter(Boolean)\n\t\t.join('\\n\\n');\n\treturn {originalMessage, shortMessage, message};\n};\n\nconst getErrorPrefix = ({\n\toriginalError,\n\ttimedOut,\n\ttimeout,\n\tisMaxBuffer,\n\tmaxBuffer,\n\terrorCode,\n\tsignal,\n\tsignalDescription,\n\texitCode,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisForcefullyTerminated,\n\tforceKillAfterDelay,\n\tkillSignal,\n}) => {\n\tconst forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);\n\n\tif (timedOut) {\n\t\treturn `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;\n\t}\n\n\tif (isGracefullyCanceled) {\n\t\tif (signal === undefined) {\n\t\t\treturn `Command was gracefully canceled with exit code ${exitCode}`;\n\t\t}\n\n\t\treturn isForcefullyTerminated\n\t\t\t? `Command was gracefully canceled${forcefulSuffix}`\n\t\t\t: `Command was gracefully canceled with ${signal} (${signalDescription})`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn `Command was canceled${forcefulSuffix}`;\n\t}\n\n\tif (isMaxBuffer) {\n\t\treturn `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `Command failed with ${errorCode}${forcefulSuffix}`;\n\t}\n\n\tif (isForcefullyTerminated) {\n\t\treturn `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `Command was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `Command failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'Command failed';\n};\n\nconst getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated\n\t? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds`\n\t: '';\n\nconst getOriginalMessage = (originalError, cwd) => {\n\tif (originalError instanceof DiscardedError) {\n\t\treturn;\n\t}\n\n\tconst originalMessage = isExecaError(originalError)\n\t\t? originalError.originalMessage\n\t\t: String(originalError?.message ?? originalError);\n\tconst escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));\n\treturn escapedOriginalMessage === '' ? undefined : escapedOriginalMessage;\n};\n\nconst serializeIpcMessage = ipcMessage => typeof ipcMessage === 'string'\n\t? ipcMessage\n\t: inspect(ipcMessage);\n\nconst serializeMessagePart = messagePart => Array.isArray(messagePart)\n\t? messagePart.map(messageItem => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join('\\n')\n\t: serializeMessageItem(messagePart);\n\nconst serializeMessageItem = messageItem => {\n\tif (typeof messageItem === 'string') {\n\t\treturn messageItem;\n\t}\n\n\tif (isUint8Array(messageItem)) {\n\t\treturn uint8ArrayToString(messageItem);\n\t}\n\n\treturn '';\n};\n", "export default function stripFinalNewline(input) {\n\tif (typeof input === 'string') {\n\t\treturn stripFinalNewlineString(input);\n\t}\n\n\tif (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {\n\t\tthrow new Error('Input must be a string or a Uint8Array');\n\t}\n\n\treturn stripFinalNewlineBinary(input);\n}\n\nconst stripFinalNewlineString = input =>\n\tinput.at(-1) === LF\n\t\t? input.slice(0, input.at(-2) === CR ? -2 : -1)\n\t\t: input;\n\nconst stripFinalNewlineBinary = input =>\n\tinput.at(-1) === LF_BINARY\n\t\t? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1)\n\t\t: input;\n\nconst LF = '\\n';\nconst LF_BINARY = LF.codePointAt(0);\nconst CR = '\\r';\nconst CR_BINARY = CR.codePointAt(0);\n", "import {on} from 'node:events';\nimport {finished} from 'node:stream/promises';\nimport {nodeImports} from './stream.js';\n\nObject.assign(nodeImports, {on, finished});\n\nexport {\n\tdefault,\n\tgetStreamAsArray,\n\tgetStreamAsArrayBuffer,\n\tgetStreamAsBuffer,\n\tMaxBufferError,\n} from './exports.js';\n", "export function isStream(stream, {checkOpen = true} = {}) {\n\treturn stream !== null\n\t\t&& typeof stream === 'object'\n\t\t&& (stream.writable || stream.readable || !checkOpen || (stream.writable === undefined && stream.readable === undefined))\n\t\t&& typeof stream.pipe === 'function';\n}\n\nexport function isWritableStream(stream, {checkOpen = true} = {}) {\n\treturn isStream(stream, {checkOpen})\n\t\t&& (stream.writable || !checkOpen)\n\t\t&& typeof stream.write === 'function'\n\t\t&& typeof stream.end === 'function'\n\t\t&& typeof stream.writable === 'boolean'\n\t\t&& typeof stream.writableObjectMode === 'boolean'\n\t\t&& typeof stream.destroy === 'function'\n\t\t&& typeof stream.destroyed === 'boolean';\n}\n\nexport function isReadableStream(stream, {checkOpen = true} = {}) {\n\treturn isStream(stream, {checkOpen})\n\t\t&& (stream.readable || !checkOpen)\n\t\t&& typeof stream.read === 'function'\n\t\t&& typeof stream.readable === 'boolean'\n\t\t&& typeof stream.readableObjectMode === 'boolean'\n\t\t&& typeof stream.destroy === 'function'\n\t\t&& typeof stream.destroyed === 'boolean';\n}\n\nexport function isDuplexStream(stream, options) {\n\treturn isWritableStream(stream, options)\n\t\t&& isReadableStream(stream, options);\n}\n\nexport function isTransformStream(stream, options) {\n\treturn isDuplexStream(stream, options)\n\t\t&& typeof stream._transform === 'function';\n}\n", "const a = Object.getPrototypeOf(\n  Object.getPrototypeOf(\n    /* istanbul ignore next */\n    async function* () {\n    }\n  ).prototype\n);\nclass c {\n  #t;\n  #n;\n  #r = !1;\n  #e = void 0;\n  constructor(e, t) {\n    this.#t = e, this.#n = t;\n  }\n  next() {\n    const e = () => this.#s();\n    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;\n  }\n  return(e) {\n    const t = () => this.#i(e);\n    return this.#e ? this.#e.then(t, t) : t();\n  }\n  async #s() {\n    if (this.#r)\n      return {\n        done: !0,\n        value: void 0\n      };\n    let e;\n    try {\n      e = await this.#t.read();\n    } catch (t) {\n      throw this.#e = void 0, this.#r = !0, this.#t.releaseLock(), t;\n    }\n    return e.done && (this.#e = void 0, this.#r = !0, this.#t.releaseLock()), e;\n  }\n  async #i(e) {\n    if (this.#r)\n      return {\n        done: !0,\n        value: e\n      };\n    if (this.#r = !0, !this.#n) {\n      const t = this.#t.cancel(e);\n      return this.#t.releaseLock(), await t, {\n        done: !0,\n        value: e\n      };\n    }\n    return this.#t.releaseLock(), {\n      done: !0,\n      value: e\n    };\n  }\n}\nconst n = Symbol();\nfunction i() {\n  return this[n].next();\n}\nObject.defineProperty(i, \"name\", { value: \"next\" });\nfunction o(r) {\n  return this[n].return(r);\n}\nObject.defineProperty(o, \"name\", { value: \"return\" });\nconst u = Object.create(a, {\n  next: {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: i\n  },\n  return: {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: o\n  }\n});\nfunction h({ preventCancel: r = !1 } = {}) {\n  const e = this.getReader(), t = new c(\n    e,\n    r\n  ), s = Object.create(u);\n  return s[n] = t, s;\n}\nexport {\n  h as asyncIterator\n};\n", "import {isReadableStream} from 'is-stream';\nimport {asyncIterator} from '@sec-ant/readable-stream/ponyfill';\n\nexport const getAsyncIterable = stream => {\n\tif (isReadableStream(stream, {checkOpen: false}) && nodeImports.on !== undefined) {\n\t\treturn getStreamIterable(stream);\n\t}\n\n\tif (typeof stream?.[Symbol.asyncIterator] === 'function') {\n\t\treturn stream;\n\t}\n\n\t// `ReadableStream[Symbol.asyncIterator]` support is missing in multiple browsers, so we ponyfill it\n\tif (toString.call(stream) === '[object ReadableStream]') {\n\t\treturn asyncIterator.call(stream);\n\t}\n\n\tthrow new TypeError('The first argument must be a Readable, a ReadableStream, or an async iterable.');\n};\n\nconst {toString} = Object.prototype;\n\n// The default iterable for Node.js streams does not allow for multiple readers at once, so we re-implement it\nconst getStreamIterable = async function * (stream) {\n\tconst controller = new AbortController();\n\tconst state = {};\n\thandleStreamEnd(stream, controller, state);\n\n\ttry {\n\t\tfor await (const [chunk] of nodeImports.on(stream, 'data', {signal: controller.signal})) {\n\t\t\tyield chunk;\n\t\t}\n\t} catch (error) {\n\t\t// Stream failure, for example due to `stream.destroy(error)`\n\t\tif (state.error !== undefined) {\n\t\t\tthrow state.error;\n\t\t// `error` event directly emitted on stream\n\t\t} else if (!controller.signal.aborted) {\n\t\t\tthrow error;\n\t\t// Otherwise, stream completed successfully\n\t\t}\n\t\t// The `finally` block also runs when the caller throws, for example due to the `maxBuffer` option\n\t} finally {\n\t\tstream.destroy();\n\t}\n};\n\nconst handleStreamEnd = async (stream, controller, state) => {\n\ttry {\n\t\tawait nodeImports.finished(stream, {\n\t\t\tcleanup: true,\n\t\t\treadable: true,\n\t\t\twritable: false,\n\t\t\terror: false,\n\t\t});\n\t} catch (error) {\n\t\tstate.error = error;\n\t} finally {\n\t\tcontroller.abort();\n\t}\n};\n\n// Loaded by the Node entrypoint, but not by the browser one.\n// This prevents using dynamic imports.\nexport const nodeImports = {};\n", "import {getAsyncIterable} from './stream.js';\n\nexport const getStreamContents = async (stream, {init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize}, {maxBuffer = Number.POSITIVE_INFINITY} = {}) => {\n\tconst asyncIterable = getAsyncIterable(stream);\n\n\tconst state = init();\n\tstate.length = 0;\n\n\ttry {\n\t\tfor await (const chunk of asyncIterable) {\n\t\t\tconst chunkType = getChunkType(chunk);\n\t\t\tconst convertedChunk = convertChunk[chunkType](chunk, state);\n\t\t\tappendChunk({\n\t\t\t\tconvertedChunk,\n\t\t\t\tstate,\n\t\t\t\tgetSize,\n\t\t\t\ttruncateChunk,\n\t\t\t\taddChunk,\n\t\t\t\tmaxBuffer,\n\t\t\t});\n\t\t}\n\n\t\tappendFinalChunk({\n\t\t\tstate,\n\t\t\tconvertChunk,\n\t\t\tgetSize,\n\t\t\ttruncateChunk,\n\t\t\taddChunk,\n\t\t\tgetFinalChunk,\n\t\t\tmaxBuffer,\n\t\t});\n\t\treturn finalize(state);\n\t} catch (error) {\n\t\tconst normalizedError = typeof error === 'object' && error !== null ? error : new Error(error);\n\t\tnormalizedError.bufferedData = finalize(state);\n\t\tthrow normalizedError;\n\t}\n};\n\nconst appendFinalChunk = ({state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer}) => {\n\tconst convertedChunk = getFinalChunk(state);\n\tif (convertedChunk !== undefined) {\n\t\tappendChunk({\n\t\t\tconvertedChunk,\n\t\t\tstate,\n\t\t\tgetSize,\n\t\t\ttruncateChunk,\n\t\t\taddChunk,\n\t\t\tmaxBuffer,\n\t\t});\n\t}\n};\n\nconst appendChunk = ({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer}) => {\n\tconst chunkSize = getSize(convertedChunk);\n\tconst newLength = state.length + chunkSize;\n\n\tif (newLength <= maxBuffer) {\n\t\taddNewChunk(convertedChunk, state, addChunk, newLength);\n\t\treturn;\n\t}\n\n\tconst truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);\n\n\tif (truncatedChunk !== undefined) {\n\t\taddNewChunk(truncatedChunk, state, addChunk, maxBuffer);\n\t}\n\n\tthrow new MaxBufferError();\n};\n\nconst addNewChunk = (convertedChunk, state, addChunk, newLength) => {\n\tstate.contents = addChunk(convertedChunk, state, newLength);\n\tstate.length = newLength;\n};\n\nconst getChunkType = chunk => {\n\tconst typeOfChunk = typeof chunk;\n\n\tif (typeOfChunk === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (typeOfChunk !== 'object' || chunk === null) {\n\t\treturn 'others';\n\t}\n\n\tif (globalThis.Buffer?.isBuffer(chunk)) {\n\t\treturn 'buffer';\n\t}\n\n\tconst prototypeName = objectToString.call(chunk);\n\n\tif (prototypeName === '[object ArrayBuffer]') {\n\t\treturn 'arrayBuffer';\n\t}\n\n\tif (prototypeName === '[object DataView]') {\n\t\treturn 'dataView';\n\t}\n\n\tif (\n\t\tNumber.isInteger(chunk.byteLength)\n\t\t&& Number.isInteger(chunk.byteOffset)\n\t\t&& objectToString.call(chunk.buffer) === '[object ArrayBuffer]'\n\t) {\n\t\treturn 'typedArray';\n\t}\n\n\treturn 'others';\n};\n\nconst {toString: objectToString} = Object.prototype;\n\nexport class MaxBufferError extends Error {\n\tname = 'MaxBufferError';\n\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t}\n}\n", "export const identity = value => value;\n\nexport const noop = () => undefined;\n\nexport const getContentsProperty = ({contents}) => contents;\n\nexport const throwObjectStream = chunk => {\n\tthrow new Error(`Streams in object mode are not supported: ${String(chunk)}`);\n};\n\nexport const getLengthProperty = convertedChunk => convertedChunk.length;\n", "import {getStreamContents} from './contents.js';\nimport {identity, noop, getContentsProperty} from './utils.js';\n\nexport async function getStreamAsArray(stream, options) {\n\treturn getStreamContents(stream, arrayMethods, options);\n}\n\nconst initArray = () => ({contents: []});\n\nconst increment = () => 1;\n\nconst addArrayChunk = (convertedChunk, {contents}) => {\n\tcontents.push(convertedChunk);\n\treturn contents;\n};\n\nconst arrayMethods = {\n\tinit: initArray,\n\tconvertChunk: {\n\t\tstring: identity,\n\t\tbuffer: identity,\n\t\tarrayBuffer: identity,\n\t\tdataView: identity,\n\t\ttypedArray: identity,\n\t\tothers: identity,\n\t},\n\tgetSize: increment,\n\ttruncateChunk: noop,\n\taddChunk: addArrayChunk,\n\tgetFinalChunk: noop,\n\tfinalize: getContentsProperty,\n};\n", "import {getStreamContents} from './contents.js';\nimport {noop, throwObjectStream, getLengthProperty} from './utils.js';\n\nexport async function getStreamAsArrayBuffer(stream, options) {\n\treturn getStreamContents(stream, arrayBufferMethods, options);\n}\n\nconst initArrayBuffer = () => ({contents: new ArrayBuffer(0)});\n\nconst useTextEncoder = chunk => textEncoder.encode(chunk);\nconst textEncoder = new TextEncoder();\n\nconst useUint8Array = chunk => new Uint8Array(chunk);\n\nconst useUint8ArrayWithOffset = chunk => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n\nconst truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\n// `contents` is an increasingly growing `Uint8Array`.\nconst addArrayBufferChunk = (convertedChunk, {contents, length: previousLength}, length) => {\n\tconst newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);\n\tnew Uint8Array(newContents).set(convertedChunk, previousLength);\n\treturn newContents;\n};\n\n// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.\n// This means its last bytes are zeroes (not stream data), which need to be\n// trimmed at the end with `ArrayBuffer.slice()`.\nconst resizeArrayBufferSlow = (contents, length) => {\n\tif (length <= contents.byteLength) {\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(getNewContentsLength(length));\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of\n// the stream data. It does not include extraneous zeroes to trim at the end.\n// The underlying `ArrayBuffer` does allocate a number of bytes that is a power\n// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.\nconst resizeArrayBuffer = (contents, length) => {\n\tif (length <= contents.maxByteLength) {\n\t\tcontents.resize(length);\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(length, {maxByteLength: getNewContentsLength(length)});\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// Retrieve the closest `length` that is both >= and a power of 2\nconst getNewContentsLength = length => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));\n\nconst SCALE_FACTOR = 2;\n\nconst finalizeArrayBuffer = ({contents, length}) => hasArrayBufferResize() ? contents : contents.slice(0, length);\n\n// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available\n// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.\n// eslint-disable-next-line no-warning-comments\n// TODO: remove after dropping support for Node 20.\n// eslint-disable-next-line no-warning-comments\n// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available\nconst hasArrayBufferResize = () => 'resize' in ArrayBuffer.prototype;\n\nconst arrayBufferMethods = {\n\tinit: initArrayBuffer,\n\tconvertChunk: {\n\t\tstring: useTextEncoder,\n\t\tbuffer: useUint8Array,\n\t\tarrayBuffer: useUint8Array,\n\t\tdataView: useUint8ArrayWithOffset,\n\t\ttypedArray: useUint8ArrayWithOffset,\n\t\tothers: throwObjectStream,\n\t},\n\tgetSize: getLengthProperty,\n\ttruncateChunk: truncateArrayBufferChunk,\n\taddChunk: addArrayBufferChunk,\n\tgetFinalChunk: noop,\n\tfinalize: finalizeArrayBuffer,\n};\n", "import {getStreamContents} from './contents.js';\nimport {\n\tidentity,\n\tgetContentsProperty,\n\tthrowObjectStream,\n\tgetLengthProperty,\n} from './utils.js';\n\nexport async function getStreamAsString(stream, options) {\n\treturn getStreamContents(stream, stringMethods, options);\n}\n\nconst initString = () => ({contents: '', textDecoder: new TextDecoder()});\n\nconst useTextDecoder = (chunk, {textDecoder}) => textDecoder.decode(chunk, {stream: true});\n\nconst addStringChunk = (convertedChunk, {contents}) => contents + convertedChunk;\n\nconst truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\nconst getFinalStringChunk = ({textDecoder}) => {\n\tconst finalChunk = textDecoder.decode();\n\treturn finalChunk === '' ? undefined : finalChunk;\n};\n\nconst stringMethods = {\n\tinit: initString,\n\tconvertChunk: {\n\t\tstring: identity,\n\t\tbuffer: useTextDecoder,\n\t\tarrayBuffer: useTextDecoder,\n\t\tdataView: useTextDecoder,\n\t\ttypedArray: useTextDecoder,\n\t\tothers: throwObjectStream,\n\t},\n\tgetSize: getLengthProperty,\n\ttruncateChunk: truncateStringChunk,\n\taddChunk: addStringChunk,\n\tgetFinalChunk: getFinalStringChunk,\n\tfinalize: getContentsProperty,\n};\n", "import {MaxBufferError} from 'get-stream';\nimport {getStreamName} from '../utils/standard-stream.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\n\n// When the `maxBuffer` option is hit, a MaxBufferError is thrown.\n// The stream is aborted, then specific information is kept for the error message.\nexport const handleMaxBuffer = ({error, stream, readableObjectMode, lines, encoding, fdNumber}) => {\n\tif (!(error instanceof MaxBufferError)) {\n\t\tthrow error;\n\t}\n\n\tif (fdNumber === 'all') {\n\t\treturn error;\n\t}\n\n\tconst unit = getMaxBufferUnit(readableObjectMode, lines, encoding);\n\terror.maxBufferInfo = {fdNumber, unit};\n\tstream.destroy();\n\tthrow error;\n};\n\nconst getMaxBufferUnit = (readableObjectMode, lines, encoding) => {\n\tif (readableObjectMode) {\n\t\treturn 'objects';\n\t}\n\n\tif (lines) {\n\t\treturn 'lines';\n\t}\n\n\tif (encoding === 'buffer') {\n\t\treturn 'bytes';\n\t}\n\n\treturn 'characters';\n};\n\n// Check the `maxBuffer` option with `result.ipcOutput`\nexport const checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {\n\tif (ipcOutput.length !== maxBuffer) {\n\t\treturn;\n\t}\n\n\tconst error = new MaxBufferError();\n\terror.maxBufferInfo = {fdNumber: 'ipc'};\n\tthrow error;\n};\n\n// Error message when `maxBuffer` is hit\nexport const getMaxBufferMessage = (error, maxBuffer) => {\n\tconst {streamName, threshold, unit} = getMaxBufferInfo(error, maxBuffer);\n\treturn `Command's ${streamName} was larger than ${threshold} ${unit}`;\n};\n\nconst getMaxBufferInfo = (error, maxBuffer) => {\n\tif (error?.maxBufferInfo === undefined) {\n\t\treturn {streamName: 'output', threshold: maxBuffer[1], unit: 'bytes'};\n\t}\n\n\tconst {maxBufferInfo: {fdNumber, unit}} = error;\n\tdelete error.maxBufferInfo;\n\n\tconst threshold = getFdSpecificValue(maxBuffer, fdNumber);\n\tif (fdNumber === 'ipc') {\n\t\treturn {streamName: 'IPC output', threshold, unit: 'messages'};\n\t}\n\n\treturn {streamName: getStreamName(fdNumber), threshold, unit};\n};\n\n// The only way to apply `maxBuffer` with `spawnSync()` is to use the native `maxBuffer` option Node.js provides.\n// However, this has multiple limitations, and cannot behave the exact same way as the async behavior.\n// When the `maxBuffer` is hit, a `ENOBUFS` error is thrown.\nexport const isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === 'ENOBUFS'\n\t&& output !== null\n\t&& output.some(result => result !== null && result.length > getMaxBufferSync(maxBuffer));\n\n// When `maxBuffer` is hit, ensure the result is truncated\nexport const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {\n\tif (!isMaxBuffer) {\n\t\treturn result;\n\t}\n\n\tconst maxBufferValue = getMaxBufferSync(maxBuffer);\n\treturn result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;\n};\n\n// `spawnSync()` does not allow differentiating `maxBuffer` per file descriptor, so we always use `stdout`\nexport const getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;\n", "import {getSignalDescription} from '../terminate/signal.js';\nimport {getDurationMs} from './duration.js';\nimport {getFinalError} from './final-error.js';\nimport {createMessages} from './message.js';\n\n// Object returned on subprocess success\nexport const makeSuccessResult = ({\n\tcommand,\n\tescapedCommand,\n\tstdio,\n\tall,\n\tipcOutput,\n\toptions: {cwd},\n\tstartTime,\n}) => omitUndefinedProperties({\n\tcommand,\n\tescapedCommand,\n\tcwd,\n\tdurationMs: getDurationMs(startTime),\n\tfailed: false,\n\ttimedOut: false,\n\tisCanceled: false,\n\tisGracefullyCanceled: false,\n\tisTerminated: false,\n\tisMaxBuffer: false,\n\tisForcefullyTerminated: false,\n\texitCode: 0,\n\tstdout: stdio[1],\n\tstderr: stdio[2],\n\tall,\n\tstdio,\n\tipcOutput,\n\tpipedFrom: [],\n});\n\n// Object returned on subprocess failure before spawning\nexport const makeEarlyError = ({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tfileDescriptors,\n\toptions,\n\tstartTime,\n\tisSync,\n}) => makeError({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut: false,\n\tisCanceled: false,\n\tisGracefullyCanceled: false,\n\tisMaxBuffer: false,\n\tisForcefullyTerminated: false,\n\tstdio: Array.from({length: fileDescriptors.length}),\n\tipcOutput: [],\n\toptions,\n\tisSync,\n});\n\n// Object returned on subprocess failure\nexport const makeError = ({\n\terror: originalError,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode: rawExitCode,\n\tsignal: rawSignal,\n\tstdio,\n\tall,\n\tipcOutput,\n\toptions: {\n\t\ttimeoutDuration,\n\t\ttimeout = timeoutDuration,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tcwd,\n\t\tmaxBuffer,\n\t},\n\tisSync,\n}) => {\n\tconst {exitCode, signal, signalDescription} = normalizeExitPayload(rawExitCode, rawSignal);\n\tconst {originalMessage, shortMessage, message} = createMessages({\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toriginalError,\n\t\tsignal,\n\t\tsignalDescription,\n\t\texitCode,\n\t\tescapedCommand,\n\t\ttimedOut,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tmaxBuffer,\n\t\ttimeout,\n\t\tcwd,\n\t});\n\tconst error = getFinalError(originalError, message, isSync);\n\tObject.assign(error, getErrorProperties({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\ttimedOut,\n\t\tisCanceled,\n\t\tisGracefullyCanceled,\n\t\tisMaxBuffer,\n\t\tisForcefullyTerminated,\n\t\texitCode,\n\t\tsignal,\n\t\tsignalDescription,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\tcwd,\n\t\toriginalMessage,\n\t\tshortMessage,\n\t}));\n\treturn error;\n};\n\nconst getErrorProperties = ({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode,\n\tsignal,\n\tsignalDescription,\n\tstdio,\n\tall,\n\tipcOutput,\n\tcwd,\n\toriginalMessage,\n\tshortMessage,\n}) => omitUndefinedProperties({\n\tshortMessage,\n\toriginalMessage,\n\tcommand,\n\tescapedCommand,\n\tcwd,\n\tdurationMs: getDurationMs(startTime),\n\tfailed: true,\n\ttimedOut,\n\tisCanceled,\n\tisGracefullyCanceled,\n\tisTerminated: signal !== undefined,\n\tisMaxBuffer,\n\tisForcefullyTerminated,\n\texitCode,\n\tsignal,\n\tsignalDescription,\n\tcode: error.cause?.code,\n\tstdout: stdio[1],\n\tstderr: stdio[2],\n\tall,\n\tstdio,\n\tipcOutput,\n\tpipedFrom: [],\n});\n\nconst omitUndefinedProperties = result => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined));\n\n// `signal` and `exitCode` emitted on `subprocess.on('exit')` event can be `null`.\n// We normalize them to `undefined`\nconst normalizeExitPayload = (rawExitCode, rawSignal) => {\n\tconst exitCode = rawExitCode === null ? undefined : rawExitCode;\n\tconst signal = rawSignal === null ? undefined : rawSignal;\n\tconst signalDescription = signal === undefined ? undefined : getSignalDescription(rawSignal);\n\treturn {exitCode, signal, signalDescription};\n};\n", "const toZeroIfInfinity = value => Number.isFinite(value) ? value : 0;\n\nfunction parseNumber(milliseconds) {\n\treturn {\n\t\tdays: Math.trunc(milliseconds / 86_400_000),\n\t\thours: Math.trunc(milliseconds / 3_600_000 % 24),\n\t\tminutes: Math.trunc(milliseconds / 60_000 % 60),\n\t\tseconds: Math.trunc(milliseconds / 1000 % 60),\n\t\tmilliseconds: Math.trunc(milliseconds % 1000),\n\t\tmicroseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1000) % 1000),\n\t\tnanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1000),\n\t};\n}\n\nfunction parseBigint(milliseconds) {\n\treturn {\n\t\tdays: milliseconds / 86_400_000n,\n\t\thours: milliseconds / 3_600_000n % 24n,\n\t\tminutes: milliseconds / 60_000n % 60n,\n\t\tseconds: milliseconds / 1000n % 60n,\n\t\tmilliseconds: milliseconds % 1000n,\n\t\tmicroseconds: 0n,\n\t\tnanoseconds: 0n,\n\t};\n}\n\nexport default function parseMilliseconds(milliseconds) {\n\tswitch (typeof milliseconds) {\n\t\tcase 'number': {\n\t\t\tif (Number.isFinite(milliseconds)) {\n\t\t\t\treturn parseNumber(milliseconds);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'bigint': {\n\t\t\treturn parseBigint(milliseconds);\n\t\t}\n\n\t\t// No default\n\t}\n\n\tthrow new TypeError('Expected a finite number or bigint');\n}\n", "import parseMilliseconds from 'parse-ms';\n\nconst isZero = value => value === 0 || value === 0n;\nconst pluralize = (word, count) => (count === 1 || count === 1n) ? word : `${word}s`;\n\nconst SECOND_ROUNDING_EPSILON = 0.000_000_1;\nconst ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;\n\nexport default function prettyMilliseconds(milliseconds, options) {\n\tconst isBigInt = typeof milliseconds === 'bigint';\n\tif (!isBigInt && !Number.isFinite(milliseconds)) {\n\t\tthrow new TypeError('Expected a finite number or bigint');\n\t}\n\n\toptions = {...options};\n\n\tconst sign = milliseconds < 0 ? '-' : '';\n\tmilliseconds = milliseconds < 0 ? -milliseconds : milliseconds; // Cannot use `Math.abs()` because of BigInt support.\n\n\tif (options.colonNotation) {\n\t\toptions.compact = false;\n\t\toptions.formatSubMilliseconds = false;\n\t\toptions.separateMilliseconds = false;\n\t\toptions.verbose = false;\n\t}\n\n\tif (options.compact) {\n\t\toptions.unitCount = 1;\n\t\toptions.secondsDecimalDigits = 0;\n\t\toptions.millisecondsDecimalDigits = 0;\n\t}\n\n\tlet result = [];\n\n\tconst floorDecimals = (value, decimalDigits) => {\n\t\tconst flooredInterimValue = Math.floor((value * (10 ** decimalDigits)) + SECOND_ROUNDING_EPSILON);\n\t\tconst flooredValue = Math.round(flooredInterimValue) / (10 ** decimalDigits);\n\t\treturn flooredValue.toFixed(decimalDigits);\n\t};\n\n\tconst add = (value, long, short, valueString) => {\n\t\tif (\n\t\t\t(result.length === 0 || !options.colonNotation)\n\t\t\t&& isZero(value)\n\t\t\t&& !(options.colonNotation && short === 'm')) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalueString ??= String(value);\n\t\tif (options.colonNotation) {\n\t\t\tconst wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;\n\t\t\tconst minLength = result.length > 0 ? 2 : 1;\n\t\t\tvalueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;\n\t\t} else {\n\t\t\tvalueString += options.verbose ? ' ' + pluralize(long, value) : short;\n\t\t}\n\n\t\tresult.push(valueString);\n\t};\n\n\tconst parsed = parseMilliseconds(milliseconds);\n\tconst days = BigInt(parsed.days);\n\n\tadd(days / 365n, 'year', 'y');\n\tadd(days % 365n, 'day', 'd');\n\tadd(Number(parsed.hours), 'hour', 'h');\n\tadd(Number(parsed.minutes), 'minute', 'm');\n\n\tif (\n\t\toptions.separateMilliseconds\n\t\t|| options.formatSubMilliseconds\n\t\t|| (!options.colonNotation && milliseconds < 1000)\n\t) {\n\t\tconst seconds = Number(parsed.seconds);\n\t\tconst milliseconds = Number(parsed.milliseconds);\n\t\tconst microseconds = Number(parsed.microseconds);\n\t\tconst nanoseconds = Number(parsed.nanoseconds);\n\n\t\tadd(seconds, 'second', 's');\n\n\t\tif (options.formatSubMilliseconds) {\n\t\t\tadd(milliseconds, 'millisecond', 'ms');\n\t\t\tadd(microseconds, 'microsecond', '\u00B5s');\n\t\t\tadd(nanoseconds, 'nanosecond', 'ns');\n\t\t} else {\n\t\t\tconst millisecondsAndBelow\n\t\t\t\t= milliseconds\n\t\t\t\t+ (microseconds / 1000)\n\t\t\t\t+ (nanoseconds / 1e6);\n\n\t\t\tconst millisecondsDecimalDigits\n\t\t\t\t= typeof options.millisecondsDecimalDigits === 'number'\n\t\t\t\t\t? options.millisecondsDecimalDigits\n\t\t\t\t\t: 0;\n\n\t\t\tconst roundedMilliseconds = millisecondsAndBelow >= 1\n\t\t\t\t? Math.round(millisecondsAndBelow)\n\t\t\t\t: Math.ceil(millisecondsAndBelow);\n\n\t\t\tconst millisecondsString = millisecondsDecimalDigits\n\t\t\t\t? millisecondsAndBelow.toFixed(millisecondsDecimalDigits)\n\t\t\t\t: roundedMilliseconds;\n\n\t\t\tadd(\n\t\t\t\tNumber.parseFloat(millisecondsString),\n\t\t\t\t'millisecond',\n\t\t\t\t'ms',\n\t\t\t\tmillisecondsString,\n\t\t\t);\n\t\t}\n\t} else {\n\t\tconst seconds = (\n\t\t\t(isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds)\n\t\t\t/ 1000\n\t\t) % 60;\n\t\tconst secondsDecimalDigits\n\t\t\t= typeof options.secondsDecimalDigits === 'number'\n\t\t\t\t? options.secondsDecimalDigits\n\t\t\t\t: 1;\n\t\tconst secondsFixed = floorDecimals(seconds, secondsDecimalDigits);\n\t\tconst secondsString = options.keepDecimalsOnWholeSeconds\n\t\t\t? secondsFixed\n\t\t\t: secondsFixed.replace(/\\.0+$/, '');\n\t\tadd(Number.parseFloat(secondsString), 'second', 's', secondsString);\n\t}\n\n\tif (result.length === 0) {\n\t\treturn sign + '0' + (options.verbose ? ' milliseconds' : 'ms');\n\t}\n\n\tconst separator = options.colonNotation ? ':' : ' ';\n\tif (typeof options.unitCount === 'number') {\n\t\tresult = result.slice(0, Math.max(options.unitCount, 1));\n\t}\n\n\treturn sign + result.join(separator);\n}\n", "import {verboseLog} from './log.js';\n\n// When `verbose` is `short|full|custom`, print each command's error when it fails\nexport const logError = (result, verboseInfo) => {\n\tif (result.failed) {\n\t\tverboseLog({\n\t\t\ttype: 'error',\n\t\t\tverboseMessage: result.shortMessage,\n\t\t\tverboseInfo,\n\t\t\tresult,\n\t\t});\n\t}\n};\n", "import prettyMs from 'pretty-ms';\nimport {isVerbose} from './values.js';\nimport {verboseLog} from './log.js';\nimport {logError} from './error.js';\n\n// When `verbose` is `short|full|custom`, print each command's completion, duration and error\nexport const logResult = (result, verboseInfo) => {\n\tif (!isVerbose(verboseInfo)) {\n\t\treturn;\n\t}\n\n\tlogError(result, verboseInfo);\n\tlogDuration(result, verboseInfo);\n};\n\nconst logDuration = (result, verboseInfo) => {\n\tconst verboseMessage = `(done in ${prettyMs(result.durationMs)})`;\n\tverboseLog({\n\t\ttype: 'duration',\n\t\tverboseMessage,\n\t\tverboseInfo,\n\t\tresult,\n\t});\n};\n", "import {logResult} from '../verbose/complete.js';\n\n// Applies the `reject` option.\n// Also print the final log line with `verbose`.\nexport const handleResult = (result, verboseInfo, {reject}) => {\n\tlogResult(result, verboseInfo);\n\n\tif (result.failed && reject) {\n\t\tthrow result;\n\t}\n\n\treturn result;\n};\n", "import {readFileSync} from 'node:fs';\nimport {bufferToUint8Array} from '../utils/uint-array.js';\nimport {handleStdio} from './handle.js';\nimport {TYPE_TO_MESSAGE} from './type.js';\n\n// Normalize `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in sync mode\nexport const handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);\n\nconst forbiddenIfSync = ({type, optionName}) => {\n\tthrowInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);\n};\n\nconst forbiddenNativeIfSync = ({optionName, value}) => {\n\tif (value === 'ipc' || value === 'overlapped') {\n\t\tthrowInvalidSyncValue(optionName, `\"${value}\"`);\n\t}\n\n\treturn {};\n};\n\nconst throwInvalidSyncValue = (optionName, value) => {\n\tthrow new TypeError(`The \\`${optionName}\\` option cannot be ${value} with synchronous methods.`);\n};\n\n// Create streams used internally for redirecting when using specific values for the `std*` options, in sync mode.\n// For example, `stdin: {file}` reads the file synchronously, then passes it as the `input` option.\nconst addProperties = {\n\tgenerator() {},\n\tasyncGenerator: forbiddenIfSync,\n\twebStream: forbiddenIfSync,\n\tnodeStream: forbiddenIfSync,\n\twebTransform: forbiddenIfSync,\n\tduplex: forbiddenIfSync,\n\tasyncIterable: forbiddenIfSync,\n\tnative: forbiddenNativeIfSync,\n};\n\nconst addPropertiesSync = {\n\tinput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({contents: [bufferToUint8Array(readFileSync(value))]}),\n\t\tfilePath: ({value: {file}}) => ({contents: [bufferToUint8Array(readFileSync(file))]}),\n\t\tfileNumber: forbiddenIfSync,\n\t\titerable: ({value}) => ({contents: [...value]}),\n\t\tstring: ({value}) => ({contents: [value]}),\n\t\tuint8Array: ({value}) => ({contents: [value]}),\n\t},\n\toutput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({path: value}),\n\t\tfilePath: ({value: {file}}) => ({path: file}),\n\t\tfileNumber: ({value}) => ({path: value}),\n\t\titerable: forbiddenIfSync,\n\t\tstring: forbiddenIfSync,\n\t\tuint8Array: forbiddenIfSync,\n\t},\n};\n", "import {isStream as isNodeStream, isDuplexStream} from 'is-stream';\nimport isPlainObj from 'is-plain-obj';\nimport {isUint8Array} from '../utils/uint-array.js';\n\n// The `stdin`/`stdout`/`stderr` option can be of many types. This detects it.\nexport const getStdioItemType = (value, optionName) => {\n\tif (isAsyncGenerator(value)) {\n\t\treturn 'asyncGenerator';\n\t}\n\n\tif (isSyncGenerator(value)) {\n\t\treturn 'generator';\n\t}\n\n\tif (isUrl(value)) {\n\t\treturn 'fileUrl';\n\t}\n\n\tif (isFilePathObject(value)) {\n\t\treturn 'filePath';\n\t}\n\n\tif (isWebStream(value)) {\n\t\treturn 'webStream';\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\treturn 'native';\n\t}\n\n\tif (isUint8Array(value)) {\n\t\treturn 'uint8Array';\n\t}\n\n\tif (isAsyncIterableObject(value)) {\n\t\treturn 'asyncIterable';\n\t}\n\n\tif (isIterableObject(value)) {\n\t\treturn 'iterable';\n\t}\n\n\tif (isTransformStream(value)) {\n\t\treturn getTransformStreamType({transform: value}, optionName);\n\t}\n\n\tif (isTransformOptions(value)) {\n\t\treturn getTransformObjectType(value, optionName);\n\t}\n\n\treturn 'native';\n};\n\nconst getTransformObjectType = (value, optionName) => {\n\tif (isDuplexStream(value.transform, {checkOpen: false})) {\n\t\treturn getDuplexType(value, optionName);\n\t}\n\n\tif (isTransformStream(value.transform)) {\n\t\treturn getTransformStreamType(value, optionName);\n\t}\n\n\treturn getGeneratorObjectType(value, optionName);\n};\n\nconst getDuplexType = (value, optionName) => {\n\tvalidateNonGeneratorType(value, optionName, 'Duplex stream');\n\treturn 'duplex';\n};\n\nconst getTransformStreamType = (value, optionName) => {\n\tvalidateNonGeneratorType(value, optionName, 'web TransformStream');\n\treturn 'webTransform';\n};\n\nconst validateNonGeneratorType = ({final, binary, objectMode}, optionName, typeName) => {\n\tcheckUndefinedOption(final, `${optionName}.final`, typeName);\n\tcheckUndefinedOption(binary, `${optionName}.binary`, typeName);\n\tcheckBooleanOption(objectMode, `${optionName}.objectMode`);\n};\n\nconst checkUndefinedOption = (value, optionName, typeName) => {\n\tif (value !== undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option can only be defined when using a generator, not a ${typeName}.`);\n\t}\n};\n\nconst getGeneratorObjectType = ({transform, final, binary, objectMode}, optionName) => {\n\tif (transform !== undefined && !isGenerator(transform)) {\n\t\tthrow new TypeError(`The \\`${optionName}.transform\\` option must be a generator, a Duplex stream or a web TransformStream.`);\n\t}\n\n\tif (isDuplexStream(final, {checkOpen: false})) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must not be a Duplex stream.`);\n\t}\n\n\tif (isTransformStream(final)) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must not be a web TransformStream.`);\n\t}\n\n\tif (final !== undefined && !isGenerator(final)) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must be a generator.`);\n\t}\n\n\tcheckBooleanOption(binary, `${optionName}.binary`);\n\tcheckBooleanOption(objectMode, `${optionName}.objectMode`);\n\n\treturn isAsyncGenerator(transform) || isAsyncGenerator(final) ? 'asyncGenerator' : 'generator';\n};\n\nconst checkBooleanOption = (value, optionName) => {\n\tif (value !== undefined && typeof value !== 'boolean') {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must use a boolean.`);\n\t}\n};\n\nconst isGenerator = value => isAsyncGenerator(value) || isSyncGenerator(value);\nexport const isAsyncGenerator = value => Object.prototype.toString.call(value) === '[object AsyncGeneratorFunction]';\nconst isSyncGenerator = value => Object.prototype.toString.call(value) === '[object GeneratorFunction]';\nconst isTransformOptions = value => isPlainObj(value)\n\t&& (value.transform !== undefined || value.final !== undefined);\n\nexport const isUrl = value => Object.prototype.toString.call(value) === '[object URL]';\nexport const isRegularUrl = value => isUrl(value) && value.protocol !== 'file:';\n\nconst isFilePathObject = value => isPlainObj(value)\n\t&& Object.keys(value).length === 1\n\t&& isFilePathString(value.file);\nexport const isFilePathString = file => typeof file === 'string';\n\nexport const isUnknownStdioString = (type, value) => type === 'native'\n\t&& typeof value === 'string'\n\t&& !KNOWN_STDIO_STRINGS.has(value);\nconst KNOWN_STDIO_STRINGS = new Set(['ipc', 'ignore', 'inherit', 'overlapped', 'pipe']);\n\nconst isReadableStream = value => Object.prototype.toString.call(value) === '[object ReadableStream]';\nexport const isWritableStream = value => Object.prototype.toString.call(value) === '[object WritableStream]';\nconst isWebStream = value => isReadableStream(value) || isWritableStream(value);\nconst isTransformStream = value => isReadableStream(value?.readable) && isWritableStream(value?.writable);\n\nconst isAsyncIterableObject = value => isObject(value) && typeof value[Symbol.asyncIterator] === 'function';\nconst isIterableObject = value => isObject(value) && typeof value[Symbol.iterator] === 'function';\nconst isObject = value => typeof value === 'object' && value !== null;\n\n// Types which modify `subprocess.std*`\nexport const TRANSFORM_TYPES = new Set(['generator', 'asyncGenerator', 'duplex', 'webTransform']);\n// Types which write to a file or a file descriptor\nexport const FILE_TYPES = new Set(['fileUrl', 'filePath', 'fileNumber']);\n// When two file descriptors of this type share the same target, we need to do some special logic\nexport const SPECIAL_DUPLICATE_TYPES_SYNC = new Set(['fileUrl', 'filePath']);\nexport const SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, 'webStream', 'nodeStream']);\n// Do not allow two file descriptors of this type sharing the same target\nexport const FORBID_DUPLICATE_TYPES = new Set(['webTransform', 'duplex']);\n\n// Convert types to human-friendly strings for error messages\nexport const TYPE_TO_MESSAGE = {\n\tgenerator: 'a generator',\n\tasyncGenerator: 'an async generator',\n\tfileUrl: 'a file URL',\n\tfilePath: 'a file path string',\n\tfileNumber: 'a file descriptor number',\n\twebStream: 'a web stream',\n\tnodeStream: 'a Node.js stream',\n\twebTransform: 'a web TransformStream',\n\tduplex: 'a Duplex stream',\n\tnative: 'any value',\n\titerable: 'an iterable',\n\tasyncIterable: 'an async iterable',\n\tstring: 'a string',\n\tuint8Array: 'a Uint8Array',\n};\n", "import {TRANSFORM_TYPES} from '../stdio/type.js';\n\n/*\nRetrieve the `objectMode`s of a single transform.\n`objectMode` determines the return value's type, i.e. the `readableObjectMode`.\nThe chunk argument's type is based on the previous generator's return value, i.e. the `writableObjectMode` is based on the previous `readableObjectMode`.\nThe last input's generator is read by `subprocess.stdin` which:\n- should not be in `objectMode` for performance reasons.\n- can only be strings, Buffers and Uint8Arrays.\nTherefore its `readableObjectMode` must be `false`.\nThe same applies to the first output's generator's `writableObjectMode`.\n*/\nexport const getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === 'output'\n\t? getOutputObjectModes(objectMode, index, newTransforms)\n\t: getInputObjectModes(objectMode, index, newTransforms);\n\nconst getOutputObjectModes = (objectMode, index, newTransforms) => {\n\tconst writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;\n\tconst readableObjectMode = objectMode ?? writableObjectMode;\n\treturn {writableObjectMode, readableObjectMode};\n};\n\nconst getInputObjectModes = (objectMode, index, newTransforms) => {\n\tconst writableObjectMode = index === 0\n\t\t? objectMode === true\n\t\t: newTransforms[index - 1].value.readableObjectMode;\n\tconst readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);\n\treturn {writableObjectMode, readableObjectMode};\n};\n\n// Retrieve the `objectMode` of a file descriptor, e.g. `stdout` or `stderr`\nexport const getFdObjectMode = (stdioItems, direction) => {\n\tconst lastTransform = stdioItems.findLast(({type}) => TRANSFORM_TYPES.has(type));\n\tif (lastTransform === undefined) {\n\t\treturn false;\n\t}\n\n\treturn direction === 'input'\n\t\t? lastTransform.value.writableObjectMode\n\t\t: lastTransform.value.readableObjectMode;\n};\n", "import isPlainObj from 'is-plain-obj';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {getTransformObjectModes} from './object-mode.js';\n\n// Transforms generators/duplex/TransformStream can have multiple shapes.\n// This normalizes it and applies default values.\nexport const normalizeTransforms = (stdioItems, optionName, direction, options) => [\n\t...stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type)),\n\t...getTransforms(stdioItems, optionName, direction, options),\n];\n\nconst getTransforms = (stdioItems, optionName, direction, {encoding}) => {\n\tconst transforms = stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type));\n\tconst newTransforms = Array.from({length: transforms.length});\n\n\tfor (const [index, stdioItem] of Object.entries(transforms)) {\n\t\tnewTransforms[index] = normalizeTransform({\n\t\t\tstdioItem,\n\t\t\tindex: Number(index),\n\t\t\tnewTransforms,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t\tencoding,\n\t\t});\n\t}\n\n\treturn sortTransforms(newTransforms, direction);\n};\n\nconst normalizeTransform = ({stdioItem, stdioItem: {type}, index, newTransforms, optionName, direction, encoding}) => {\n\tif (type === 'duplex') {\n\t\treturn normalizeDuplex({stdioItem, optionName});\n\t}\n\n\tif (type === 'webTransform') {\n\t\treturn normalizeTransformStream({\n\t\t\tstdioItem,\n\t\t\tindex,\n\t\t\tnewTransforms,\n\t\t\tdirection,\n\t\t});\n\t}\n\n\treturn normalizeGenerator({\n\t\tstdioItem,\n\t\tindex,\n\t\tnewTransforms,\n\t\tdirection,\n\t\tencoding,\n\t});\n};\n\nconst normalizeDuplex = ({\n\tstdioItem,\n\tstdioItem: {\n\t\tvalue: {\n\t\t\ttransform,\n\t\t\ttransform: {writableObjectMode, readableObjectMode},\n\t\t\tobjectMode = readableObjectMode,\n\t\t},\n\t},\n\toptionName,\n}) => {\n\tif (objectMode && !readableObjectMode) {\n\t\tthrow new TypeError(`The \\`${optionName}.objectMode\\` option can only be \\`true\\` if \\`new Duplex({objectMode: true})\\` is used.`);\n\t}\n\n\tif (!objectMode && readableObjectMode) {\n\t\tthrow new TypeError(`The \\`${optionName}.objectMode\\` option cannot be \\`false\\` if \\`new Duplex({objectMode: true})\\` is used.`);\n\t}\n\n\treturn {\n\t\t...stdioItem,\n\t\tvalue: {transform, writableObjectMode, readableObjectMode},\n\t};\n};\n\nconst normalizeTransformStream = ({stdioItem, stdioItem: {value}, index, newTransforms, direction}) => {\n\tconst {transform, objectMode} = isPlainObj(value) ? value : {transform: value};\n\tconst {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);\n\treturn ({\n\t\t...stdioItem,\n\t\tvalue: {transform, writableObjectMode, readableObjectMode},\n\t});\n};\n\nconst normalizeGenerator = ({stdioItem, stdioItem: {value}, index, newTransforms, direction, encoding}) => {\n\tconst {\n\t\ttransform,\n\t\tfinal,\n\t\tbinary: binaryOption = false,\n\t\tpreserveNewlines = false,\n\t\tobjectMode,\n\t} = isPlainObj(value) ? value : {transform: value};\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);\n\treturn {\n\t\t...stdioItem,\n\t\tvalue: {\n\t\t\ttransform,\n\t\t\tfinal,\n\t\t\tbinary,\n\t\t\tpreserveNewlines,\n\t\t\twritableObjectMode,\n\t\t\treadableObjectMode,\n\t\t},\n\t};\n};\n\nconst sortTransforms = (newTransforms, direction) => direction === 'input' ? newTransforms.reverse() : newTransforms;\n", "import process from 'node:process';\nimport {\n\tisStream as isNodeStream,\n\tisReadableStream as isNodeReadableStream,\n\tisWritableStream as isNodeWritableStream,\n} from 'is-stream';\nimport {isWritableStream} from './type.js';\n\n// For `stdio[fdNumber]` beyond stdin/stdout/stderr, we need to guess whether the value passed is intended for inputs or outputs.\n// This allows us to know whether to pipe _into_ or _from_ the stream.\n// When `stdio[fdNumber]` is a single value, this guess is fairly straightforward.\n// However, when it is an array instead, we also need to make sure the different values are not incompatible with each other.\nexport const getStreamDirection = (stdioItems, fdNumber, optionName) => {\n\tconst directions = stdioItems.map(stdioItem => getStdioItemDirection(stdioItem, fdNumber));\n\n\tif (directions.includes('input') && directions.includes('output')) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must not be an array of both readable and writable values.`);\n\t}\n\n\treturn directions.find(Boolean) ?? DEFAULT_DIRECTION;\n};\n\nconst getStdioItemDirection = ({type, value}, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);\n\n// `stdin`/`stdout`/`stderr` have a known direction\nconst KNOWN_DIRECTIONS = ['input', 'output', 'output'];\n\nconst anyDirection = () => undefined;\nconst alwaysInput = () => 'input';\n\n// `string` can only be added through the `input` option, i.e. does not need to be handled here\nconst guessStreamDirection = {\n\tgenerator: anyDirection,\n\tasyncGenerator: anyDirection,\n\tfileUrl: anyDirection,\n\tfilePath: anyDirection,\n\titerable: alwaysInput,\n\tasyncIterable: alwaysInput,\n\tuint8Array: alwaysInput,\n\twebStream: value => isWritableStream(value) ? 'output' : 'input',\n\tnodeStream(value) {\n\t\tif (!isNodeReadableStream(value, {checkOpen: false})) {\n\t\t\treturn 'output';\n\t\t}\n\n\t\treturn isNodeWritableStream(value, {checkOpen: false}) ? undefined : 'input';\n\t},\n\twebTransform: anyDirection,\n\tduplex: anyDirection,\n\tnative(value) {\n\t\tconst standardStreamDirection = getStandardStreamDirection(value);\n\t\tif (standardStreamDirection !== undefined) {\n\t\t\treturn standardStreamDirection;\n\t\t}\n\n\t\tif (isNodeStream(value, {checkOpen: false})) {\n\t\t\treturn guessStreamDirection.nodeStream(value);\n\t\t}\n\t},\n};\n\nconst getStandardStreamDirection = value => {\n\tif ([0, process.stdin].includes(value)) {\n\t\treturn 'input';\n\t}\n\n\tif ([1, 2, process.stdout, process.stderr].includes(value)) {\n\t\treturn 'output';\n\t}\n};\n\n// When ambiguous, we initially keep the direction as `undefined`.\n// This allows arrays of `stdio` values to resolve the ambiguity.\n// For example, `stdio[3]: DuplexStream` is ambiguous, but `stdio[3]: [DuplexStream, WritableStream]` is not.\n// When the ambiguity remains, we default to `output` since it is the most common use case for additional file descriptors.\nconst DEFAULT_DIRECTION = 'output';\n", "// The `ipc` option adds an `ipc` item to the `stdio` option\nexport const normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes('ipc')\n\t? [...stdioArray, 'ipc']\n\t: stdioArray;\n", "import {STANDARD_STREAMS_ALIASES} from '../utils/standard-stream.js';\nimport {normalizeIpcStdioArray} from '../ipc/array.js';\nimport {isFullVerbose} from '../verbose/values.js';\n\n// Add support for `stdin`/`stdout`/`stderr` as an alias for `stdio`.\n// Also normalize the `stdio` option.\nexport const normalizeStdioOption = ({stdio, ipc, buffer, ...options}, verboseInfo, isSync) => {\n\tconst stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue(stdioOption, fdNumber));\n\treturn isSync\n\t\t? normalizeStdioSync(stdioArray, buffer, verboseInfo)\n\t\t: normalizeIpcStdioArray(stdioArray, ipc);\n};\n\nconst getStdioArray = (stdio, options) => {\n\tif (stdio === undefined) {\n\t\treturn STANDARD_STREAMS_ALIASES.map(alias => options[alias]);\n\t}\n\n\tif (hasAlias(options)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${STANDARD_STREAMS_ALIASES.map(alias => `\\`${alias}\\``).join(', ')}`);\n\t}\n\n\tif (typeof stdio === 'string') {\n\t\treturn [stdio, stdio, stdio];\n\t}\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);\n\treturn Array.from({length}, (_, fdNumber) => stdio[fdNumber]);\n};\n\nconst hasAlias = options => STANDARD_STREAMS_ALIASES.some(alias => options[alias] !== undefined);\n\nconst addDefaultValue = (stdioOption, fdNumber) => {\n\tif (Array.isArray(stdioOption)) {\n\t\treturn stdioOption.map(item => addDefaultValue(item, fdNumber));\n\t}\n\n\tif (stdioOption === null || stdioOption === undefined) {\n\t\treturn fdNumber >= STANDARD_STREAMS_ALIASES.length ? 'ignore' : 'pipe';\n\t}\n\n\treturn stdioOption;\n};\n\n// Using `buffer: false` with synchronous methods implies `stdout`/`stderr`: `ignore`.\n// Unless the output is needed, e.g. due to `verbose: 'full'` or to redirecting to a file.\nconst normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) =>\n\t!buffer[fdNumber]\n\t&& fdNumber !== 0\n\t&& !isFullVerbose(verboseInfo, fdNumber)\n\t&& isOutputPipeOnly(stdioOption)\n\t\t? 'ignore'\n\t\t: stdioOption);\n\nconst isOutputPipeOnly = stdioOption => stdioOption === 'pipe'\n\t|| (Array.isArray(stdioOption) && stdioOption.every(item => item === 'pipe'));\n", "import {readFileSync} from 'node:fs';\nimport tty from 'node:tty';\nimport {isStream as isNodeStream} from 'is-stream';\nimport {STANDARD_STREAMS} from '../utils/standard-stream.js';\nimport {bufferToUint8Array} from '../utils/uint-array.js';\nimport {serializeOptionValue} from '../arguments/fd-options.js';\n\n// When we use multiple `stdio` values for the same streams, we pass 'pipe' to `child_process.spawn()`.\n// We then emulate the piping done by core Node.js.\n// To do so, we transform the following values:\n//  - Node.js streams are marked as `type: nodeStream`\n//  - 'inherit' becomes `process.stdin|stdout|stderr`\n//  - any file descriptor integer becomes `process.stdio[fdNumber]`\n// All of the above transformations tell Execa to perform manual piping.\nexport const handleNativeStream = ({stdioItem, stdioItem: {type}, isStdioArray, fdNumber, direction, isSync}) => {\n\tif (!isStdioArray || type !== 'native') {\n\t\treturn stdioItem;\n\t}\n\n\treturn isSync\n\t\t? handleNativeStreamSync({stdioItem, fdNumber, direction})\n\t\t: handleNativeStreamAsync({stdioItem, fdNumber});\n};\n\n// Synchronous methods use a different logic.\n// 'inherit', file descriptors and process.std* are handled by readFileSync()/writeFileSync().\nconst handleNativeStreamSync = ({stdioItem, stdioItem: {value, optionName}, fdNumber, direction}) => {\n\tconst targetFd = getTargetFd({\n\t\tvalue,\n\t\toptionName,\n\t\tfdNumber,\n\t\tdirection,\n\t});\n\tif (targetFd !== undefined) {\n\t\treturn targetFd;\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\tthrow new TypeError(`The \\`${optionName}: Stream\\` option cannot both be an array and include a stream with synchronous methods.`);\n\t}\n\n\treturn stdioItem;\n};\n\nconst getTargetFd = ({value, optionName, fdNumber, direction}) => {\n\tconst targetFdNumber = getTargetFdNumber(value, fdNumber);\n\tif (targetFdNumber === undefined) {\n\t\treturn;\n\t}\n\n\tif (direction === 'output') {\n\t\treturn {type: 'fileNumber', value: targetFdNumber, optionName};\n\t}\n\n\tif (tty.isatty(targetFdNumber)) {\n\t\tthrow new TypeError(`The \\`${optionName}: ${serializeOptionValue(value)}\\` option is invalid: it cannot be a TTY with synchronous methods.`);\n\t}\n\n\treturn {type: 'uint8Array', value: bufferToUint8Array(readFileSync(targetFdNumber)), optionName};\n};\n\nconst getTargetFdNumber = (value, fdNumber) => {\n\tif (value === 'inherit') {\n\t\treturn fdNumber;\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn value;\n\t}\n\n\tconst standardStreamIndex = STANDARD_STREAMS.indexOf(value);\n\tif (standardStreamIndex !== -1) {\n\t\treturn standardStreamIndex;\n\t}\n};\n\nconst handleNativeStreamAsync = ({stdioItem, stdioItem: {value, optionName}, fdNumber}) => {\n\tif (value === 'inherit') {\n\t\treturn {type: 'nodeStream', value: getStandardStream(fdNumber, value, optionName), optionName};\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn {type: 'nodeStream', value: getStandardStream(value, value, optionName), optionName};\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\treturn {type: 'nodeStream', value, optionName};\n\t}\n\n\treturn stdioItem;\n};\n\n// Node.js does not allow to easily retrieve file descriptors beyond stdin/stdout/stderr as streams.\n//  - `fs.createReadStream()`/`fs.createWriteStream()` with the `fd` option do not work with character devices that use blocking reads/writes (such as interactive TTYs).\n//  - Using a TCP `Socket` would work but be rather complex to implement.\n// Since this is an edge case, we simply throw an error message.\n// See https://github.com/sindresorhus/execa/pull/643#discussion_r1435905707\nconst getStandardStream = (fdNumber, value, optionName) => {\n\tconst standardStream = STANDARD_STREAMS[fdNumber];\n\n\tif (standardStream === undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}: ${value}\\` option is invalid: no such standard stream.`);\n\t}\n\n\treturn standardStream;\n};\n", "import {isReadableStream} from 'is-stream';\nimport {isUint8Array} from '../utils/uint-array.js';\nimport {isUrl, isFilePathString} from './type.js';\n\n// Append the `stdin` option with the `input` and `inputFile` options\nexport const handleInputOptions = ({input, inputFile}, fdNumber) => fdNumber === 0\n\t? [\n\t\t...handleInputOption(input),\n\t\t...handleInputFileOption(inputFile),\n\t]\n\t: [];\n\nconst handleInputOption = input => input === undefined ? [] : [{\n\ttype: getInputType(input),\n\tvalue: input,\n\toptionName: 'input',\n}];\n\nconst getInputType = input => {\n\tif (isReadableStream(input, {checkOpen: false})) {\n\t\treturn 'nodeStream';\n\t}\n\n\tif (typeof input === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (isUint8Array(input)) {\n\t\treturn 'uint8Array';\n\t}\n\n\tthrow new Error('The `input` option must be a string, a Uint8Array or a Node.js Readable stream.');\n};\n\nconst handleInputFileOption = inputFile => inputFile === undefined ? [] : [{\n\t...getInputFileType(inputFile),\n\toptionName: 'inputFile',\n}];\n\nconst getInputFileType = inputFile => {\n\tif (isUrl(inputFile)) {\n\t\treturn {type: 'fileUrl', value: inputFile};\n\t}\n\n\tif (isFilePathString(inputFile)) {\n\t\treturn {type: 'filePath', value: {file: inputFile}};\n\t}\n\n\tthrow new Error('The `inputFile` option must be a file path string or a file URL.');\n};\n", "import {\n\tSPECIAL_DUPLICATE_TYPES_SYNC,\n\tSPECIAL_DUPLICATE_TYPES,\n\tFORBID_DUPLICATE_TYPES,\n\tTYPE_TO_MESSAGE,\n} from './type.js';\n\n// Duplicates in the same file descriptor is most likely an error.\n// However, this can be useful with generators.\nexport const filterDuplicates = stdioItems => stdioItems.filter((stdioItemOne, indexOne) =>\n\tstdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value\n\t\t|| indexOne >= indexTwo\n\t\t|| stdioItemOne.type === 'generator'\n\t\t|| stdioItemOne.type === 'asyncGenerator'));\n\n// Check if two file descriptors are sharing the same target.\n// For example `{stdout: {file: './output.txt'}, stderr: {file: './output.txt'}}`.\nexport const getDuplicateStream = ({stdioItem: {type, value, optionName}, direction, fileDescriptors, isSync}) => {\n\tconst otherStdioItems = getOtherStdioItems(fileDescriptors, type);\n\tif (otherStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tif (isSync) {\n\t\tvalidateDuplicateStreamSync({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t\treturn;\n\t}\n\n\tif (SPECIAL_DUPLICATE_TYPES.has(type)) {\n\t\treturn getDuplicateStreamInstance({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t}\n\n\tif (FORBID_DUPLICATE_TYPES.has(type)) {\n\t\tvalidateDuplicateTransform({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t});\n\t}\n};\n\n// Values shared by multiple file descriptors\nconst getOtherStdioItems = (fileDescriptors, type) => fileDescriptors\n\t.flatMap(({direction, stdioItems}) => stdioItems\n\t\t.filter(stdioItem => stdioItem.type === type)\n\t\t.map((stdioItem => ({...stdioItem, direction}))));\n\n// With `execaSync()`, do not allow setting a file path both in input and output\nconst validateDuplicateStreamSync = ({otherStdioItems, type, value, optionName, direction}) => {\n\tif (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) {\n\t\tgetDuplicateStreamInstance({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t}\n};\n\n// When two file descriptors share the file or stream, we need to re-use the same underlying stream.\n// Otherwise, the stream would be closed twice when piping ends.\n// This is only an issue with output file descriptors.\n// This is not a problem with generator functions since those create a new instance for each file descriptor.\n// We also forbid input and output file descriptors sharing the same file or stream, since that does not make sense.\nconst getDuplicateStreamInstance = ({otherStdioItems, type, value, optionName, direction}) => {\n\tconst duplicateStdioItems = otherStdioItems.filter(stdioItem => hasSameValue(stdioItem, value));\n\tif (duplicateStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tconst differentStdioItem = duplicateStdioItems.find(stdioItem => stdioItem.direction !== direction);\n\tthrowOnDuplicateStream(differentStdioItem, optionName, type);\n\n\treturn direction === 'output' ? duplicateStdioItems[0].stream : undefined;\n};\n\nconst hasSameValue = ({type, value}, secondValue) => {\n\tif (type === 'filePath') {\n\t\treturn value.file === secondValue.file;\n\t}\n\n\tif (type === 'fileUrl') {\n\t\treturn value.href === secondValue.href;\n\t}\n\n\treturn value === secondValue;\n};\n\n// We do not allow two file descriptors to share the same Duplex or TransformStream.\n// This is because those are set directly to `subprocess.std*`.\n// For example, this could result in `subprocess.stdout` and `subprocess.stderr` being the same value.\n// This means reading from either would get data from both stdout and stderr.\nconst validateDuplicateTransform = ({otherStdioItems, type, value, optionName}) => {\n\tconst duplicateStdioItem = otherStdioItems.find(({value: {transform}}) => transform === value.transform);\n\tthrowOnDuplicateStream(duplicateStdioItem, optionName, type);\n};\n\nconst throwOnDuplicateStream = (stdioItem, optionName, type) => {\n\tif (stdioItem !== undefined) {\n\t\tthrow new TypeError(`The \\`${stdioItem.optionName}\\` and \\`${optionName}\\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);\n\t}\n};\n", "import {getStreamName, isStandardStream} from '../utils/standard-stream.js';\nimport {normalizeTransforms} from '../transform/normalize.js';\nimport {getFdObjectMode} from '../transform/object-mode.js';\nimport {\n\tgetStdioItemType,\n\tisRegularUrl,\n\tisUnknownStdioString,\n\tFILE_TYPES,\n} from './type.js';\nimport {getStreamDirection} from './direction.js';\nimport {normalizeStdioOption} from './stdio-option.js';\nimport {handleNativeStream} from './native.js';\nimport {handleInputOptions} from './input-option.js';\nimport {filterDuplicates, getDuplicateStream} from './duplicate.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async/sync mode\n// They are converted into an array of `fileDescriptors`.\n// Each `fileDescriptor` is normalized, validated and contains all information necessary for further handling.\nexport const handleStdio = (addProperties, options, verboseInfo, isSync) => {\n\tconst stdio = normalizeStdioOption(options, verboseInfo, isSync);\n\tconst initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({\n\t\tstdioOption,\n\t\tfdNumber,\n\t\toptions,\n\t\tisSync,\n\t}));\n\tconst fileDescriptors = getFinalFileDescriptors({\n\t\tinitialFileDescriptors,\n\t\taddProperties,\n\t\toptions,\n\t\tisSync,\n\t});\n\toptions.stdio = fileDescriptors.map(({stdioItems}) => forwardStdio(stdioItems));\n\treturn fileDescriptors;\n};\n\nconst getFileDescriptor = ({stdioOption, fdNumber, options, isSync}) => {\n\tconst optionName = getStreamName(fdNumber);\n\tconst {stdioItems: initialStdioItems, isStdioArray} = initializeStdioItems({\n\t\tstdioOption,\n\t\tfdNumber,\n\t\toptions,\n\t\toptionName,\n\t});\n\tconst direction = getStreamDirection(initialStdioItems, fdNumber, optionName);\n\tconst stdioItems = initialStdioItems.map(stdioItem => handleNativeStream({\n\t\tstdioItem,\n\t\tisStdioArray,\n\t\tfdNumber,\n\t\tdirection,\n\t\tisSync,\n\t}));\n\tconst normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);\n\tconst objectMode = getFdObjectMode(normalizedStdioItems, direction);\n\tvalidateFileObjectMode(normalizedStdioItems, objectMode);\n\treturn {direction, objectMode, stdioItems: normalizedStdioItems};\n};\n\n// We make sure passing an array with a single item behaves the same as passing that item without an array.\n// This is what users would expect.\n// For example, `stdout: ['ignore']` behaves the same as `stdout: 'ignore'`.\nconst initializeStdioItems = ({stdioOption, fdNumber, options, optionName}) => {\n\tconst values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];\n\tconst initialStdioItems = [\n\t\t...values.map(value => initializeStdioItem(value, optionName)),\n\t\t...handleInputOptions(options, fdNumber),\n\t];\n\n\tconst stdioItems = filterDuplicates(initialStdioItems);\n\tconst isStdioArray = stdioItems.length > 1;\n\tvalidateStdioArray(stdioItems, isStdioArray, optionName);\n\tvalidateStreams(stdioItems);\n\treturn {stdioItems, isStdioArray};\n};\n\nconst initializeStdioItem = (value, optionName) => ({\n\ttype: getStdioItemType(value, optionName),\n\tvalue,\n\toptionName,\n});\n\nconst validateStdioArray = (stdioItems, isStdioArray, optionName) => {\n\tif (stdioItems.length === 0) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must not be an empty array.`);\n\t}\n\n\tif (!isStdioArray) {\n\t\treturn;\n\t}\n\n\tfor (const {value, optionName} of stdioItems) {\n\t\tif (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {\n\t\t\tthrow new Error(`The \\`${optionName}\\` option must not include \\`${value}\\`.`);\n\t\t}\n\t}\n};\n\n// Using those `stdio` values together with others for the same stream does not make sense, so we make it fail.\n// However, we do allow it if the array has a single item.\nconst INVALID_STDIO_ARRAY_OPTIONS = new Set(['ignore', 'ipc']);\n\nconst validateStreams = stdioItems => {\n\tfor (const stdioItem of stdioItems) {\n\t\tvalidateFileStdio(stdioItem);\n\t}\n};\n\nconst validateFileStdio = ({type, value, optionName}) => {\n\tif (isRegularUrl(value)) {\n\t\tthrow new TypeError(`The \\`${optionName}: URL\\` option must use the \\`file:\\` scheme.\nFor example, you can use the \\`pathToFileURL()\\` method of the \\`url\\` core module.`);\n\t}\n\n\tif (isUnknownStdioString(type, value)) {\n\t\tthrow new TypeError(`The \\`${optionName}: { file: '...' }\\` option must be used instead of \\`${optionName}: '...'\\`.`);\n\t}\n};\n\nconst validateFileObjectMode = (stdioItems, objectMode) => {\n\tif (!objectMode) {\n\t\treturn;\n\t}\n\n\tconst fileStdioItem = stdioItems.find(({type}) => FILE_TYPES.has(type));\n\tif (fileStdioItem !== undefined) {\n\t\tthrow new TypeError(`The \\`${fileStdioItem.optionName}\\` option cannot use both files and transforms in objectMode.`);\n\t}\n};\n\n// Some `stdio` values require Execa to create streams.\n// For example, file paths create file read/write streams.\n// Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.\nconst getFinalFileDescriptors = ({initialFileDescriptors, addProperties, options, isSync}) => {\n\tconst fileDescriptors = [];\n\n\ttry {\n\t\tfor (const fileDescriptor of initialFileDescriptors) {\n\t\t\tfileDescriptors.push(getFinalFileDescriptor({\n\t\t\t\tfileDescriptor,\n\t\t\t\tfileDescriptors,\n\t\t\t\taddProperties,\n\t\t\t\toptions,\n\t\t\t\tisSync,\n\t\t\t}));\n\t\t}\n\n\t\treturn fileDescriptors;\n\t} catch (error) {\n\t\tcleanupCustomStreams(fileDescriptors);\n\t\tthrow error;\n\t}\n};\n\nconst getFinalFileDescriptor = ({\n\tfileDescriptor: {direction, objectMode, stdioItems},\n\tfileDescriptors,\n\taddProperties,\n\toptions,\n\tisSync,\n}) => {\n\tconst finalStdioItems = stdioItems.map(stdioItem => addStreamProperties({\n\t\tstdioItem,\n\t\taddProperties,\n\t\tdirection,\n\t\toptions,\n\t\tfileDescriptors,\n\t\tisSync,\n\t}));\n\treturn {direction, objectMode, stdioItems: finalStdioItems};\n};\n\nconst addStreamProperties = ({stdioItem, addProperties, direction, options, fileDescriptors, isSync}) => {\n\tconst duplicateStream = getDuplicateStream({\n\t\tstdioItem,\n\t\tdirection,\n\t\tfileDescriptors,\n\t\tisSync,\n\t});\n\n\tif (duplicateStream !== undefined) {\n\t\treturn {...stdioItem, stream: duplicateStream};\n\t}\n\n\treturn {\n\t\t...stdioItem,\n\t\t...addProperties[direction][stdioItem.type](stdioItem, options),\n\t};\n};\n\n// The stream error handling is performed by the piping logic above, which cannot be performed before subprocess spawning.\n// If the subprocess spawning fails (e.g. due to an invalid command), the streams need to be manually destroyed.\n// We need to create those streams before subprocess spawning, in case their creation fails, e.g. when passing an invalid generator as argument.\n// Like this, an exception would be thrown, which would prevent spawning a subprocess.\nexport const cleanupCustomStreams = fileDescriptors => {\n\tfor (const {stdioItems} of fileDescriptors) {\n\t\tfor (const {stream} of stdioItems) {\n\t\t\tif (stream !== undefined && !isStandardStream(stream)) {\n\t\t\t\tstream.destroy();\n\t\t\t}\n\t\t}\n\t}\n};\n\n// When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `subprocess.std*`.\n// When the `std*: Array` option is used, we emulate some of the native values ('inherit', Node.js stream and file descriptor integer). To do so, we also need to pipe to `subprocess.std*`.\n// Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `subprocess.std*`.\nconst forwardStdio = stdioItems => {\n\tif (stdioItems.length > 1) {\n\t\treturn stdioItems.some(({value}) => value === 'overlapped') ? 'overlapped' : 'pipe';\n\t}\n\n\tconst [{type, value}] = stdioItems;\n\treturn type === 'native' ? value : 'pipe';\n};\n", "import stripFinalNewlineFunction from 'strip-final-newline';\n\n// Apply `stripFinalNewline` option, which applies to `result.stdout|stderr|all|stdio[*]`.\n// If the `lines` option is used, it is applied on each line, but using a different function.\nexport const stripNewline = (value, {stripFinalNewline}, fdNumber) => getStripFinalNewline(stripFinalNewline, fdNumber) && value !== undefined && !Array.isArray(value)\n\t? stripFinalNewlineFunction(value)\n\t: value;\n\n// Retrieve `stripFinalNewline` option value, including with `subprocess.all`\nexport const getStripFinalNewline = (stripFinalNewline, fdNumber) => fdNumber === 'all'\n\t? stripFinalNewline[1] || stripFinalNewline[2]\n\t: stripFinalNewline[fdNumber];\n", "import {Transform, getDefaultHighWaterMark} from 'node:stream';\nimport {isAsyncGenerator} from '../stdio/type.js';\nimport {getSplitLinesGenerator, getAppendNewlineGenerator} from './split.js';\nimport {getValidateTransformInput, getValidateTransformReturn} from './validate.js';\nimport {getEncodingTransformGenerator} from './encoding-transform.js';\nimport {\n\tpushChunks,\n\ttransformChunk,\n\tfinalChunks,\n\tdestroyTransform,\n} from './run-async.js';\nimport {\n\tpushChunksSync,\n\ttransformChunkSync,\n\tfinalChunksSync,\n\trunTransformSync,\n} from './run-sync.js';\n\n/*\nGenerators can be used to transform/filter standard streams.\n\nGenerators have a simple syntax, yet allows all of the following:\n- Sharing `state` between chunks\n- Flushing logic, by using a `final` function\n- Asynchronous logic\n- Emitting multiple chunks from a single source chunk, even if spaced in time, by using multiple `yield`\n- Filtering, by using no `yield`\n\nTherefore, there is no need to allow Node.js or web transform streams.\n\nThe `highWaterMark` is kept as the default value, since this is what `subprocess.std*` uses.\n\nChunks are currently processed serially. We could add a `concurrency` option to parallelize in the future.\n\nTransform an array of generator functions into a `Transform` stream.\n`Duplex.from(generator)` cannot be used because it does not allow setting the `objectMode` and `highWaterMark`.\n*/\nexport const generatorToStream = ({\n\tvalue,\n\tvalue: {transform, final, writableObjectMode, readableObjectMode},\n\toptionName,\n}, {encoding}) => {\n\tconst state = {};\n\tconst generators = addInternalGenerators(value, encoding, optionName);\n\n\tconst transformAsync = isAsyncGenerator(transform);\n\tconst finalAsync = isAsyncGenerator(final);\n\tconst transformMethod = transformAsync\n\t\t? pushChunks.bind(undefined, transformChunk, state)\n\t\t: pushChunksSync.bind(undefined, transformChunkSync);\n\tconst finalMethod = transformAsync || finalAsync\n\t\t? pushChunks.bind(undefined, finalChunks, state)\n\t\t: pushChunksSync.bind(undefined, finalChunksSync);\n\tconst destroyMethod = transformAsync || finalAsync\n\t\t? destroyTransform.bind(undefined, state)\n\t\t: undefined;\n\n\tconst stream = new Transform({\n\t\twritableObjectMode,\n\t\twritableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),\n\t\treadableObjectMode,\n\t\treadableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),\n\t\ttransform(chunk, encoding, done) {\n\t\t\ttransformMethod([chunk, generators, 0], this, done);\n\t\t},\n\t\tflush(done) {\n\t\t\tfinalMethod([generators], this, done);\n\t\t},\n\t\tdestroy: destroyMethod,\n\t});\n\treturn {stream};\n};\n\n// Applies transform generators in sync mode\nexport const runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {\n\tconst generators = stdioItems.filter(({type}) => type === 'generator');\n\tconst reversedGenerators = isInput ? generators.reverse() : generators;\n\n\tfor (const {value, optionName} of reversedGenerators) {\n\t\tconst generators = addInternalGenerators(value, encoding, optionName);\n\t\tchunks = runTransformSync(generators, chunks);\n\t}\n\n\treturn chunks;\n};\n\n// Generators used internally to convert the chunk type, validate it, and split into lines\nconst addInternalGenerators = (\n\t{transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines},\n\tencoding,\n\toptionName,\n) => {\n\tconst state = {};\n\treturn [\n\t\t{transform: getValidateTransformInput(writableObjectMode, optionName)},\n\t\tgetEncodingTransformGenerator(binary, encoding, writableObjectMode),\n\t\tgetSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),\n\t\t{transform, final},\n\t\t{transform: getValidateTransformReturn(readableObjectMode, optionName)},\n\t\tgetAppendNewlineGenerator({\n\t\t\tbinary,\n\t\t\tpreserveNewlines,\n\t\t\treadableObjectMode,\n\t\t\tstate,\n\t\t}),\n\t].filter(Boolean);\n};\n", "// Split chunks line-wise for generators passed to the `std*` options\nexport const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped\n\t? undefined\n\t: initializeSplitLines(preserveNewlines, state);\n\n// Same but for synchronous methods\nexport const splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode\n\t? chunk.flatMap(item => splitLinesItemSync(item, preserveNewlines))\n\t: splitLinesItemSync(chunk, preserveNewlines);\n\nconst splitLinesItemSync = (chunk, preserveNewlines) => {\n\tconst {transform, final} = initializeSplitLines(preserveNewlines, {});\n\treturn [...transform(chunk), ...final()];\n};\n\nconst initializeSplitLines = (preserveNewlines, state) => {\n\tstate.previousChunks = '';\n\treturn {\n\t\ttransform: splitGenerator.bind(undefined, state, preserveNewlines),\n\t\tfinal: linesFinal.bind(undefined, state),\n\t};\n};\n\n// This imperative logic is much faster than using `String.split()` and uses very low memory.\nconst splitGenerator = function * (state, preserveNewlines, chunk) {\n\tif (typeof chunk !== 'string') {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tlet {previousChunks} = state;\n\tlet start = -1;\n\n\tfor (let end = 0; end < chunk.length; end += 1) {\n\t\tif (chunk[end] === '\\n') {\n\t\t\tconst newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);\n\t\t\tlet line = chunk.slice(start + 1, end + 1 - newlineLength);\n\n\t\t\tif (previousChunks.length > 0) {\n\t\t\t\tline = concatString(previousChunks, line);\n\t\t\t\tpreviousChunks = '';\n\t\t\t}\n\n\t\t\tyield line;\n\t\t\tstart = end;\n\t\t}\n\t}\n\n\tif (start !== chunk.length - 1) {\n\t\tpreviousChunks = concatString(previousChunks, chunk.slice(start + 1));\n\t}\n\n\tstate.previousChunks = previousChunks;\n};\n\nconst getNewlineLength = (chunk, end, preserveNewlines, state) => {\n\tif (preserveNewlines) {\n\t\treturn 0;\n\t}\n\n\tstate.isWindowsNewline = end !== 0 && chunk[end - 1] === '\\r';\n\treturn state.isWindowsNewline ? 2 : 1;\n};\n\nconst linesFinal = function * ({previousChunks}) {\n\tif (previousChunks.length > 0) {\n\t\tyield previousChunks;\n\t}\n};\n\n// Unless `preserveNewlines: true` is used, we strip the newline of each line.\n// This re-adds them after the user `transform` code has run.\nexport const getAppendNewlineGenerator = ({binary, preserveNewlines, readableObjectMode, state}) => binary || preserveNewlines || readableObjectMode\n\t? undefined\n\t: {transform: appendNewlineGenerator.bind(undefined, state)};\n\nconst appendNewlineGenerator = function * ({isWindowsNewline = false}, chunk) {\n\tconst {unixNewline, windowsNewline, LF, concatBytes} = typeof chunk === 'string' ? linesStringInfo : linesUint8ArrayInfo;\n\n\tif (chunk.at(-1) === LF) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst newline = isWindowsNewline ? windowsNewline : unixNewline;\n\tyield concatBytes(chunk, newline);\n};\n\nconst concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;\n\nconst linesStringInfo = {\n\twindowsNewline: '\\r\\n',\n\tunixNewline: '\\n',\n\tLF: '\\n',\n\tconcatBytes: concatString,\n};\n\nconst concatUint8Array = (firstChunk, secondChunk) => {\n\tconst chunk = new Uint8Array(firstChunk.length + secondChunk.length);\n\tchunk.set(firstChunk, 0);\n\tchunk.set(secondChunk, firstChunk.length);\n\treturn chunk;\n};\n\nconst linesUint8ArrayInfo = {\n\twindowsNewline: new Uint8Array([0x0D, 0x0A]),\n\tunixNewline: new Uint8Array([0x0A]),\n\tLF: 0x0A,\n\tconcatBytes: concatUint8Array,\n};\n", "import {Buffer} from 'node:buffer';\nimport {isUint8Array} from '../utils/uint-array.js';\n\n// Validate the type of chunk argument passed to transform generators\nexport const getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode\n\t? undefined\n\t: validateStringTransformInput.bind(undefined, optionName);\n\nconst validateStringTransformInput = function * (optionName, chunk) {\n\tif (typeof chunk !== 'string' && !isUint8Array(chunk) && !Buffer.isBuffer(chunk)) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's transform must use \"objectMode: true\" to receive as input: ${typeof chunk}.`);\n\t}\n\n\tyield chunk;\n};\n\n// Validate the type of the value returned by transform generators\nexport const getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode\n\t? validateObjectTransformReturn.bind(undefined, optionName)\n\t: validateStringTransformReturn.bind(undefined, optionName);\n\nconst validateObjectTransformReturn = function * (optionName, chunk) {\n\tvalidateEmptyReturn(optionName, chunk);\n\tyield chunk;\n};\n\nconst validateStringTransformReturn = function * (optionName, chunk) {\n\tvalidateEmptyReturn(optionName, chunk);\n\n\tif (typeof chunk !== 'string' && !isUint8Array(chunk)) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);\n\t}\n\n\tyield chunk;\n};\n\nconst validateEmptyReturn = (optionName, chunk) => {\n\tif (chunk === null || chunk === undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's function must not call \\`yield ${chunk}\\`.\nInstead, \\`yield\\` should either be called with a value, or not be called at all. For example:\n  if (condition) { yield value; }`);\n\t}\n};\n", "import {Buffer} from 'node:buffer';\nimport {StringDecoder} from 'node:string_decoder';\nimport {isUint8Array, bufferToUint8Array} from '../utils/uint-array.js';\n\n/*\nWhen using binary encodings, add an internal generator that converts chunks from `Buffer` to `string` or `Uint8Array`.\nChunks might be Buffer, Uint8Array or strings since:\n- `subprocess.stdout|stderr` emits Buffers\n- `subprocess.stdin.write()` accepts Buffer, Uint8Array or string\n- Previous generators might return Uint8Array or string\n\nHowever, those are converted to Buffer:\n- on writes: `Duplex.writable` `decodeStrings: true` default option\n- on reads: `Duplex.readable` `readableEncoding: null` default option\n*/\nexport const getEncodingTransformGenerator = (binary, encoding, skipped) => {\n\tif (skipped) {\n\t\treturn;\n\t}\n\n\tif (binary) {\n\t\treturn {transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder())};\n\t}\n\n\tconst stringDecoder = new StringDecoder(encoding);\n\treturn {\n\t\ttransform: encodingStringGenerator.bind(undefined, stringDecoder),\n\t\tfinal: encodingStringFinal.bind(undefined, stringDecoder),\n\t};\n};\n\nconst encodingUint8ArrayGenerator = function * (textEncoder, chunk) {\n\tif (Buffer.isBuffer(chunk)) {\n\t\tyield bufferToUint8Array(chunk);\n\t} else if (typeof chunk === 'string') {\n\t\tyield textEncoder.encode(chunk);\n\t} else {\n\t\tyield chunk;\n\t}\n};\n\nconst encodingStringGenerator = function * (stringDecoder, chunk) {\n\tyield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;\n};\n\nconst encodingStringFinal = function * (stringDecoder) {\n\tconst lastChunk = stringDecoder.end();\n\tif (lastChunk !== '') {\n\t\tyield lastChunk;\n\t}\n};\n", "import {callbackify} from 'node:util';\n\n// Applies a series of generator functions asynchronously\nexport const pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {\n\tstate.currentIterable = getChunks(...getChunksArguments);\n\n\ttry {\n\t\tfor await (const chunk of state.currentIterable) {\n\t\t\ttransformStream.push(chunk);\n\t\t}\n\t} finally {\n\t\tdelete state.currentIterable;\n\t}\n});\n\n// For each new chunk, apply each `transform()` method\nexport const transformChunk = async function * (chunk, generators, index) {\n\tif (index === generators.length) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst {transform = identityGenerator} = generators[index];\n\tfor await (const transformedChunk of transform(chunk)) {\n\t\tyield * transformChunk(transformedChunk, generators, index + 1);\n\t}\n};\n\n// At the end, apply each `final()` method, followed by the `transform()` method of the next transforms\nexport const finalChunks = async function * (generators) {\n\tfor (const [index, {final}] of Object.entries(generators)) {\n\t\tyield * generatorFinalChunks(final, Number(index), generators);\n\t}\n};\n\nconst generatorFinalChunks = async function * (final, index, generators) {\n\tif (final === undefined) {\n\t\treturn;\n\t}\n\n\tfor await (const finalChunk of final()) {\n\t\tyield * transformChunk(finalChunk, generators, index + 1);\n\t}\n};\n\n// Cancel any ongoing async generator when the Transform is destroyed, e.g. when the subprocess errors\nexport const destroyTransform = callbackify(async ({currentIterable}, error) => {\n\tif (currentIterable !== undefined) {\n\t\tawait (error ? currentIterable.throw(error) : currentIterable.return());\n\t\treturn;\n\t}\n\n\tif (error) {\n\t\tthrow error;\n\t}\n});\n\nconst identityGenerator = function * (chunk) {\n\tyield chunk;\n};\n", "// Duplicate the code from `run-async.js` but as synchronous functions\nexport const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {\n\ttry {\n\t\tfor (const chunk of getChunksSync(...getChunksArguments)) {\n\t\t\ttransformStream.push(chunk);\n\t\t}\n\n\t\tdone();\n\t} catch (error) {\n\t\tdone(error);\n\t}\n};\n\n// Run synchronous generators with `execaSync()`\nexport const runTransformSync = (generators, chunks) => [\n\t...chunks.flatMap(chunk => [...transformChunkSync(chunk, generators, 0)]),\n\t...finalChunksSync(generators),\n];\n\nexport const transformChunkSync = function * (chunk, generators, index) {\n\tif (index === generators.length) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst {transform = identityGenerator} = generators[index];\n\tfor (const transformedChunk of transform(chunk)) {\n\t\tyield * transformChunkSync(transformedChunk, generators, index + 1);\n\t}\n};\n\nexport const finalChunksSync = function * (generators) {\n\tfor (const [index, {final}] of Object.entries(generators)) {\n\t\tyield * generatorFinalChunksSync(final, Number(index), generators);\n\t}\n};\n\nconst generatorFinalChunksSync = function * (final, index, generators) {\n\tif (final === undefined) {\n\t\treturn;\n\t}\n\n\tfor (const finalChunk of final()) {\n\t\tyield * transformChunkSync(finalChunk, generators, index + 1);\n\t}\n};\n\nconst identityGenerator = function * (chunk) {\n\tyield chunk;\n};\n", "import {runGeneratorsSync} from '../transform/generator.js';\nimport {joinToUint8Array, isUint8Array} from '../utils/uint-array.js';\nimport {TYPE_TO_MESSAGE} from '../stdio/type.js';\n\n// Apply `stdin`/`input`/`inputFile` options, before spawning, in sync mode, by converting it to the `input` option\nexport const addInputOptionsSync = (fileDescriptors, options) => {\n\tfor (const fdNumber of getInputFdNumbers(fileDescriptors)) {\n\t\taddInputOptionSync(fileDescriptors, fdNumber, options);\n\t}\n};\n\nconst getInputFdNumbers = fileDescriptors => new Set(Object.entries(fileDescriptors)\n\t.filter(([, {direction}]) => direction === 'input')\n\t.map(([fdNumber]) => Number(fdNumber)));\n\nconst addInputOptionSync = (fileDescriptors, fdNumber, options) => {\n\tconst {stdioItems} = fileDescriptors[fdNumber];\n\tconst allStdioItems = stdioItems.filter(({contents}) => contents !== undefined);\n\tif (allStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tif (fdNumber !== 0) {\n\t\tconst [{type, optionName}] = allStdioItems;\n\t\tthrow new TypeError(`Only the \\`stdin\\` option, not \\`${optionName}\\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);\n\t}\n\n\tconst allContents = allStdioItems.map(({contents}) => contents);\n\tconst transformedContents = allContents.map(contents => applySingleInputGeneratorsSync(contents, stdioItems));\n\toptions.input = joinToUint8Array(transformedContents);\n};\n\nconst applySingleInputGeneratorsSync = (contents, stdioItems) => {\n\tconst newContents = runGeneratorsSync(contents, stdioItems, 'utf8', true);\n\tvalidateSerializable(newContents);\n\treturn joinToUint8Array(newContents);\n};\n\nconst validateSerializable = newContents => {\n\tconst invalidItem = newContents.find(item => typeof item !== 'string' && !isUint8Array(item));\n\tif (invalidItem !== undefined) {\n\t\tthrow new TypeError(`The \\`stdin\\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);\n\t}\n};\n", "import {writeFileSync, appendFileSync} from 'node:fs';\nimport {shouldLogOutput, logLinesSync} from '../verbose/output.js';\nimport {runGeneratorsSync} from '../transform/generator.js';\nimport {splitLinesSync} from '../transform/split.js';\nimport {joinToString, joinToUint8Array, bufferToUint8Array} from '../utils/uint-array.js';\nimport {FILE_TYPES} from '../stdio/type.js';\nimport {truncateMaxBufferSync} from './max-buffer.js';\n\n// Apply `stdout`/`stderr` options, after spawning, in sync mode\nexport const transformOutputSync = ({fileDescriptors, syncResult: {output}, options, isMaxBuffer, verboseInfo}) => {\n\tif (output === null) {\n\t\treturn {output: Array.from({length: 3})};\n\t}\n\n\tconst state = {};\n\tconst outputFiles = new Set([]);\n\tconst transformedOutput = output.map((result, fdNumber) =>\n\t\ttransformOutputResultSync({\n\t\t\tresult,\n\t\t\tfileDescriptors,\n\t\t\tfdNumber,\n\t\t\tstate,\n\t\t\toutputFiles,\n\t\t\tisMaxBuffer,\n\t\t\tverboseInfo,\n\t\t}, options));\n\treturn {output: transformedOutput, ...state};\n};\n\nconst transformOutputResultSync = (\n\t{result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo},\n\t{buffer, encoding, lines, stripFinalNewline, maxBuffer},\n) => {\n\tif (result === null) {\n\t\treturn;\n\t}\n\n\tconst truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);\n\tconst uint8ArrayResult = bufferToUint8Array(truncatedResult);\n\tconst {stdioItems, objectMode} = fileDescriptors[fdNumber];\n\tconst chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);\n\tconst {serializedResult, finalResult = serializedResult} = serializeChunks({\n\t\tchunks,\n\t\tobjectMode,\n\t\tencoding,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tfdNumber,\n\t});\n\n\tlogOutputSync({\n\t\tserializedResult,\n\t\tfdNumber,\n\t\tstate,\n\t\tverboseInfo,\n\t\tencoding,\n\t\tstdioItems,\n\t\tobjectMode,\n\t});\n\n\tconst returnedResult = buffer[fdNumber] ? finalResult : undefined;\n\n\ttry {\n\t\tif (state.error === undefined) {\n\t\t\twriteToFiles(serializedResult, stdioItems, outputFiles);\n\t\t}\n\n\t\treturn returnedResult;\n\t} catch (error) {\n\t\tstate.error = error;\n\t\treturn returnedResult;\n\t}\n};\n\n// Applies transform generators to `stdout`/`stderr`\nconst runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {\n\ttry {\n\t\treturn runGeneratorsSync(chunks, stdioItems, encoding, false);\n\t} catch (error) {\n\t\tstate.error = error;\n\t\treturn chunks;\n\t}\n};\n\n// The contents is converted to three stages:\n//  - serializedResult: used when the target is a file path/URL or a file descriptor (including 'inherit')\n//  - finalResult/returnedResult: returned as `result.std*`\nconst serializeChunks = ({chunks, objectMode, encoding, lines, stripFinalNewline, fdNumber}) => {\n\tif (objectMode) {\n\t\treturn {serializedResult: chunks};\n\t}\n\n\tif (encoding === 'buffer') {\n\t\treturn {serializedResult: joinToUint8Array(chunks)};\n\t}\n\n\tconst serializedResult = joinToString(chunks, encoding);\n\tif (lines[fdNumber]) {\n\t\treturn {serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline[fdNumber], objectMode)};\n\t}\n\n\treturn {serializedResult};\n};\n\nconst logOutputSync = ({serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode}) => {\n\tif (!shouldLogOutput({\n\t\tstdioItems,\n\t\tencoding,\n\t\tverboseInfo,\n\t\tfdNumber,\n\t})) {\n\t\treturn;\n\t}\n\n\tconst linesArray = splitLinesSync(serializedResult, false, objectMode);\n\n\ttry {\n\t\tlogLinesSync(linesArray, fdNumber, verboseInfo);\n\t} catch (error) {\n\t\tstate.error ??= error;\n\t}\n};\n\n// When the `std*` target is a file path/URL or a file descriptor\nconst writeToFiles = (serializedResult, stdioItems, outputFiles) => {\n\tfor (const {path} of stdioItems.filter(({type}) => FILE_TYPES.has(type))) {\n\t\tconst pathString = typeof path === 'string' ? path : path.toString();\n\t\tif (outputFiles.has(pathString)) {\n\t\t\tappendFileSync(path, serializedResult);\n\t\t} else {\n\t\t\toutputFiles.add(pathString);\n\t\t\twriteFileSync(path, serializedResult);\n\t\t}\n\t}\n};\n", "import {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {verboseLog, serializeVerboseMessage} from './log.js';\nimport {isFullVerbose} from './values.js';\n\n// `ignore` opts-out of `verbose` for a specific stream.\n// `ipc` cannot use piping.\n// `inherit` would result in double printing.\n// They can also lead to double printing when passing file descriptor integers or `process.std*`.\n// This only leaves with `pipe` and `overlapped`.\nexport const shouldLogOutput = ({stdioItems, encoding, verboseInfo, fdNumber}) => fdNumber !== 'all'\n\t&& isFullVerbose(verboseInfo, fdNumber)\n\t&& !BINARY_ENCODINGS.has(encoding)\n\t&& fdUsesVerbose(fdNumber)\n\t&& (stdioItems.some(({type, value}) => type === 'native' && PIPED_STDIO_VALUES.has(value))\n\t|| stdioItems.every(({type}) => TRANSFORM_TYPES.has(type)));\n\n// Printing input streams would be confusing.\n// Files and streams can produce big outputs, which we don't want to print.\n// We could print `stdio[3+]` but it often is redirected to files and streams, with the same issue.\n// So we only print stdout and stderr.\nconst fdUsesVerbose = fdNumber => fdNumber === 1 || fdNumber === 2;\n\nconst PIPED_STDIO_VALUES = new Set(['pipe', 'overlapped']);\n\n// `verbose: 'full'` printing logic with async methods\nexport const logLines = async (linesIterable, stream, fdNumber, verboseInfo) => {\n\tfor await (const line of linesIterable) {\n\t\tif (!isPipingStream(stream)) {\n\t\t\tlogLine(line, fdNumber, verboseInfo);\n\t\t}\n\t}\n};\n\n// `verbose: 'full'` printing logic with sync methods\nexport const logLinesSync = (linesArray, fdNumber, verboseInfo) => {\n\tfor (const line of linesArray) {\n\t\tlogLine(line, fdNumber, verboseInfo);\n\t}\n};\n\n// When `subprocess.stdout|stderr.pipe()` is called, `verbose` becomes a noop.\n// This prevents the following problems:\n//  - `.pipe()` achieves the same result as using `stdout: 'inherit'`, `stdout: stream`, etc. which also make `verbose` a noop.\n//    For example, `subprocess.stdout.pipe(process.stdin)` would print each line twice.\n//  - When chaining subprocesses with `subprocess.pipe(otherSubprocess)`, only the last one should print its output.\n// Detecting whether `.pipe()` is impossible without monkey-patching it, so we use the following undocumented property.\n// This is not a critical behavior since changes of the following property would only make `verbose` more verbose.\nconst isPipingStream = stream => stream._readableState.pipes.length > 0;\n\n// When `verbose` is `full`, print stdout|stderr\nconst logLine = (line, fdNumber, verboseInfo) => {\n\tconst verboseMessage = serializeVerboseMessage(line);\n\tverboseLog({\n\t\ttype: 'output',\n\t\tverboseMessage,\n\t\tfdNumber,\n\t\tverboseInfo,\n\t});\n};\n", "import {isUint8Array, concatUint8Arrays} from '../utils/uint-array.js';\nimport {stripNewline} from '../io/strip-newline.js';\n\n// Retrieve `result.all` with synchronous methods\nexport const getAllSync = ([, stdout, stderr], options) => {\n\tif (!options.all) {\n\t\treturn;\n\t}\n\n\tif (stdout === undefined) {\n\t\treturn stderr;\n\t}\n\n\tif (stderr === undefined) {\n\t\treturn stdout;\n\t}\n\n\tif (Array.isArray(stdout)) {\n\t\treturn Array.isArray(stderr)\n\t\t\t? [...stdout, ...stderr]\n\t\t\t: [...stdout, stripNewline(stderr, options, 'all')];\n\t}\n\n\tif (Array.isArray(stderr)) {\n\t\treturn [stripNewline(stdout, options, 'all'), ...stderr];\n\t}\n\n\tif (isUint8Array(stdout) && isUint8Array(stderr)) {\n\t\treturn concatUint8Arrays([stdout, stderr]);\n\t}\n\n\treturn `${stdout}${stderr}`;\n};\n", "import {once} from 'node:events';\nimport {DiscardedError} from '../return/final-error.js';\n\n// If `error` is emitted before `spawn`, `exit` will never be emitted.\n// However, `error` might be emitted after `spawn`.\n// In that case, `exit` will still be emitted.\n// Since the `exit` event contains the signal name, we want to make sure we are listening for it.\n// This function also takes into account the following unlikely cases:\n//  - `exit` being emitted in the same microtask as `spawn`\n//  - `error` being emitted multiple times\nexport const waitForExit = async (subprocess, context) => {\n\tconst [exitCode, signal] = await waitForExitOrError(subprocess);\n\tcontext.isForcefullyTerminated ??= false;\n\treturn [exitCode, signal];\n};\n\nconst waitForExitOrError = async subprocess => {\n\tconst [spawnPayload, exitPayload] = await Promise.allSettled([\n\t\tonce(subprocess, 'spawn'),\n\t\tonce(subprocess, 'exit'),\n\t]);\n\n\tif (spawnPayload.status === 'rejected') {\n\t\treturn [];\n\t}\n\n\treturn exitPayload.status === 'rejected'\n\t\t? waitForSubprocessExit(subprocess)\n\t\t: exitPayload.value;\n};\n\nconst waitForSubprocessExit = async subprocess => {\n\ttry {\n\t\treturn await once(subprocess, 'exit');\n\t} catch {\n\t\treturn waitForSubprocessExit(subprocess);\n\t}\n};\n\n// Retrieve the final exit code and|or signal name\nexport const waitForSuccessfulExit = async exitPromise => {\n\tconst [exitCode, signal] = await exitPromise;\n\n\tif (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {\n\t\tthrow new DiscardedError();\n\t}\n\n\treturn [exitCode, signal];\n};\n\n// When the subprocess fails due to an `error` event\nconst isSubprocessErrorExit = (exitCode, signal) => exitCode === undefined && signal === undefined;\n// When the subprocess fails due to a non-0 exit code or to a signal termination\nexport const isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;\n", "import {DiscardedError} from '../return/final-error.js';\nimport {isMaxBufferSync} from '../io/max-buffer.js';\nimport {isFailedExit} from './exit-async.js';\n\n// Retrieve exit code, signal name and error information, with synchronous methods\nexport const getExitResultSync = ({error, status: exitCode, signal, output}, {maxBuffer}) => {\n\tconst resultError = getResultError(error, exitCode, signal);\n\tconst timedOut = resultError?.code === 'ETIMEDOUT';\n\tconst isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);\n\treturn {\n\t\tresultError,\n\t\texitCode,\n\t\tsignal,\n\t\ttimedOut,\n\t\tisMaxBuffer,\n\t};\n};\n\nconst getResultError = (error, exitCode, signal) => {\n\tif (error !== undefined) {\n\t\treturn error;\n\t}\n\n\treturn isFailedExit(exitCode, signal) ? new DiscardedError() : undefined;\n};\n", "import {setMaxListeners} from 'node:events';\nimport {spawn} from 'node:child_process';\nimport {MaxBufferError} from 'get-stream';\nimport {handleCommand} from '../arguments/command.js';\nimport {normalizeOptions} from '../arguments/options.js';\nimport {SUBPROCESS_OPTIONS} from '../arguments/fd-options.js';\nimport {addIpcMethods} from '../ipc/methods.js';\nimport {makeError, makeSuccessResult} from '../return/result.js';\nimport {handleResult} from '../return/reject.js';\nimport {handleEarlyError} from '../return/early-error.js';\nimport {handleStdioAsync} from '../stdio/handle-async.js';\nimport {stripNewline} from '../io/strip-newline.js';\nimport {pipeOutputAsync} from '../io/output-async.js';\nimport {subprocessKill} from '../terminate/kill.js';\nimport {cleanupOnExit} from '../terminate/cleanup.js';\nimport {pipeToSubprocess} from '../pipe/setup.js';\nimport {makeAllStream} from '../resolve/all-async.js';\nimport {waitForSubprocessResult} from '../resolve/wait-subprocess.js';\nimport {addConvertedStreams} from '../convert/add.js';\nimport {createDeferred} from '../utils/deferred.js';\nimport {mergePromise} from './promise.js';\n\n// Main shared logic for all async methods: `execa()`, `$`, `execaNode()`\nexport const execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {\n\tconst {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleAsyncArguments(rawFile, rawArguments, rawOptions);\n\tconst {subprocess, promise} = spawnSubprocessAsync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t});\n\tsubprocess.pipe = pipeToSubprocess.bind(undefined, {\n\t\tsource: subprocess,\n\t\tsourcePromise: promise,\n\t\tboundOptions: {},\n\t\tcreateNested,\n\t});\n\tmergePromise(subprocess, promise);\n\tSUBPROCESS_OPTIONS.set(subprocess, {options, fileDescriptors});\n\treturn subprocess;\n};\n\n// Compute arguments to pass to `child_process.spawn()`\nconst handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {\n\tconst {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);\n\tconst {file, commandArguments, options: normalizedOptions} = normalizeOptions(rawFile, rawArguments, rawOptions);\n\tconst options = handleAsyncOptions(normalizedOptions);\n\tconst fileDescriptors = handleStdioAsync(options, verboseInfo);\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\toptions,\n\t\tfileDescriptors,\n\t};\n};\n\n// Options normalization logic specific to async methods.\n// Prevent passing the `timeout` option directly to `child_process.spawn()`.\nconst handleAsyncOptions = ({timeout, signal, ...options}) => {\n\tif (signal !== undefined) {\n\t\tthrow new TypeError('The \"signal\" option has been renamed to \"cancelSignal\" instead.');\n\t}\n\n\treturn {...options, timeoutDuration: timeout};\n};\n\nconst spawnSubprocessAsync = ({file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors}) => {\n\tlet subprocess;\n\ttry {\n\t\tsubprocess = spawn(file, commandArguments, options);\n\t} catch (error) {\n\t\treturn handleEarlyError({\n\t\t\terror,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tfileDescriptors,\n\t\t\toptions,\n\t\t\tstartTime,\n\t\t\tverboseInfo,\n\t\t});\n\t}\n\n\tconst controller = new AbortController();\n\tsetMaxListeners(Number.POSITIVE_INFINITY, controller.signal);\n\n\tconst originalStreams = [...subprocess.stdio];\n\tpipeOutputAsync(subprocess, fileDescriptors, controller);\n\tcleanupOnExit(subprocess, options, controller);\n\n\tconst context = {};\n\tconst onInternalError = createDeferred();\n\tsubprocess.kill = subprocessKill.bind(undefined, {\n\t\tkill: subprocess.kill.bind(subprocess),\n\t\toptions,\n\t\tonInternalError,\n\t\tcontext,\n\t\tcontroller,\n\t});\n\tsubprocess.all = makeAllStream(subprocess, options);\n\taddConvertedStreams(subprocess, options);\n\taddIpcMethods(subprocess, options);\n\n\tconst promise = handlePromise({\n\t\tsubprocess,\n\t\toptions,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\toriginalStreams,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tcontext,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\treturn {subprocess, promise};\n};\n\n// Asynchronous logic, as opposed to the previous logic which can be run synchronously, i.e. can be returned to user right away\nconst handlePromise = async ({subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context, onInternalError, controller}) => {\n\tconst [\n\t\terrorInfo,\n\t\t[exitCode, signal],\n\t\tstdioResults,\n\t\tallResult,\n\t\tipcOutput,\n\t] = await waitForSubprocessResult({\n\t\tsubprocess,\n\t\toptions,\n\t\tcontext,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\toriginalStreams,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\tcontroller.abort();\n\tonInternalError.resolve();\n\n\tconst stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));\n\tconst all = stripNewline(allResult, options, 'all');\n\tconst result = getAsyncResult({\n\t\terrorInfo,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\tcontext,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t});\n\treturn handleResult(result, verboseInfo, options);\n};\n\nconst getAsyncResult = ({errorInfo, exitCode, signal, stdio, all, ipcOutput, context, options, command, escapedCommand, startTime}) => 'error' in errorInfo\n\t? makeError({\n\t\terror: errorInfo.error,\n\t\tcommand,\n\t\tescapedCommand,\n\t\ttimedOut: context.terminationReason === 'timeout',\n\t\tisCanceled: context.terminationReason === 'cancel' || context.terminationReason === 'gracefulCancel',\n\t\tisGracefullyCanceled: context.terminationReason === 'gracefulCancel',\n\t\tisMaxBuffer: errorInfo.error instanceof MaxBufferError,\n\t\tisForcefullyTerminated: context.isForcefullyTerminated,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: false,\n\t})\n\t: makeSuccessResult({\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstdio,\n\t\tall,\n\t\tipcOutput,\n\t\toptions,\n\t\tstartTime,\n\t});\n", "import process from 'node:process';\nimport {sendMessage} from './send.js';\nimport {getOneMessage} from './get-one.js';\nimport {getEachMessage} from './get-each.js';\nimport {getCancelSignal} from './graceful.js';\n\n// Add promise-based IPC methods in current process\nexport const addIpcMethods = (subprocess, {ipc}) => {\n\tObject.assign(subprocess, getIpcMethods(subprocess, false, ipc));\n};\n\n// Get promise-based IPC in the subprocess\nexport const getIpcExport = () => {\n\tconst anyProcess = process;\n\tconst isSubprocess = true;\n\tconst ipc = process.channel !== undefined;\n\n\treturn {\n\t\t...getIpcMethods(anyProcess, isSubprocess, ipc),\n\t\tgetCancelSignal: getCancelSignal.bind(undefined, {\n\t\t\tanyProcess,\n\t\t\tchannel: anyProcess.channel,\n\t\t\tisSubprocess,\n\t\t\tipc,\n\t\t}),\n\t};\n};\n\n// Retrieve the `ipc` shared by both the current process and the subprocess\nconst getIpcMethods = (anyProcess, isSubprocess, ipc) => ({\n\tsendMessage: sendMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n\tgetOneMessage: getOneMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n\tgetEachMessage: getEachMessage.bind(undefined, {\n\t\tanyProcess,\n\t\tchannel: anyProcess.channel,\n\t\tisSubprocess,\n\t\tipc,\n\t}),\n});\n", "import {once, on} from 'node:events';\nimport {\n\tvalidateIpcMethod,\n\tthrowOnEarlyDisconnect,\n\tdisconnect,\n\tgetStrictResponseError,\n} from './validation.js';\nimport {getIpcEmitter, isConnected} from './forward.js';\nimport {addReference, removeReference} from './reference.js';\n\n// Like `[sub]process.once('message')` but promise-based\nexport const getOneMessage = ({anyProcess, channel, isSubprocess, ipc}, {reference = true, filter} = {}) => {\n\tvalidateIpcMethod({\n\t\tmethodName: 'getOneMessage',\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: isConnected(anyProcess),\n\t});\n\n\treturn getOneMessageAsync({\n\t\tanyProcess,\n\t\tchannel,\n\t\tisSubprocess,\n\t\tfilter,\n\t\treference,\n\t});\n};\n\nconst getOneMessageAsync = async ({anyProcess, channel, isSubprocess, filter, reference}) => {\n\taddReference(channel, reference);\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst controller = new AbortController();\n\ttry {\n\t\treturn await Promise.race([\n\t\t\tgetMessage(ipcEmitter, filter, controller),\n\t\t\tthrowOnDisconnect(ipcEmitter, isSubprocess, controller),\n\t\t\tthrowOnStrictError(ipcEmitter, isSubprocess, controller),\n\t\t]);\n\t} catch (error) {\n\t\tdisconnect(anyProcess);\n\t\tthrow error;\n\t} finally {\n\t\tcontroller.abort();\n\t\tremoveReference(channel, reference);\n\t}\n};\n\nconst getMessage = async (ipcEmitter, filter, {signal}) => {\n\tif (filter === undefined) {\n\t\tconst [message] = await once(ipcEmitter, 'message', {signal});\n\t\treturn message;\n\t}\n\n\tfor await (const [message] of on(ipcEmitter, 'message', {signal})) {\n\t\tif (filter(message)) {\n\t\t\treturn message;\n\t\t}\n\t}\n};\n\nconst throwOnDisconnect = async (ipcEmitter, isSubprocess, {signal}) => {\n\tawait once(ipcEmitter, 'disconnect', {signal});\n\tthrowOnEarlyDisconnect(isSubprocess);\n};\n\nconst throwOnStrictError = async (ipcEmitter, isSubprocess, {signal}) => {\n\tconst [error] = await once(ipcEmitter, 'strict:error', {signal});\n\tthrow getStrictResponseError(error, isSubprocess);\n};\n", "import {once, on} from 'node:events';\nimport {validateIpcMethod, disconnect, getStrictResponseError} from './validation.js';\nimport {getIpcEmitter, isConnected} from './forward.js';\nimport {addReference, removeReference} from './reference.js';\n\n// Like `[sub]process.on('message')` but promise-based\nexport const getEachMessage = ({anyProcess, channel, isSubprocess, ipc}, {reference = true} = {}) => loopOnMessages({\n\tanyProcess,\n\tchannel,\n\tisSubprocess,\n\tipc,\n\tshouldAwait: !isSubprocess,\n\treference,\n});\n\n// Same but used internally\nexport const loopOnMessages = ({anyProcess, channel, isSubprocess, ipc, shouldAwait, reference}) => {\n\tvalidateIpcMethod({\n\t\tmethodName: 'getEachMessage',\n\t\tisSubprocess,\n\t\tipc,\n\t\tisConnected: isConnected(anyProcess),\n\t});\n\n\taddReference(channel, reference);\n\tconst ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);\n\tconst controller = new AbortController();\n\tconst state = {};\n\tstopOnDisconnect(anyProcess, ipcEmitter, controller);\n\tabortOnStrictError({\n\t\tipcEmitter,\n\t\tisSubprocess,\n\t\tcontroller,\n\t\tstate,\n\t});\n\treturn iterateOnMessages({\n\t\tanyProcess,\n\t\tchannel,\n\t\tipcEmitter,\n\t\tisSubprocess,\n\t\tshouldAwait,\n\t\tcontroller,\n\t\tstate,\n\t\treference,\n\t});\n};\n\nconst stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {\n\ttry {\n\t\tawait once(ipcEmitter, 'disconnect', {signal: controller.signal});\n\t\tcontroller.abort();\n\t} catch {}\n};\n\nconst abortOnStrictError = async ({ipcEmitter, isSubprocess, controller, state}) => {\n\ttry {\n\t\tconst [error] = await once(ipcEmitter, 'strict:error', {signal: controller.signal});\n\t\tstate.error = getStrictResponseError(error, isSubprocess);\n\t\tcontroller.abort();\n\t} catch {}\n};\n\nconst iterateOnMessages = async function * ({anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference}) {\n\ttry {\n\t\tfor await (const [message] of on(ipcEmitter, 'message', {signal: controller.signal})) {\n\t\t\tthrowIfStrictError(state);\n\t\t\tyield message;\n\t\t}\n\t} catch {\n\t\tthrowIfStrictError(state);\n\t} finally {\n\t\tcontroller.abort();\n\t\tremoveReference(channel, reference);\n\n\t\tif (!isSubprocess) {\n\t\t\tdisconnect(anyProcess);\n\t\t}\n\n\t\tif (shouldAwait) {\n\t\t\tawait anyProcess;\n\t\t}\n\t}\n};\n\nconst throwIfStrictError = ({error}) => {\n\tif (error) {\n\t\tthrow error;\n\t}\n};\n", "import {ChildProcess} from 'node:child_process';\nimport {\n\tPassThrough,\n\tReadable,\n\tWritable,\n\tDuplex,\n} from 'node:stream';\nimport {cleanupCustomStreams} from '../stdio/handle.js';\nimport {makeEarlyError} from './result.js';\nimport {handleResult} from './reject.js';\n\n// When the subprocess fails to spawn.\n// We ensure the returned error is always both a promise and a subprocess.\nexport const handleEarlyError = ({error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo}) => {\n\tcleanupCustomStreams(fileDescriptors);\n\n\tconst subprocess = new ChildProcess();\n\tcreateDummyStreams(subprocess, fileDescriptors);\n\tObject.assign(subprocess, {readable, writable, duplex});\n\n\tconst earlyError = makeEarlyError({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: false,\n\t});\n\tconst promise = handleDummyPromise(earlyError, verboseInfo, options);\n\treturn {subprocess, promise};\n};\n\nconst createDummyStreams = (subprocess, fileDescriptors) => {\n\tconst stdin = createDummyStream();\n\tconst stdout = createDummyStream();\n\tconst stderr = createDummyStream();\n\tconst extraStdio = Array.from({length: fileDescriptors.length - 3}, createDummyStream);\n\tconst all = createDummyStream();\n\tconst stdio = [stdin, stdout, stderr, ...extraStdio];\n\tObject.assign(subprocess, {\n\t\tstdin,\n\t\tstdout,\n\t\tstderr,\n\t\tall,\n\t\tstdio,\n\t});\n};\n\nconst createDummyStream = () => {\n\tconst stream = new PassThrough();\n\tstream.end();\n\treturn stream;\n};\n\nconst readable = () => new Readable({read() {}});\nconst writable = () => new Writable({write() {}});\nconst duplex = () => new Duplex({read() {}, write() {}});\n\nconst handleDummyPromise = async (error, verboseInfo, options) => handleResult(error, verboseInfo, options);\n", "import {createReadStream, createWriteStream} from 'node:fs';\nimport {Buffer} from 'node:buffer';\nimport {Readable, Writable, Duplex} from 'node:stream';\nimport {generatorToStream} from '../transform/generator.js';\nimport {handleStdio} from './handle.js';\nimport {TYPE_TO_MESSAGE} from './type.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async mode\nexport const handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);\n\nconst forbiddenIfAsync = ({type, optionName}) => {\n\tthrow new TypeError(`The \\`${optionName}\\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);\n};\n\n// Create streams used internally for piping when using specific values for the `std*` options, in async mode.\n// For example, `stdout: {file}` creates a file stream, which is piped from/to.\nconst addProperties = {\n\tfileNumber: forbiddenIfAsync,\n\tgenerator: generatorToStream,\n\tasyncGenerator: generatorToStream,\n\tnodeStream: ({value}) => ({stream: value}),\n\twebTransform({value: {transform, writableObjectMode, readableObjectMode}}) {\n\t\tconst objectMode = writableObjectMode || readableObjectMode;\n\t\tconst stream = Duplex.fromWeb(transform, {objectMode});\n\t\treturn {stream};\n\t},\n\tduplex: ({value: {transform}}) => ({stream: transform}),\n\tnative() {},\n};\n\nconst addPropertiesAsync = {\n\tinput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({stream: createReadStream(value)}),\n\t\tfilePath: ({value: {file}}) => ({stream: createReadStream(file)}),\n\t\twebStream: ({value}) => ({stream: Readable.fromWeb(value)}),\n\t\titerable: ({value}) => ({stream: Readable.from(value)}),\n\t\tasyncIterable: ({value}) => ({stream: Readable.from(value)}),\n\t\tstring: ({value}) => ({stream: Readable.from(value)}),\n\t\tuint8Array: ({value}) => ({stream: Readable.from(Buffer.from(value))}),\n\t},\n\toutput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({stream: createWriteStream(value)}),\n\t\tfilePath: ({value: {file}}) => ({stream: createWriteStream(file)}),\n\t\twebStream: ({value}) => ({stream: Writable.fromWeb(value)}),\n\t\titerable: forbiddenIfAsync,\n\t\tasyncIterable: forbiddenIfAsync,\n\t\tstring: forbiddenIfAsync,\n\t\tuint8Array: forbiddenIfAsync,\n\t},\n};\n", "import {on, once} from 'node:events';\nimport {PassThrough as PassThroughStream, getDefaultHighWaterMark} from 'node:stream';\nimport {finished} from 'node:stream/promises';\n\nexport default function mergeStreams(streams) {\n\tif (!Array.isArray(streams)) {\n\t\tthrow new TypeError(`Expected an array, got \\`${typeof streams}\\`.`);\n\t}\n\n\tfor (const stream of streams) {\n\t\tvalidateStream(stream);\n\t}\n\n\tconst objectMode = streams.some(({readableObjectMode}) => readableObjectMode);\n\tconst highWaterMark = getHighWaterMark(streams, objectMode);\n\tconst passThroughStream = new MergedStream({\n\t\tobjectMode,\n\t\twritableHighWaterMark: highWaterMark,\n\t\treadableHighWaterMark: highWaterMark,\n\t});\n\n\tfor (const stream of streams) {\n\t\tpassThroughStream.add(stream);\n\t}\n\n\treturn passThroughStream;\n}\n\nconst getHighWaterMark = (streams, objectMode) => {\n\tif (streams.length === 0) {\n\t\treturn getDefaultHighWaterMark(objectMode);\n\t}\n\n\tconst highWaterMarks = streams\n\t\t.filter(({readableObjectMode}) => readableObjectMode === objectMode)\n\t\t.map(({readableHighWaterMark}) => readableHighWaterMark);\n\treturn Math.max(...highWaterMarks);\n};\n\nclass MergedStream extends PassThroughStream {\n\t#streams = new Set([]);\n\t#ended = new Set([]);\n\t#aborted = new Set([]);\n\t#onFinished;\n\t#unpipeEvent = Symbol('unpipe');\n\t#streamPromises = new WeakMap();\n\n\tadd(stream) {\n\t\tvalidateStream(stream);\n\n\t\tif (this.#streams.has(stream)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#streams.add(stream);\n\n\t\tthis.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);\n\t\tconst streamPromise = endWhenStreamsDone({\n\t\t\tpassThroughStream: this,\n\t\t\tstream,\n\t\t\tstreams: this.#streams,\n\t\t\tended: this.#ended,\n\t\t\taborted: this.#aborted,\n\t\t\tonFinished: this.#onFinished,\n\t\t\tunpipeEvent: this.#unpipeEvent,\n\t\t});\n\t\tthis.#streamPromises.set(stream, streamPromise);\n\n\t\tstream.pipe(this, {end: false});\n\t}\n\n\tasync remove(stream) {\n\t\tvalidateStream(stream);\n\n\t\tif (!this.#streams.has(stream)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst streamPromise = this.#streamPromises.get(stream);\n\t\tif (streamPromise === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.#streamPromises.delete(stream);\n\n\t\tstream.unpipe(this);\n\t\tawait streamPromise;\n\t\treturn true;\n\t}\n}\n\nconst onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {\n\tupdateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tawait Promise.race([\n\t\t\tonMergedStreamEnd(passThroughStream, controller),\n\t\t\tonInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller),\n\t\t]);\n\t} finally {\n\t\tcontroller.abort();\n\t\tupdateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);\n\t}\n};\n\nconst onMergedStreamEnd = async (passThroughStream, {signal}) => {\n\ttry {\n\t\tawait finished(passThroughStream, {signal, cleanup: true});\n\t} catch (error) {\n\t\terrorOrAbortStream(passThroughStream, error);\n\t\tthrow error;\n\t}\n};\n\nconst onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, {signal}) => {\n\tfor await (const [unpipedStream] of on(passThroughStream, 'unpipe', {signal})) {\n\t\tif (streams.has(unpipedStream)) {\n\t\t\tunpipedStream.emit(unpipeEvent);\n\t\t}\n\t}\n};\n\nconst validateStream = stream => {\n\tif (typeof stream?.pipe !== 'function') {\n\t\tthrow new TypeError(`Expected a readable stream, got: \\`${typeof stream}\\`.`);\n\t}\n};\n\nconst endWhenStreamsDone = async ({passThroughStream, stream, streams, ended, aborted, onFinished, unpipeEvent}) => {\n\tupdateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tawait Promise.race([\n\t\t\tafterMergedStreamFinished(onFinished, stream, controller),\n\t\t\tonInputStreamEnd({\n\t\t\t\tpassThroughStream,\n\t\t\t\tstream,\n\t\t\t\tstreams,\n\t\t\t\tended,\n\t\t\t\taborted,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t\tonInputStreamUnpipe({\n\t\t\t\tstream,\n\t\t\t\tstreams,\n\t\t\t\tended,\n\t\t\t\taborted,\n\t\t\t\tunpipeEvent,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t]);\n\t} finally {\n\t\tcontroller.abort();\n\t\tupdateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);\n\t}\n\n\tif (streams.size > 0 && streams.size === ended.size + aborted.size) {\n\t\tif (ended.size === 0 && aborted.size > 0) {\n\t\t\tabortStream(passThroughStream);\n\t\t} else {\n\t\t\tendStream(passThroughStream);\n\t\t}\n\t}\n};\n\nconst afterMergedStreamFinished = async (onFinished, stream, {signal}) => {\n\ttry {\n\t\tawait onFinished;\n\t\tif (!signal.aborted) {\n\t\t\tabortStream(stream);\n\t\t}\n\t} catch (error) {\n\t\tif (!signal.aborted) {\n\t\t\terrorOrAbortStream(stream, error);\n\t\t}\n\t}\n};\n\nconst onInputStreamEnd = async ({passThroughStream, stream, streams, ended, aborted, controller: {signal}}) => {\n\ttry {\n\t\tawait finished(stream, {\n\t\t\tsignal,\n\t\t\tcleanup: true,\n\t\t\treadable: true,\n\t\t\twritable: false,\n\t\t});\n\t\tif (streams.has(stream)) {\n\t\t\tended.add(stream);\n\t\t}\n\t} catch (error) {\n\t\tif (signal.aborted || !streams.has(stream)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isAbortError(error)) {\n\t\t\taborted.add(stream);\n\t\t} else {\n\t\t\terrorStream(passThroughStream, error);\n\t\t}\n\t}\n};\n\nconst onInputStreamUnpipe = async ({stream, streams, ended, aborted, unpipeEvent, controller: {signal}}) => {\n\tawait once(stream, unpipeEvent, {signal});\n\n\tif (!stream.readable) {\n\t\treturn once(signal, 'abort', {signal});\n\t}\n\n\tstreams.delete(stream);\n\tended.delete(stream);\n\taborted.delete(stream);\n};\n\nconst endStream = stream => {\n\tif (stream.writable) {\n\t\tstream.end();\n\t}\n};\n\nconst errorOrAbortStream = (stream, error) => {\n\tif (isAbortError(error)) {\n\t\tabortStream(stream);\n\t} else {\n\t\terrorStream(stream, error);\n\t}\n};\n\n// This is the error thrown by `finished()` on `stream.destroy()`\nconst isAbortError = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';\n\nconst abortStream = stream => {\n\tif (stream.readable || stream.writable) {\n\t\tstream.destroy();\n\t}\n};\n\n// `stream.destroy(error)` crashes the process with `uncaughtException` if no `error` event listener exists on `stream`.\n// We take care of error handling on user behalf, so we do not want this to happen.\nconst errorStream = (stream, error) => {\n\tif (!stream.destroyed) {\n\t\tstream.once('error', noop);\n\t\tstream.destroy(error);\n\t}\n};\n\nconst noop = () => {};\n\nconst updateMaxListeners = (passThroughStream, increment) => {\n\tconst maxListeners = passThroughStream.getMaxListeners();\n\tif (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {\n\t\tpassThroughStream.setMaxListeners(maxListeners + increment);\n\t}\n};\n\n// Number of times `passThroughStream.on()` is called regardless of streams:\n//  - once due to `finished(passThroughStream)`\n//  - once due to `on(passThroughStream)`\nconst PASSTHROUGH_LISTENERS_COUNT = 2;\n\n// Number of times `passThroughStream.on()` is called per stream:\n//  - once due to `stream.pipe(passThroughStream)`\nconst PASSTHROUGH_LISTENERS_PER_STREAM = 1;\n", "import {finished} from 'node:stream/promises';\nimport {isStandardStream} from '../utils/standard-stream.js';\n\n// Similar to `Stream.pipeline(source, destination)`, but does not destroy standard streams\nexport const pipeStreams = (source, destination) => {\n\tsource.pipe(destination);\n\tonSourceFinish(source, destination);\n\tonDestinationFinish(source, destination);\n};\n\n// `source.pipe(destination)` makes `destination` end when `source` ends.\n// But it does not propagate aborts or errors. This function does it.\nconst onSourceFinish = async (source, destination) => {\n\tif (isStandardStream(source) || isStandardStream(destination)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait finished(source, {cleanup: true, readable: true, writable: false});\n\t} catch {}\n\n\tendDestinationStream(destination);\n};\n\nexport const endDestinationStream = destination => {\n\tif (destination.writable) {\n\t\tdestination.end();\n\t}\n};\n\n// We do the same thing in the other direction as well.\nconst onDestinationFinish = async (source, destination) => {\n\tif (isStandardStream(source) || isStandardStream(destination)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait finished(destination, {cleanup: true, readable: false, writable: true});\n\t} catch {}\n\n\tabortSourceStream(source);\n};\n\nexport const abortSourceStream = source => {\n\tif (source.readable) {\n\t\tsource.destroy();\n\t}\n};\n", "import mergeStreams from '@sindresorhus/merge-streams';\nimport {isStandardStream} from '../utils/standard-stream.js';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {pipeStreams} from './pipeline.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, after spawning, in async mode\n// When multiple input streams are used, we merge them to ensure the output stream ends only once each input stream has ended\nexport const pipeOutputAsync = (subprocess, fileDescriptors, controller) => {\n\tconst pipeGroups = new Map();\n\n\tfor (const [fdNumber, {stdioItems, direction}] of Object.entries(fileDescriptors)) {\n\t\tfor (const {stream} of stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type))) {\n\t\t\tpipeTransform(subprocess, stream, direction, fdNumber);\n\t\t}\n\n\t\tfor (const {stream} of stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type))) {\n\t\t\tpipeStdioItem({\n\t\t\t\tsubprocess,\n\t\t\t\tstream,\n\t\t\t\tdirection,\n\t\t\t\tfdNumber,\n\t\t\t\tpipeGroups,\n\t\t\t\tcontroller,\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (const [outputStream, inputStreams] of pipeGroups.entries()) {\n\t\tconst inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);\n\t\tpipeStreams(inputStream, outputStream);\n\t}\n};\n\n// When using transforms, `subprocess.stdin|stdout|stderr|stdio` is directly mutated\nconst pipeTransform = (subprocess, stream, direction, fdNumber) => {\n\tif (direction === 'output') {\n\t\tpipeStreams(subprocess.stdio[fdNumber], stream);\n\t} else {\n\t\tpipeStreams(stream, subprocess.stdio[fdNumber]);\n\t}\n\n\tconst streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];\n\tif (streamProperty !== undefined) {\n\t\tsubprocess[streamProperty] = stream;\n\t}\n\n\tsubprocess.stdio[fdNumber] = stream;\n};\n\nconst SUBPROCESS_STREAM_PROPERTIES = ['stdin', 'stdout', 'stderr'];\n\n// Most `std*` option values involve piping `subprocess.std*` to a stream.\n// The stream is either passed by the user or created internally.\nconst pipeStdioItem = ({subprocess, stream, direction, fdNumber, pipeGroups, controller}) => {\n\tif (stream === undefined) {\n\t\treturn;\n\t}\n\n\tsetStandardStreamMaxListeners(stream, controller);\n\n\tconst [inputStream, outputStream] = direction === 'output'\n\t\t? [stream, subprocess.stdio[fdNumber]]\n\t\t: [subprocess.stdio[fdNumber], stream];\n\tconst outputStreams = pipeGroups.get(inputStream) ?? [];\n\tpipeGroups.set(inputStream, [...outputStreams, outputStream]);\n};\n\n// Multiple subprocesses might be piping from/to `process.std*` at the same time.\n// This is not necessarily an error and should not print a `maxListeners` warning.\nconst setStandardStreamMaxListeners = (stream, {signal}) => {\n\tif (isStandardStream(stream)) {\n\t\tincrementMaxListeners(stream, MAX_LISTENERS_INCREMENT, signal);\n\t}\n};\n\n// `source.pipe(destination)` adds at most 1 listener for each event.\n// If `stdin` option is an array, the values might be combined with `merge-streams`.\n// That library also listens for `source` end, which adds 1 more listener.\nconst MAX_LISTENERS_INCREMENT = 2;\n", "import {addAbortListener} from 'node:events';\nimport {onExit} from 'signal-exit';\n\n// If the `cleanup` option is used, call `subprocess.kill()` when the parent process exits\nexport const cleanupOnExit = (subprocess, {cleanup, detached}, {signal}) => {\n\tif (!cleanup || detached) {\n\t\treturn;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tsubprocess.kill();\n\t});\n\taddAbortListener(signal, () => {\n\t\tremoveExitHandler();\n\t});\n};\n", "/**\n * This is not the set of all possible signals.\n *\n * It IS, however, the set of all signals that trigger\n * an exit on either Linux or BSD systems.  Linux is a\n * superset of the signal names supported on BSD, and\n * the unknown signals just fail to register, so we can\n * catch that easily enough.\n *\n * Windows signals are a different set, since there are\n * signals that terminate Windows processes, but don't\n * terminate (or don't even exist) on Posix systems.\n *\n * Don't bother with SIGKILL.  It's uncatchable, which\n * means that we can't fire any callbacks anyway.\n *\n * If a user does happen to register a handler on a non-\n * fatal signal like SIGWINCH or something, and then\n * exit, it'll end up firing `process.emit('exit')`, so\n * the handler will be fired anyway.\n *\n * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n * artificially, inherently leave the process in a\n * state from which it is not safe to try and enter JS\n * listeners.\n */\nexport const signals: NodeJS.Signals[] = []\nsignals.push('SIGHUP', 'SIGINT', 'SIGTERM')\n\nif (process.platform !== 'win32') {\n  signals.push(\n    'SIGALRM',\n    'SIGABRT',\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT')\n}\n", "// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nimport { signals } from './signals.js'\nexport { signals }\n\n// just a loosened process type so we can do some evil things\ntype ProcessRE = NodeJS.Process & {\n  reallyExit: (code?: number | undefined | null) => any\n  emit: (ev: string, ...a: any[]) => any\n}\n\nconst processOk = (process: any): process is ProcessRE =>\n  !!process &&\n  typeof process === 'object' &&\n  typeof process.removeListener === 'function' &&\n  typeof process.emit === 'function' &&\n  typeof process.reallyExit === 'function' &&\n  typeof process.listeners === 'function' &&\n  typeof process.kill === 'function' &&\n  typeof process.pid === 'number' &&\n  typeof process.on === 'function'\n\nconst kExitEmitter = Symbol.for('signal-exit emitter')\nconst global: typeof globalThis & { [kExitEmitter]?: Emitter } = globalThis\nconst ObjectDefineProperty = Object.defineProperty.bind(Object)\n\n/**\n * A function that takes an exit code and signal as arguments\n *\n * In the case of signal exits *only*, a return value of true\n * will indicate that the signal is being handled, and we should\n * not synthetically exit with the signal we received. Regardless\n * of the handler return value, the handler is unloaded when an\n * otherwise fatal signal is received, so you get exactly 1 shot\n * at it, unless you add another onExit handler at that point.\n *\n * In the case of numeric code exits, we may already have committed\n * to exiting the process, for example via a fatal exception or\n * unhandled promise rejection, so it is impossible to stop safely.\n */\nexport type Handler = (\n  code: number | null | undefined,\n  signal: NodeJS.Signals | null\n) => true | void\ntype ExitEvent = 'afterExit' | 'exit'\ntype Emitted = { [k in ExitEvent]: boolean }\ntype Listeners = { [k in ExitEvent]: Handler[] }\n\n// teeny special purpose ee\nclass Emitter {\n  emitted: Emitted = {\n    afterExit: false,\n    exit: false,\n  }\n\n  listeners: Listeners = {\n    afterExit: [],\n    exit: [],\n  }\n\n  count: number = 0\n  id: number = Math.random()\n\n  constructor() {\n    if (global[kExitEmitter]) {\n      return global[kExitEmitter]\n    }\n    ObjectDefineProperty(global, kExitEmitter, {\n      value: this,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    })\n  }\n\n  on(ev: ExitEvent, fn: Handler) {\n    this.listeners[ev].push(fn)\n  }\n\n  removeListener(ev: ExitEvent, fn: Handler) {\n    const list = this.listeners[ev]\n    const i = list.indexOf(fn)\n    /* c8 ignore start */\n    if (i === -1) {\n      return\n    }\n    /* c8 ignore stop */\n    if (i === 0 && list.length === 1) {\n      list.length = 0\n    } else {\n      list.splice(i, 1)\n    }\n  }\n\n  emit(\n    ev: ExitEvent,\n    code: number | null | undefined,\n    signal: NodeJS.Signals | null\n  ): boolean {\n    if (this.emitted[ev]) {\n      return false\n    }\n    this.emitted[ev] = true\n    let ret: boolean = false\n    for (const fn of this.listeners[ev]) {\n      ret = fn(code, signal) === true || ret\n    }\n    if (ev === 'exit') {\n      ret = this.emit('afterExit', code, signal) || ret\n    }\n    return ret\n  }\n}\n\nabstract class SignalExitBase {\n  abstract onExit(cb: Handler, opts?: { alwaysLast?: boolean }): () => void\n  abstract load(): void\n  abstract unload(): void\n}\n\nconst signalExitWrap = <T extends SignalExitBase>(handler: T) => {\n  return {\n    onExit(cb: Handler, opts?: { alwaysLast?: boolean }) {\n      return handler.onExit(cb, opts)\n    },\n    load() {\n      return handler.load()\n    },\n    unload() {\n      return handler.unload()\n    },\n  }\n}\n\nclass SignalExitFallback extends SignalExitBase {\n  onExit() {\n    return () => {}\n  }\n  load() {}\n  unload() {}\n}\n\nclass SignalExit extends SignalExitBase {\n  // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n  // so use a supported signal instead\n  /* c8 ignore start */\n  #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP'\n  /* c8 ignore stop */\n  #emitter = new Emitter()\n  #process: ProcessRE\n  #originalProcessEmit: ProcessRE['emit']\n  #originalProcessReallyExit: ProcessRE['reallyExit']\n\n  #sigListeners: { [k in NodeJS.Signals]?: () => void } = {}\n  #loaded: boolean = false\n\n  constructor(process: ProcessRE) {\n    super()\n    this.#process = process\n    // { <signal>: <listener fn>, ... }\n    this.#sigListeners = {}\n    for (const sig of signals) {\n      this.#sigListeners[sig] = () => {\n        // If there are no other listeners, an exit is coming!\n        // Simplest way: remove us and then re-send the signal.\n        // We know that this will kill the process, so we can\n        // safely emit now.\n        const listeners = this.#process.listeners(sig)\n        let { count } = this.#emitter\n        // This is a workaround for the fact that signal-exit v3 and signal\n        // exit v4 are not aware of each other, and each will attempt to let\n        // the other handle it, so neither of them do. To correct this, we\n        // detect if we're the only handler *except* for previous versions\n        // of signal-exit, and increment by the count of listeners it has\n        // created.\n        /* c8 ignore start */\n        const p = process as unknown as {\n          __signal_exit_emitter__?: { count: number }\n        }\n        if (\n          typeof p.__signal_exit_emitter__ === 'object' &&\n          typeof p.__signal_exit_emitter__.count === 'number'\n        ) {\n          count += p.__signal_exit_emitter__.count\n        }\n        /* c8 ignore stop */\n        if (listeners.length === count) {\n          this.unload()\n          const ret = this.#emitter.emit('exit', null, sig)\n          /* c8 ignore start */\n          const s = sig === 'SIGHUP' ? this.#hupSig : sig\n          if (!ret) process.kill(process.pid, s)\n          /* c8 ignore stop */\n        }\n      }\n    }\n\n    this.#originalProcessReallyExit = process.reallyExit\n    this.#originalProcessEmit = process.emit\n  }\n\n  onExit(cb: Handler, opts?: { alwaysLast?: boolean }) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return () => {}\n    }\n    /* c8 ignore stop */\n\n    if (this.#loaded === false) {\n      this.load()\n    }\n\n    const ev = opts?.alwaysLast ? 'afterExit' : 'exit'\n    this.#emitter.on(ev, cb)\n    return () => {\n      this.#emitter.removeListener(ev, cb)\n      if (\n        this.#emitter.listeners['exit'].length === 0 &&\n        this.#emitter.listeners['afterExit'].length === 0\n      ) {\n        this.unload()\n      }\n    }\n  }\n\n  load() {\n    if (this.#loaded) {\n      return\n    }\n    this.#loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    this.#emitter.count += 1\n\n    for (const sig of signals) {\n      try {\n        const fn = this.#sigListeners[sig]\n        if (fn) this.#process.on(sig, fn)\n      } catch (_) {}\n    }\n\n    this.#process.emit = (ev: string, ...a: any[]) => {\n      return this.#processEmit(ev, ...a)\n    }\n    this.#process.reallyExit = (code?: number | null | undefined) => {\n      return this.#processReallyExit(code)\n    }\n  }\n\n  unload() {\n    if (!this.#loaded) {\n      return\n    }\n    this.#loaded = false\n\n    signals.forEach(sig => {\n      const listener = this.#sigListeners[sig]\n      /* c8 ignore start */\n      if (!listener) {\n        throw new Error('Listener not defined for signal: ' + sig)\n      }\n      /* c8 ignore stop */\n      try {\n        this.#process.removeListener(sig, listener)\n        /* c8 ignore start */\n      } catch (_) {}\n      /* c8 ignore stop */\n    })\n    this.#process.emit = this.#originalProcessEmit\n    this.#process.reallyExit = this.#originalProcessReallyExit\n    this.#emitter.count -= 1\n  }\n\n  #processReallyExit(code?: number | null | undefined) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return 0\n    }\n    this.#process.exitCode = code || 0\n    /* c8 ignore stop */\n\n    this.#emitter.emit('exit', this.#process.exitCode, null)\n    return this.#originalProcessReallyExit.call(\n      this.#process,\n      this.#process.exitCode\n    )\n  }\n\n  #processEmit(ev: string, ...args: any[]): any {\n    const og = this.#originalProcessEmit\n    if (ev === 'exit' && processOk(this.#process)) {\n      if (typeof args[0] === 'number') {\n        this.#process.exitCode = args[0]\n        /* c8 ignore start */\n      }\n      /* c8 ignore start */\n      const ret = og.call(this.#process, ev, ...args)\n      /* c8 ignore start */\n      this.#emitter.emit('exit', this.#process.exitCode, null)\n      /* c8 ignore stop */\n      return ret\n    } else {\n      return og.call(this.#process, ev, ...args)\n    }\n  }\n}\n\nconst process = globalThis.process\n// wrap so that we call the method on the actual handler, without\n// exporting it directly.\nexport const {\n  /**\n   * Called when the process is exiting, whether via signal, explicit\n   * exit, or running out of stuff to do.\n   *\n   * If the global process object is not suitable for instrumentation,\n   * then this will be a no-op.\n   *\n   * Returns a function that may be used to unload signal-exit.\n   */\n  onExit,\n\n  /**\n   * Load the listeners.  Likely you never need to call this, unless\n   * doing a rather deep integration with signal-exit functionality.\n   * Mostly exposed for the benefit of testing.\n   *\n   * @internal\n   */\n  load,\n\n  /**\n   * Unload the listeners.  Likely you never need to call this, unless\n   * doing a rather deep integration with signal-exit functionality.\n   * Mostly exposed for the benefit of testing.\n   *\n   * @internal\n   */\n  unload,\n} = signalExitWrap(\n  processOk(process) ? new SignalExit(process) : new SignalExitFallback()\n)\n", "import {normalizeParameters} from '../methods/parameters.js';\nimport {getStartTime} from '../return/duration.js';\nimport {SUBPROCESS_OPTIONS, getToStream, getFromStream} from '../arguments/fd-options.js';\n\n// Normalize and validate arguments passed to `source.pipe(destination)`\nexport const normalizePipeArguments = ({source, sourcePromise, boundOptions, createNested}, ...pipeArguments) => {\n\tconst startTime = getStartTime();\n\tconst {\n\t\tdestination,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tfrom,\n\t\tunpipeSignal,\n\t} = getDestinationStream(boundOptions, createNested, pipeArguments);\n\tconst {sourceStream, sourceError} = getSourceStream(source, from);\n\tconst {options: sourceOptions, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);\n\treturn {\n\t\tsourcePromise,\n\t\tsourceStream,\n\t\tsourceOptions,\n\t\tsourceError,\n\t\tdestination,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tunpipeSignal,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t};\n};\n\nconst getDestinationStream = (boundOptions, createNested, pipeArguments) => {\n\ttry {\n\t\tconst {\n\t\t\tdestination,\n\t\t\tpipeOptions: {from, to, unpipeSignal} = {},\n\t\t} = getDestination(boundOptions, createNested, ...pipeArguments);\n\t\tconst destinationStream = getToStream(destination, to);\n\t\treturn {\n\t\t\tdestination,\n\t\t\tdestinationStream,\n\t\t\tfrom,\n\t\t\tunpipeSignal,\n\t\t};\n\t} catch (error) {\n\t\treturn {destinationError: error};\n\t}\n};\n\n// Piping subprocesses can use three syntaxes:\n//  - source.pipe('command', commandArguments, pipeOptionsOrDestinationOptions)\n//  - source.pipe`command commandArgument` or source.pipe(pipeOptionsOrDestinationOptions)`command commandArgument`\n//  - source.pipe(execa(...), pipeOptions)\nconst getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {\n\tif (Array.isArray(firstArgument)) {\n\t\tconst destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);\n\t\treturn {destination, pipeOptions: boundOptions};\n\t}\n\n\tif (typeof firstArgument === 'string' || firstArgument instanceof URL) {\n\t\tif (Object.keys(boundOptions).length > 0) {\n\t\t\tthrow new TypeError('Please use .pipe(\"file\", ..., options) or .pipe(execa(\"file\", ..., options)) instead of .pipe(options)(\"file\", ...).');\n\t\t}\n\n\t\tconst [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);\n\t\tconst destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);\n\t\treturn {destination, pipeOptions: rawOptions};\n\t}\n\n\tif (SUBPROCESS_OPTIONS.has(firstArgument)) {\n\t\tif (Object.keys(boundOptions).length > 0) {\n\t\t\tthrow new TypeError('Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).');\n\t\t}\n\n\t\treturn {destination: firstArgument, pipeOptions: pipeArguments[0]};\n\t}\n\n\tthrow new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);\n};\n\n// Force `stdin: 'pipe'` with the destination subprocess\nconst mapDestinationArguments = ({options}) => ({options: {...options, stdin: 'pipe', piped: true}});\n\nconst getSourceStream = (source, from) => {\n\ttry {\n\t\tconst sourceStream = getFromStream(source, from);\n\t\treturn {sourceStream};\n\t} catch (error) {\n\t\treturn {sourceError: error};\n\t}\n};\n", "import {makeEarlyError} from '../return/result.js';\nimport {abortSourceStream, endDestinationStream} from '../io/pipeline.js';\n\n// When passing invalid arguments to `source.pipe()`, throw asynchronously.\n// We also abort both subprocesses.\nexport const handlePipeArgumentsError = ({\n\tsourceStream,\n\tsourceError,\n\tdestinationStream,\n\tdestinationError,\n\tfileDescriptors,\n\tsourceOptions,\n\tstartTime,\n}) => {\n\tconst error = getPipeArgumentsError({\n\t\tsourceStream,\n\t\tsourceError,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t});\n\tif (error !== undefined) {\n\t\tthrow createNonCommandError({\n\t\t\terror,\n\t\t\tfileDescriptors,\n\t\t\tsourceOptions,\n\t\t\tstartTime,\n\t\t});\n\t}\n};\n\nconst getPipeArgumentsError = ({sourceStream, sourceError, destinationStream, destinationError}) => {\n\tif (sourceError !== undefined && destinationError !== undefined) {\n\t\treturn destinationError;\n\t}\n\n\tif (destinationError !== undefined) {\n\t\tabortSourceStream(sourceStream);\n\t\treturn destinationError;\n\t}\n\n\tif (sourceError !== undefined) {\n\t\tendDestinationStream(destinationStream);\n\t\treturn sourceError;\n\t}\n};\n\n// Specific error return value when passing invalid arguments to `subprocess.pipe()` or when using `unpipeSignal`\nexport const createNonCommandError = ({error, fileDescriptors, sourceOptions, startTime}) => makeEarlyError({\n\terror,\n\tcommand: PIPE_COMMAND_MESSAGE,\n\tescapedCommand: PIPE_COMMAND_MESSAGE,\n\tfileDescriptors,\n\toptions: sourceOptions,\n\tstartTime,\n\tisSync: false,\n});\n\nconst PIPE_COMMAND_MESSAGE = 'source.pipe(destination)';\n", "// Like Bash, we await both subprocesses. This is unlike some other shells which only await the destination subprocess.\n// Like Bash with the `pipefail` option, if either subprocess fails, the whole pipe fails.\n// Like Bash, if both subprocesses fail, we return the failure of the destination.\n// This ensures both subprocesses' errors are present, using `error.pipedFrom`.\nexport const waitForBothSubprocesses = async subprocessPromises => {\n\tconst [\n\t\t{status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason},\n\t\t{status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason},\n\t] = await subprocessPromises;\n\n\tif (!destinationResult.pipedFrom.includes(sourceResult)) {\n\t\tdestinationResult.pipedFrom.push(sourceResult);\n\t}\n\n\tif (destinationStatus === 'rejected') {\n\t\tthrow destinationResult;\n\t}\n\n\tif (sourceStatus === 'rejected') {\n\t\tthrow sourceResult;\n\t}\n\n\treturn destinationResult;\n};\n", "import {finished} from 'node:stream/promises';\nimport mergeStreams from '@sindresorhus/merge-streams';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {pipeStreams} from '../io/pipeline.js';\n\n// The piping behavior is like Bash.\n// In particular, when one subprocess exits, the other is not terminated by a signal.\n// Instead, its stdout (for the source) or stdin (for the destination) closes.\n// If the subprocess uses it, it will make it error with SIGPIPE or EPIPE (for the source) or end (for the destination).\n// If it does not use it, it will continue running.\n// This allows for subprocesses to gracefully exit and lower the coupling between subprocesses.\nexport const pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {\n\tconst mergedStream = MERGED_STREAMS.has(destinationStream)\n\t\t? pipeMoreSubprocessStream(sourceStream, destinationStream)\n\t\t: pipeFirstSubprocessStream(sourceStream, destinationStream);\n\tincrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);\n\tincrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);\n\tcleanupMergedStreamsMap(destinationStream);\n\treturn mergedStream;\n};\n\n// We use `merge-streams` to allow for multiple sources to pipe to the same destination.\nconst pipeFirstSubprocessStream = (sourceStream, destinationStream) => {\n\tconst mergedStream = mergeStreams([sourceStream]);\n\tpipeStreams(mergedStream, destinationStream);\n\tMERGED_STREAMS.set(destinationStream, mergedStream);\n\treturn mergedStream;\n};\n\nconst pipeMoreSubprocessStream = (sourceStream, destinationStream) => {\n\tconst mergedStream = MERGED_STREAMS.get(destinationStream);\n\tmergedStream.add(sourceStream);\n\treturn mergedStream;\n};\n\nconst cleanupMergedStreamsMap = async destinationStream => {\n\ttry {\n\t\tawait finished(destinationStream, {cleanup: true, readable: false, writable: true});\n\t} catch {}\n\n\tMERGED_STREAMS.delete(destinationStream);\n};\n\nconst MERGED_STREAMS = new WeakMap();\n\n// Number of listeners set up on `sourceStream` by each `sourceStream.pipe(destinationStream)`\n// Those are added by `merge-streams`\nconst SOURCE_LISTENERS_PER_PIPE = 2;\n// Number of listeners set up on `destinationStream` by each `sourceStream.pipe(destinationStream)`\n// Those are added by `finished()` in `cleanupMergedStreamsMap()`\nconst DESTINATION_LISTENERS_PER_PIPE = 1;\n", "import {aborted} from 'node:util';\nimport {createNonCommandError} from './throw.js';\n\n// When passing an `unpipeSignal` option, abort piping when the signal is aborted.\n// However, do not terminate the subprocesses.\nexport const unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined\n\t? []\n\t: [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];\n\nconst unpipeOnSignalAbort = async (unpipeSignal, {sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime}) => {\n\tawait aborted(unpipeSignal, sourceStream);\n\tawait mergedStream.remove(sourceStream);\n\tconst error = new Error('Pipe canceled by `unpipeSignal` option.');\n\tthrow createNonCommandError({\n\t\terror,\n\t\tfileDescriptors,\n\t\tsourceOptions,\n\t\tstartTime,\n\t});\n};\n", "import isPlainObject from 'is-plain-obj';\nimport {normalizePipeArguments} from './pipe-arguments.js';\nimport {handlePipeArgumentsError} from './throw.js';\nimport {waitForBothSubprocesses} from './sequence.js';\nimport {pipeSubprocessStream} from './streaming.js';\nimport {unpipeOnAbort} from './abort.js';\n\n// Pipe a subprocess' `stdout`/`stderr`/`stdio` into another subprocess' `stdin`\nexport const pipeToSubprocess = (sourceInfo, ...pipeArguments) => {\n\tif (isPlainObject(pipeArguments[0])) {\n\t\treturn pipeToSubprocess.bind(undefined, {\n\t\t\t...sourceInfo,\n\t\t\tboundOptions: {...sourceInfo.boundOptions, ...pipeArguments[0]},\n\t\t});\n\t}\n\n\tconst {destination, ...normalizedInfo} = normalizePipeArguments(sourceInfo, ...pipeArguments);\n\tconst promise = handlePipePromise({...normalizedInfo, destination});\n\tpromise.pipe = pipeToSubprocess.bind(undefined, {\n\t\t...sourceInfo,\n\t\tsource: destination,\n\t\tsourcePromise: promise,\n\t\tboundOptions: {},\n\t});\n\treturn promise;\n};\n\n// Asynchronous logic when piping subprocesses\nconst handlePipePromise = async ({\n\tsourcePromise,\n\tsourceStream,\n\tsourceOptions,\n\tsourceError,\n\tdestination,\n\tdestinationStream,\n\tdestinationError,\n\tunpipeSignal,\n\tfileDescriptors,\n\tstartTime,\n}) => {\n\tconst subprocessPromises = getSubprocessPromises(sourcePromise, destination);\n\thandlePipeArgumentsError({\n\t\tsourceStream,\n\t\tsourceError,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tfileDescriptors,\n\t\tsourceOptions,\n\t\tstartTime,\n\t});\n\tconst maxListenersController = new AbortController();\n\ttry {\n\t\tconst mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);\n\t\treturn await Promise.race([\n\t\t\twaitForBothSubprocesses(subprocessPromises),\n\t\t\t...unpipeOnAbort(unpipeSignal, {\n\t\t\t\tsourceStream,\n\t\t\t\tmergedStream,\n\t\t\t\tsourceOptions,\n\t\t\t\tfileDescriptors,\n\t\t\t\tstartTime,\n\t\t\t}),\n\t\t]);\n\t} finally {\n\t\tmaxListenersController.abort();\n\t}\n};\n\n// `.pipe()` awaits the subprocess promises.\n// When invalid arguments are passed to `.pipe()`, we throw an error, which prevents awaiting them.\n// We need to ensure this does not create unhandled rejections.\nconst getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);\n", "import {setImmediate} from 'node:timers/promises';\nimport getStream, {getStreamAsArrayBuffer, getStreamAsArray} from 'get-stream';\nimport {isArrayBuffer} from '../utils/uint-array.js';\nimport {shouldLogOutput, logLines} from '../verbose/output.js';\nimport {iterateForResult} from './iterate.js';\nimport {handleMaxBuffer} from './max-buffer.js';\nimport {getStripFinalNewline} from './strip-newline.js';\n\n// Retrieve `result.stdout|stderr|all|stdio[*]`\nexport const getStreamOutput = async ({stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {\n\tconst logPromise = logOutputAsync({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tfdNumber,\n\t\tencoding,\n\t\tallMixed,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\n\tif (!buffer) {\n\t\tawait Promise.all([resumeStream(stream), logPromise]);\n\t\treturn;\n\t}\n\n\tconst stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline, fdNumber);\n\tconst iterable = iterateForResult({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tlines,\n\t\tencoding,\n\t\tstripFinalNewline: stripFinalNewlineValue,\n\t\tallMixed,\n\t});\n\tconst [output] = await Promise.all([\n\t\tgetStreamContents({\n\t\t\tstream,\n\t\t\titerable,\n\t\t\tfdNumber,\n\t\t\tencoding,\n\t\t\tmaxBuffer,\n\t\t\tlines,\n\t\t}),\n\t\tlogPromise,\n\t]);\n\treturn output;\n};\n\nconst logOutputAsync = async ({stream, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: {fileDescriptors}}) => {\n\tif (!shouldLogOutput({\n\t\tstdioItems: fileDescriptors[fdNumber]?.stdioItems,\n\t\tencoding,\n\t\tverboseInfo,\n\t\tfdNumber,\n\t})) {\n\t\treturn;\n\t}\n\n\tconst linesIterable = iterateForResult({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tlines: true,\n\t\tencoding,\n\t\tstripFinalNewline: true,\n\t\tallMixed,\n\t});\n\tawait logLines(linesIterable, stream, fdNumber, verboseInfo);\n};\n\n// When using `buffer: false`, users need to read `subprocess.stdout|stderr|all` right away\n// See https://github.com/sindresorhus/execa/issues/730 and https://github.com/sindresorhus/execa/pull/729#discussion_r1465496310\nconst resumeStream = async stream => {\n\tawait setImmediate();\n\tif (stream.readableFlowing === null) {\n\t\tstream.resume();\n\t}\n};\n\nconst getStreamContents = async ({stream, stream: {readableObjectMode}, iterable, fdNumber, encoding, maxBuffer, lines}) => {\n\ttry {\n\t\tif (readableObjectMode || lines) {\n\t\t\treturn await getStreamAsArray(iterable, {maxBuffer});\n\t\t}\n\n\t\tif (encoding === 'buffer') {\n\t\t\treturn new Uint8Array(await getStreamAsArrayBuffer(iterable, {maxBuffer}));\n\t\t}\n\n\t\treturn await getStream(iterable, {maxBuffer});\n\t} catch (error) {\n\t\treturn handleBufferedData(handleMaxBuffer({\n\t\t\terror,\n\t\t\tstream,\n\t\t\treadableObjectMode,\n\t\t\tlines,\n\t\t\tencoding,\n\t\t\tfdNumber,\n\t\t}));\n\t}\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\n// They are automatically closed and flushed by Node.js when the subprocess exits\n// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve\nexport const getBufferedData = async streamPromise => {\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn handleBufferedData(error);\n\t}\n};\n\n// Ensure we are returning Uint8Arrays when using `encoding: 'buffer'`\nconst handleBufferedData = ({bufferedData}) => isArrayBuffer(bufferedData)\n\t? new Uint8Array(bufferedData)\n\t: bufferedData;\n", "import {on} from 'node:events';\nimport {getDefaultHighWaterMark} from 'node:stream';\nimport {getEncodingTransformGenerator} from '../transform/encoding-transform.js';\nimport {getSplitLinesGenerator} from '../transform/split.js';\nimport {transformChunkSync, finalChunksSync} from '../transform/run-sync.js';\n\n// Iterate over lines of `subprocess.stdout`, used by `subprocess.readable|duplex|iterable()`\nexport const iterateOnSubprocessStream = ({subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines}) => {\n\tconst controller = new AbortController();\n\tstopReadingOnExit(subprocess, controller);\n\treturn iterateOnStream({\n\t\tstream: subprocessStdout,\n\t\tcontroller,\n\t\tbinary,\n\t\tshouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,\n\t\tencoding,\n\t\tshouldSplit: !subprocessStdout.readableObjectMode,\n\t\tpreserveNewlines,\n\t});\n};\n\nconst stopReadingOnExit = async (subprocess, controller) => {\n\ttry {\n\t\tawait subprocess;\n\t} catch {} finally {\n\t\tcontroller.abort();\n\t}\n};\n\n// Iterate over lines of `subprocess.stdout`, used by `result.stdout` and the `verbose: 'full'` option.\n// Applies the `lines` and `encoding` options.\nexport const iterateForResult = ({stream, onStreamEnd, lines, encoding, stripFinalNewline, allMixed}) => {\n\tconst controller = new AbortController();\n\tstopReadingOnStreamEnd(onStreamEnd, controller, stream);\n\tconst objectMode = stream.readableObjectMode && !allMixed;\n\treturn iterateOnStream({\n\t\tstream,\n\t\tcontroller,\n\t\tbinary: encoding === 'buffer',\n\t\tshouldEncode: !objectMode,\n\t\tencoding,\n\t\tshouldSplit: !objectMode && lines,\n\t\tpreserveNewlines: !stripFinalNewline,\n\t});\n};\n\nconst stopReadingOnStreamEnd = async (onStreamEnd, controller, stream) => {\n\ttry {\n\t\tawait onStreamEnd;\n\t} catch {\n\t\tstream.destroy();\n\t} finally {\n\t\tcontroller.abort();\n\t}\n};\n\nconst iterateOnStream = ({stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => {\n\tconst onStdoutChunk = on(stream, 'data', {\n\t\tsignal: controller.signal,\n\t\thighWaterMark: HIGH_WATER_MARK,\n\t\t// Backward compatibility with older name for this option\n\t\t// See https://github.com/nodejs/node/pull/52080#discussion_r1525227861\n\t\t// @todo Remove after removing support for Node 21\n\t\thighWatermark: HIGH_WATER_MARK,\n\t});\n\treturn iterateOnData({\n\t\tonStdoutChunk,\n\t\tcontroller,\n\t\tbinary,\n\t\tshouldEncode,\n\t\tencoding,\n\t\tshouldSplit,\n\t\tpreserveNewlines,\n\t});\n};\n\nexport const DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark(true);\n\n// The `highWaterMark` of `events.on()` is measured in number of events, not in bytes.\n// Not knowing the average amount of bytes per `data` event, we use the same heuristic as streams in objectMode, since they have the same issue.\n// Therefore, we use the value of `getDefaultHighWaterMark(true)`.\n// Note: this option does not exist on Node 18, but this is ok since the logic works without it. It just consumes more memory.\nconst HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;\n\nconst iterateOnData = async function * ({onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) {\n\tconst generators = getGenerators({\n\t\tbinary,\n\t\tshouldEncode,\n\t\tencoding,\n\t\tshouldSplit,\n\t\tpreserveNewlines,\n\t});\n\n\ttry {\n\t\tfor await (const [chunk] of onStdoutChunk) {\n\t\t\tyield * transformChunkSync(chunk, generators, 0);\n\t\t}\n\t} catch (error) {\n\t\tif (!controller.signal.aborted) {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tyield * finalChunksSync(generators);\n\t}\n};\n\nconst getGenerators = ({binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => [\n\tgetEncodingTransformGenerator(binary, encoding, !shouldEncode),\n\tgetSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {}),\n].filter(Boolean);\n", "import {finished} from 'node:stream/promises';\n\n// Wraps `finished(stream)` to handle the following case:\n//  - When the subprocess exits, Node.js automatically calls `subprocess.stdin.destroy()`, which we need to ignore.\n//  - However, we still need to throw if `subprocess.stdin.destroy()` is called before subprocess exit.\nexport const waitForStream = async (stream, fdNumber, streamInfo, {isSameDirection, stopOnExit = false} = {}) => {\n\tconst state = handleStdinDestroy(stream, streamInfo);\n\tconst abortController = new AbortController();\n\ttry {\n\t\tawait Promise.race([\n\t\t\t...(stopOnExit ? [streamInfo.exitPromise] : []),\n\t\t\tfinished(stream, {cleanup: true, signal: abortController.signal}),\n\t\t]);\n\t} catch (error) {\n\t\tif (!state.stdinCleanedUp) {\n\t\t\thandleStreamError(error, fdNumber, streamInfo, isSameDirection);\n\t\t}\n\t} finally {\n\t\tabortController.abort();\n\t}\n};\n\n// If `subprocess.stdin` is destroyed before being fully written to, it is considered aborted and should throw an error.\n// This can happen for example when user called `subprocess.stdin.destroy()` before `subprocess.stdin.end()`.\n// However, Node.js calls `subprocess.stdin.destroy()` on exit for cleanup purposes.\n// https://github.com/nodejs/node/blob/0b4cdb4b42956cbd7019058e409e06700a199e11/lib/internal/child_process.js#L278\n// This is normal and should not throw an error.\n// Therefore, we need to differentiate between both situations to know whether to throw an error.\n// Unfortunately, events (`close`, `error`, `end`, `exit`) cannot be used because `.destroy()` can take an arbitrary amount of time.\n// For example, `stdin: 'pipe'` is implemented as a TCP socket, and its `.destroy()` method waits for TCP disconnection.\n// Therefore `.destroy()` might end before or after subprocess exit, based on OS speed and load.\n// The only way to detect this is to spy on `subprocess.stdin._destroy()` by wrapping it.\n// If `subprocess.exitCode` or `subprocess.signalCode` is set, it means `.destroy()` is being called by Node.js itself.\nconst handleStdinDestroy = (stream, {originalStreams: [originalStdin], subprocess}) => {\n\tconst state = {stdinCleanedUp: false};\n\tif (stream === originalStdin) {\n\t\tspyOnStdinDestroy(stream, subprocess, state);\n\t}\n\n\treturn state;\n};\n\nconst spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {\n\tconst {_destroy} = subprocessStdin;\n\tsubprocessStdin._destroy = (...destroyArguments) => {\n\t\tsetStdinCleanedUp(subprocess, state);\n\t\t_destroy.call(subprocessStdin, ...destroyArguments);\n\t};\n};\n\nconst setStdinCleanedUp = ({exitCode, signalCode}, state) => {\n\tif (exitCode !== null || signalCode !== null) {\n\t\tstate.stdinCleanedUp = true;\n\t}\n};\n\n// We ignore EPIPEs on writable streams and aborts on readable streams since those can happen normally.\n// When one stream errors, the error is propagated to the other streams on the same file descriptor.\n// Those other streams might have a different direction due to the above.\n// When this happens, the direction of both the initial stream and the others should then be taken into account.\n// Therefore, we keep track of whether a stream error is currently propagating.\nconst handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {\n\tif (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {\n\t\tthrow error;\n\t}\n};\n\nconst shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {\n\tif (streamInfo.propagating) {\n\t\treturn isStreamEpipe(error) || isStreamAbort(error);\n\t}\n\n\tstreamInfo.propagating = true;\n\treturn isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection\n\t\t? isStreamEpipe(error)\n\t\t: isStreamAbort(error);\n};\n\n// Unfortunately, we cannot use the stream's class or properties to know whether it is readable or writable.\n// For example, `subprocess.stdin` is technically a Duplex, but can only be used as a writable.\n// Therefore, we need to use the file descriptor's direction (`stdin` is input, `stdout` is output, etc.).\n// However, while `subprocess.std*` and transforms follow that direction, any stream passed the `std*` option has the opposite direction.\n// For example, `subprocess.stdin` is a writable, but the `stdin` option is a readable.\nexport const isInputFileDescriptor = ({fileDescriptors}, fdNumber) => fdNumber !== 'all' && fileDescriptors[fdNumber].direction === 'input';\n\n// When `stream.destroy()` is called without an `error` argument, stream is aborted.\n// This is the only way to abort a readable stream, which can be useful in some instances.\n// Therefore, we ignore this error on readable streams.\nexport const isStreamAbort = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';\n\n// When `stream.write()` is called but the underlying source has been closed, `EPIPE` is emitted.\n// When piping subprocesses, the source subprocess usually decides when to stop piping.\n// However, there are some instances when the destination does instead, such as `... | head -n1`.\n// It notifies the source by using `EPIPE`.\n// Therefore, we ignore this error on writable streams.\nconst isStreamEpipe = error => error?.code === 'EPIPE';\n", "import {getStreamOutput} from '../io/contents.js';\nimport {waitForStream, isInputFileDescriptor} from './wait-stream.js';\n\n// Read the contents of `subprocess.std*` and|or wait for its completion\nexport const waitForStdioStreams = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => subprocess.stdio.map((stream, fdNumber) => waitForSubprocessStream({\n\tstream,\n\tfdNumber,\n\tencoding,\n\tbuffer: buffer[fdNumber],\n\tmaxBuffer: maxBuffer[fdNumber],\n\tlines: lines[fdNumber],\n\tallMixed: false,\n\tstripFinalNewline,\n\tverboseInfo,\n\tstreamInfo,\n}));\n\n// Read the contents of `subprocess.std*` or `subprocess.all` and|or wait for its completion\nexport const waitForSubprocessStream = async ({stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tconst onStreamEnd = waitForStream(stream, fdNumber, streamInfo);\n\tif (isInputFileDescriptor(streamInfo, fdNumber)) {\n\t\tawait onStreamEnd;\n\t\treturn;\n\t}\n\n\tconst [output] = await Promise.all([\n\t\tgetStreamOutput({\n\t\t\tstream,\n\t\t\tonStreamEnd,\n\t\t\tfdNumber,\n\t\t\tencoding,\n\t\t\tbuffer,\n\t\t\tmaxBuffer,\n\t\t\tlines,\n\t\t\tallMixed,\n\t\t\tstripFinalNewline,\n\t\t\tverboseInfo,\n\t\t\tstreamInfo,\n\t\t}),\n\t\tonStreamEnd,\n\t]);\n\treturn output;\n};\n", "import mergeStreams from '@sindresorhus/merge-streams';\nimport {waitForSubprocessStream} from './stdio.js';\n\n// `all` interleaves `stdout` and `stderr`\nexport const makeAllStream = ({stdout, stderr}, {all}) => all && (stdout || stderr)\n\t? mergeStreams([stdout, stderr].filter(Boolean))\n\t: undefined;\n\n// Read the contents of `subprocess.all` and|or wait for its completion\nexport const waitForAllStream = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => waitForSubprocessStream({\n\t...getAllStream(subprocess, buffer),\n\tfdNumber: 'all',\n\tencoding,\n\tmaxBuffer: maxBuffer[1] + maxBuffer[2],\n\tlines: lines[1] || lines[2],\n\tallMixed: getAllMixed(subprocess),\n\tstripFinalNewline,\n\tverboseInfo,\n\tstreamInfo,\n});\n\nconst getAllStream = ({stdout, stderr, all}, [, bufferStdout, bufferStderr]) => {\n\tconst buffer = bufferStdout || bufferStderr;\n\tif (!buffer) {\n\t\treturn {stream: all, buffer};\n\t}\n\n\tif (!bufferStdout) {\n\t\treturn {stream: stderr, buffer};\n\t}\n\n\tif (!bufferStderr) {\n\t\treturn {stream: stdout, buffer};\n\t}\n\n\treturn {stream: all, buffer};\n};\n\n// When `subprocess.stdout` is in objectMode but not `subprocess.stderr` (or the opposite), we need to use both:\n//  - `getStreamAsArray()` for the chunks in objectMode, to return as an array without changing each chunk\n//  - `getStreamAsArrayBuffer()` or `getStream()` for the chunks not in objectMode, to convert them from Buffers to string or Uint8Array\n// We do this by emulating the Buffer -> string|Uint8Array conversion performed by `get-stream` with our own, which is identical.\nconst getAllMixed = ({all, stdout, stderr}) => all\n\t&& stdout\n\t&& stderr\n\t&& stdout.readableObjectMode !== stderr.readableObjectMode;\n", "import {once} from 'node:events';\nimport {isStream as isNodeStream} from 'is-stream';\nimport {throwOnTimeout} from '../terminate/timeout.js';\nimport {throwOnCancel} from '../terminate/cancel.js';\nimport {throwOnGracefulCancel} from '../terminate/graceful.js';\nimport {isStandardStream} from '../utils/standard-stream.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {getBufferedData} from '../io/contents.js';\nimport {waitForIpcOutput, getBufferedIpcOutput} from '../ipc/buffer-messages.js';\nimport {sendIpcInput} from '../ipc/ipc-input.js';\nimport {waitForAllStream} from './all-async.js';\nimport {waitForStdioStreams} from './stdio.js';\nimport {waitForExit, waitForSuccessfulExit} from './exit-async.js';\nimport {waitForStream} from './wait-stream.js';\n\n// Retrieve result of subprocess: exit code, signal, error, streams (stdout/stderr/all)\nexport const waitForSubprocessResult = async ({\n\tsubprocess,\n\toptions: {\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\ttimeoutDuration: timeout,\n\t\tcancelSignal,\n\t\tgracefulCancel,\n\t\tforceKillAfterDelay,\n\t\tstripFinalNewline,\n\t\tipc,\n\t\tipcInput,\n\t},\n\tcontext,\n\tverboseInfo,\n\tfileDescriptors,\n\toriginalStreams,\n\tonInternalError,\n\tcontroller,\n}) => {\n\tconst exitPromise = waitForExit(subprocess, context);\n\tconst streamInfo = {\n\t\toriginalStreams,\n\t\tfileDescriptors,\n\t\tsubprocess,\n\t\texitPromise,\n\t\tpropagating: false,\n\t};\n\n\tconst stdioPromises = waitForStdioStreams({\n\t\tsubprocess,\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\tconst allPromise = waitForAllStream({\n\t\tsubprocess,\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\tconst ipcOutput = [];\n\tconst ipcOutputPromise = waitForIpcOutput({\n\t\tsubprocess,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tipc,\n\t\tipcOutput,\n\t\tverboseInfo,\n\t});\n\tconst originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);\n\tconst customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);\n\n\ttry {\n\t\treturn await Promise.race([\n\t\t\tPromise.all([\n\t\t\t\t{},\n\t\t\t\twaitForSuccessfulExit(exitPromise),\n\t\t\t\tPromise.all(stdioPromises),\n\t\t\t\tallPromise,\n\t\t\t\tipcOutputPromise,\n\t\t\t\tsendIpcInput(subprocess, ipcInput),\n\t\t\t\t...originalPromises,\n\t\t\t\t...customStreamsEndPromises,\n\t\t\t]),\n\t\t\tonInternalError,\n\t\t\tthrowOnSubprocessError(subprocess, controller),\n\t\t\t...throwOnTimeout(subprocess, timeout, context, controller),\n\t\t\t...throwOnCancel({\n\t\t\t\tsubprocess,\n\t\t\t\tcancelSignal,\n\t\t\t\tgracefulCancel,\n\t\t\t\tcontext,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t\t...throwOnGracefulCancel({\n\t\t\t\tsubprocess,\n\t\t\t\tcancelSignal,\n\t\t\t\tgracefulCancel,\n\t\t\t\tforceKillAfterDelay,\n\t\t\t\tcontext,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t]);\n\t} catch (error) {\n\t\tcontext.terminationReason ??= 'other';\n\t\treturn Promise.all([\n\t\t\t{error},\n\t\t\texitPromise,\n\t\t\tPromise.all(stdioPromises.map(stdioPromise => getBufferedData(stdioPromise))),\n\t\t\tgetBufferedData(allPromise),\n\t\t\tgetBufferedIpcOutput(ipcOutputPromise, ipcOutput),\n\t\t\tPromise.allSettled(originalPromises),\n\t\t\tPromise.allSettled(customStreamsEndPromises),\n\t\t]);\n\t}\n};\n\n// Transforms replace `subprocess.std*`, which means they are not exposed to users.\n// However, we still want to wait for their completion.\nconst waitForOriginalStreams = (originalStreams, subprocess, streamInfo) =>\n\toriginalStreams.map((stream, fdNumber) => stream === subprocess.stdio[fdNumber]\n\t\t? undefined\n\t\t: waitForStream(stream, fdNumber, streamInfo));\n\n// Some `stdin`/`stdout`/`stderr` options create a stream, e.g. when passing a file path.\n// The `.pipe()` method automatically ends that stream when `subprocess` ends.\n// This makes sure we wait for the completion of those streams, in order to catch any error.\nconst waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({stdioItems}, fdNumber) => stdioItems\n\t.filter(({value, stream = value}) => isNodeStream(stream, {checkOpen: false}) && !isStandardStream(stream))\n\t.map(({type, value, stream = value}) => waitForStream(stream, fdNumber, streamInfo, {\n\t\tisSameDirection: TRANSFORM_TYPES.has(type),\n\t\tstopOnExit: type === 'native',\n\t})));\n\n// Fails when the subprocess emits an `error` event\nconst throwOnSubprocessError = async (subprocess, {signal}) => {\n\tconst [error] = await once(subprocess, 'error', {signal});\n\tthrow error;\n};\n", "import {verboseLog, serializeVerboseMessage} from './log.js';\nimport {isFullVerbose} from './values.js';\n\n// When `verbose` is `'full'`, print IPC messages from the subprocess\nexport const shouldLogIpc = verboseInfo => isFullVerbose(verboseInfo, 'ipc');\n\nexport const logIpcOutput = (message, verboseInfo) => {\n\tconst verboseMessage = serializeVerboseMessage(message);\n\tverboseLog({\n\t\ttype: 'ipc',\n\t\tverboseMessage,\n\t\tfdNumber: 'ipc',\n\t\tverboseInfo,\n\t});\n};\n", "import {checkIpcMaxBuffer} from '../io/max-buffer.js';\nimport {shouldLogIpc, logIpcOutput} from '../verbose/ipc.js';\nimport {getFdSpecificValue} from '../arguments/specific.js';\nimport {loopOnMessages} from './get-each.js';\n\n// Iterate through IPC messages sent by the subprocess\nexport const waitForIpcOutput = async ({\n\tsubprocess,\n\tbuffer: bufferArray,\n\tmaxBuffer: maxBufferArray,\n\tipc,\n\tipcOutput,\n\tverboseInfo,\n}) => {\n\tif (!ipc) {\n\t\treturn ipcOutput;\n\t}\n\n\tconst isVerbose = shouldLogIpc(verboseInfo);\n\tconst buffer = getFdSpecificValue(bufferArray, 'ipc');\n\tconst maxBuffer = getFdSpecificValue(maxBufferArray, 'ipc');\n\n\tfor await (const message of loopOnMessages({\n\t\tanyProcess: subprocess,\n\t\tchannel: subprocess.channel,\n\t\tisSubprocess: false,\n\t\tipc,\n\t\tshouldAwait: false,\n\t\treference: true,\n\t})) {\n\t\tif (buffer) {\n\t\t\tcheckIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);\n\t\t\tipcOutput.push(message);\n\t\t}\n\n\t\tif (isVerbose) {\n\t\t\tlogIpcOutput(message, verboseInfo);\n\t\t}\n\t}\n\n\treturn ipcOutput;\n};\n\nexport const getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {\n\tawait Promise.allSettled([ipcOutputPromise]);\n\treturn ipcOutput;\n};\n", "import {createDeferred} from '../utils/deferred.js';\n\n// When using multiple `.readable()`/`.writable()`/`.duplex()`, `final` and `destroy` should wait for other streams\nexport const initializeConcurrentStreams = () => ({\n\treadableDestroy: new WeakMap(),\n\twritableFinal: new WeakMap(),\n\twritableDestroy: new WeakMap(),\n});\n\n// Each file descriptor + `waitName` has its own array of promises.\n// Each promise is a single `.readable()`/`.writable()`/`.duplex()` call.\nexport const addConcurrentStream = (concurrentStreams, stream, waitName) => {\n\tconst weakMap = concurrentStreams[waitName];\n\tif (!weakMap.has(stream)) {\n\t\tweakMap.set(stream, []);\n\t}\n\n\tconst promises = weakMap.get(stream);\n\tconst promise = createDeferred();\n\tpromises.push(promise);\n\tconst resolve = promise.resolve.bind(promise);\n\treturn {resolve, promises};\n};\n\n// Wait for other streams, but stop waiting when subprocess ends\nexport const waitForConcurrentStreams = async ({resolve, promises}, subprocess) => {\n\tresolve();\n\tconst [isSubprocessExit] = await Promise.race([\n\t\tPromise.allSettled([true, subprocess]),\n\t\tPromise.all([false, ...promises]),\n\t]);\n\treturn !isSubprocessExit;\n};\n", "import {Readable} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {getFromStream} from '../arguments/fd-options.js';\nimport {iterateOnSubprocessStream, DEFAULT_OBJECT_HIGH_WATER_MARK} from '../io/iterate.js';\nimport {createDeferred} from '../utils/deferred.js';\nimport {addConcurrentStream, waitForConcurrentStreams} from './concurrent.js';\nimport {\n\tsafeWaitForSubprocessStdin,\n\twaitForSubprocessStdout,\n\twaitForSubprocess,\n\tdestroyOtherStream,\n} from './shared.js';\n\n// Create a `Readable` stream that forwards from `stdout` and awaits the subprocess\nexport const createReadable = ({subprocess, concurrentStreams, encoding}, {from, binary: binaryOption = true, preserveNewlines = true} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);\n\tconst {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);\n\tconst {read, onStdoutDataDone} = getReadableMethods({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\tconst readable = new Readable({\n\t\tread,\n\t\tdestroy: callbackify(onReadableDestroy.bind(undefined, {subprocessStdout, subprocess, waitReadableDestroy})),\n\t\thighWaterMark: readableHighWaterMark,\n\t\tobjectMode: readableObjectMode,\n\t\tencoding: readableEncoding,\n\t});\n\tonStdoutFinished({\n\t\tsubprocessStdout,\n\t\tonStdoutDataDone,\n\t\treadable,\n\t\tsubprocess,\n\t});\n\treturn readable;\n};\n\n// Retrieve `stdout` (or other stream depending on `from`)\nexport const getSubprocessStdout = (subprocess, from, concurrentStreams) => {\n\tconst subprocessStdout = getFromStream(subprocess, from);\n\tconst waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, 'readableDestroy');\n\treturn {subprocessStdout, waitReadableDestroy};\n};\n\nexport const getReadableOptions = ({readableEncoding, readableObjectMode, readableHighWaterMark}, binary) => binary\n\t? {readableEncoding, readableObjectMode, readableHighWaterMark}\n\t: {readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK};\n\nexport const getReadableMethods = ({subprocessStdout, subprocess, binary, encoding, preserveNewlines}) => {\n\tconst onStdoutDataDone = createDeferred();\n\tconst onStdoutData = iterateOnSubprocessStream({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tshouldEncode: !binary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\n\treturn {\n\t\tread() {\n\t\t\tonRead(this, onStdoutData, onStdoutDataDone);\n\t\t},\n\t\tonStdoutDataDone,\n\t};\n};\n\n// Forwards data from `stdout` to `readable`\nconst onRead = async (readable, onStdoutData, onStdoutDataDone) => {\n\ttry {\n\t\tconst {value, done} = await onStdoutData.next();\n\t\tif (done) {\n\t\t\tonStdoutDataDone.resolve();\n\t\t} else {\n\t\t\treadable.push(value);\n\t\t}\n\t} catch {}\n};\n\n// When `subprocess.stdout` ends/aborts/errors, do the same on `readable`.\n// Await the subprocess, for the same reason as above.\nexport const onStdoutFinished = async ({subprocessStdout, onStdoutDataDone, readable, subprocess, subprocessStdin}) => {\n\ttry {\n\t\tawait waitForSubprocessStdout(subprocessStdout);\n\t\tawait subprocess;\n\t\tawait safeWaitForSubprocessStdin(subprocessStdin);\n\t\tawait onStdoutDataDone;\n\n\t\tif (readable.readable) {\n\t\t\treadable.push(null);\n\t\t}\n\t} catch (error) {\n\t\tawait safeWaitForSubprocessStdin(subprocessStdin);\n\t\tdestroyOtherReadable(readable, error);\n\t}\n};\n\n// When `readable` aborts/errors, do the same on `subprocess.stdout`\nexport const onReadableDestroy = async ({subprocessStdout, subprocess, waitReadableDestroy}, error) => {\n\tif (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {\n\t\tdestroyOtherReadable(subprocessStdout, error);\n\t\tawait waitForSubprocess(subprocess, error);\n\t}\n};\n\nconst destroyOtherReadable = (stream, error) => {\n\tdestroyOtherStream(stream, stream.readable, error);\n};\n", "import {finished} from 'node:stream/promises';\nimport {isStreamAbort} from '../resolve/wait-stream.js';\n\nexport const safeWaitForSubprocessStdin = async subprocessStdin => {\n\tif (subprocessStdin === undefined) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait waitForSubprocessStdin(subprocessStdin);\n\t} catch {}\n};\n\nexport const safeWaitForSubprocessStdout = async subprocessStdout => {\n\tif (subprocessStdout === undefined) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait waitForSubprocessStdout(subprocessStdout);\n\t} catch {}\n};\n\nexport const waitForSubprocessStdin = async subprocessStdin => {\n\tawait finished(subprocessStdin, {cleanup: true, readable: false, writable: true});\n};\n\nexport const waitForSubprocessStdout = async subprocessStdout => {\n\tawait finished(subprocessStdout, {cleanup: true, readable: true, writable: false});\n};\n\n// When `readable` or `writable` aborts/errors, awaits the subprocess, for the reason mentioned above\nexport const waitForSubprocess = async (subprocess, error) => {\n\tawait subprocess;\n\tif (error) {\n\t\tthrow error;\n\t}\n};\n\nexport const destroyOtherStream = (stream, isOpen, error) => {\n\tif (error && !isStreamAbort(error)) {\n\t\tstream.destroy(error);\n\t} else if (isOpen) {\n\t\tstream.destroy();\n\t}\n};\n", "import {Writable} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {getToStream} from '../arguments/fd-options.js';\nimport {addConcurrentStream, waitForConcurrentStreams} from './concurrent.js';\nimport {\n\tsafeWaitForSubprocessStdout,\n\twaitForSubprocessStdin,\n\twaitForSubprocess,\n\tdestroyOtherStream,\n} from './shared.js';\n\n// Create a `Writable` stream that forwards to `stdin` and awaits the subprocess\nexport const createWritable = ({subprocess, concurrentStreams}, {to} = {}) => {\n\tconst {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);\n\tconst writable = new Writable({\n\t\t...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),\n\t\tdestroy: callbackify(onWritableDestroy.bind(undefined, {\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t})),\n\t\thighWaterMark: subprocessStdin.writableHighWaterMark,\n\t\tobjectMode: subprocessStdin.writableObjectMode,\n\t});\n\tonStdinFinished(subprocessStdin, writable);\n\treturn writable;\n};\n\n// Retrieve `stdin` (or other stream depending on `to`)\nexport const getSubprocessStdin = (subprocess, to, concurrentStreams) => {\n\tconst subprocessStdin = getToStream(subprocess, to);\n\tconst waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableFinal');\n\tconst waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableDestroy');\n\treturn {subprocessStdin, waitWritableFinal, waitWritableDestroy};\n};\n\nexport const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({\n\twrite: onWrite.bind(undefined, subprocessStdin),\n\tfinal: callbackify(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal)),\n});\n\n// Forwards data from `writable` to `stdin`\nconst onWrite = (subprocessStdin, chunk, encoding, done) => {\n\tif (subprocessStdin.write(chunk, encoding)) {\n\t\tdone();\n\t} else {\n\t\tsubprocessStdin.once('drain', done);\n\t}\n};\n\n// Ensures that the writable `final` and readable `end` events awaits the subprocess.\n// Like this, any subprocess failure is propagated as a stream `error` event, instead of being lost.\n// The user does not need to `await` the subprocess anymore, but now needs to await the stream completion or error.\n// When multiple writables are targeting the same stream, they wait for each other, unless the subprocess ends first.\nconst onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {\n\tif (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {\n\t\tif (subprocessStdin.writable) {\n\t\t\tsubprocessStdin.end();\n\t\t}\n\n\t\tawait subprocess;\n\t}\n};\n\n// When `subprocess.stdin` ends/aborts/errors, do the same on `writable`.\nexport const onStdinFinished = async (subprocessStdin, writable, subprocessStdout) => {\n\ttry {\n\t\tawait waitForSubprocessStdin(subprocessStdin);\n\t\tif (writable.writable) {\n\t\t\twritable.end();\n\t\t}\n\t} catch (error) {\n\t\tawait safeWaitForSubprocessStdout(subprocessStdout);\n\t\tdestroyOtherWritable(writable, error);\n\t}\n};\n\n// When `writable` aborts/errors, do the same on `subprocess.stdin`\nexport const onWritableDestroy = async ({subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy}, error) => {\n\tawait waitForConcurrentStreams(waitWritableFinal, subprocess);\n\tif (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {\n\t\tdestroyOtherWritable(subprocessStdin, error);\n\t\tawait waitForSubprocess(subprocess, error);\n\t}\n};\n\nconst destroyOtherWritable = (stream, error) => {\n\tdestroyOtherStream(stream, stream.writable, error);\n};\n", "import {Duplex} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {\n\tgetSubprocessStdout,\n\tgetReadableOptions,\n\tgetReadableMethods,\n\tonStdoutFinished,\n\tonReadableDestroy,\n} from './readable.js';\nimport {\n\tgetSubprocessStdin,\n\tgetWritableMethods,\n\tonStdinFinished,\n\tonWritableDestroy,\n} from './writable.js';\n\n// Create a `Duplex` stream combining both `subprocess.readable()` and `subprocess.writable()`\nexport const createDuplex = ({subprocess, concurrentStreams, encoding}, {from, to, binary: binaryOption = true, preserveNewlines = true} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);\n\tconst {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);\n\tconst {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);\n\tconst {read, onStdoutDataDone} = getReadableMethods({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\tconst duplex = new Duplex({\n\t\tread,\n\t\t...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),\n\t\tdestroy: callbackify(onDuplexDestroy.bind(undefined, {\n\t\t\tsubprocessStdout,\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitReadableDestroy,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t})),\n\t\treadableHighWaterMark,\n\t\twritableHighWaterMark: subprocessStdin.writableHighWaterMark,\n\t\treadableObjectMode,\n\t\twritableObjectMode: subprocessStdin.writableObjectMode,\n\t\tencoding: readableEncoding,\n\t});\n\tonStdoutFinished({\n\t\tsubprocessStdout,\n\t\tonStdoutDataDone,\n\t\treadable: duplex,\n\t\tsubprocess,\n\t\tsubprocessStdin,\n\t});\n\tonStdinFinished(subprocessStdin, duplex, subprocessStdout);\n\treturn duplex;\n};\n\nconst onDuplexDestroy = async ({subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy}, error) => {\n\tawait Promise.all([\n\t\tonReadableDestroy({subprocessStdout, subprocess, waitReadableDestroy}, error),\n\t\tonWritableDestroy({\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t}, error),\n\t]);\n};\n", "import {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {getFromStream} from '../arguments/fd-options.js';\nimport {iterateOnSubprocessStream} from '../io/iterate.js';\n\n// Convert the subprocess to an async iterable\nexport const createIterable = (subprocess, encoding, {\n\tfrom,\n\tbinary: binaryOption = false,\n\tpreserveNewlines = false,\n} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst subprocessStdout = getFromStream(subprocess, from);\n\tconst onStdoutData = iterateOnSubprocessStream({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tshouldEncode: true,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\treturn iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);\n};\n\nconst iterateOnStdoutData = async function * (onStdoutData, subprocessStdout, subprocess) {\n\ttry {\n\t\tyield * onStdoutData;\n\t} finally {\n\t\tif (subprocessStdout.readable) {\n\t\t\tsubprocessStdout.destroy();\n\t\t}\n\n\t\tawait subprocess;\n\t}\n};\n", "import {initializeConcurrentStreams} from './concurrent.js';\nimport {createReadable} from './readable.js';\nimport {createWritable} from './writable.js';\nimport {createDuplex} from './duplex.js';\nimport {createIterable} from './iterable.js';\n\n// Add methods to convert the subprocess to a stream or iterable\nexport const addConvertedStreams = (subprocess, {encoding}) => {\n\tconst concurrentStreams = initializeConcurrentStreams();\n\tsubprocess.readable = createReadable.bind(undefined, {subprocess, concurrentStreams, encoding});\n\tsubprocess.writable = createWritable.bind(undefined, {subprocess, concurrentStreams});\n\tsubprocess.duplex = createDuplex.bind(undefined, {subprocess, concurrentStreams, encoding});\n\tsubprocess.iterable = createIterable.bind(undefined, subprocess, encoding);\n\tsubprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});\n};\n", "// The return value is a mixin of `subprocess` and `Promise`\nexport const mergePromise = (subprocess, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\tconst value = descriptor.value.bind(promise);\n\t\tReflect.defineProperty(subprocess, property, {...descriptor, value});\n\t}\n};\n\n// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\n\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property),\n]);\n", "import isPlainObject from 'is-plain-obj';\nimport {FD_SPECIFIC_OPTIONS} from '../arguments/specific.js';\n\n// Deep merge specific options like `env`. Shallow merge the other ones.\nexport const mergeOptions = (boundOptions, options) => {\n\tconst newOptions = Object.fromEntries(\n\t\tObject.entries(options).map(([optionName, optionValue]) => [\n\t\t\toptionName,\n\t\t\tmergeOption(optionName, boundOptions[optionName], optionValue),\n\t\t]),\n\t);\n\treturn {...boundOptions, ...newOptions};\n};\n\nconst mergeOption = (optionName, boundOptionValue, optionValue) => {\n\tif (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) {\n\t\treturn {...boundOptionValue, ...optionValue};\n\t}\n\n\treturn optionValue;\n};\n\nconst DEEP_OPTIONS = new Set(['env', ...FD_SPECIFIC_OPTIONS]);\n", "import isPlainObject from 'is-plain-obj';\nimport {normalizeParameters} from './parameters.js';\nimport {isTemplateString, parseTemplates} from './template.js';\nimport {execaCoreSync} from './main-sync.js';\nimport {execaCoreAsync} from './main-async.js';\nimport {mergeOptions} from './bind.js';\n\n// Wraps every exported methods to provide the following features:\n//  - template string syntax: execa`command argument`\n//  - options binding: boundExeca = execa(options)\n//  - optional argument/options: execa(file), execa(file, args), execa(file, options), execa(file, args, options)\n// `mapArguments()` and `setBoundExeca()` allows for method-specific logic.\nexport const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {\n\tconst createNested = (mapArguments, boundOptions, setBoundExeca) => createExeca(mapArguments, boundOptions, deepOptions, setBoundExeca);\n\tconst boundExeca = (...execaArguments) => callBoundExeca({\n\t\tmapArguments,\n\t\tdeepOptions,\n\t\tboundOptions,\n\t\tsetBoundExeca,\n\t\tcreateNested,\n\t}, ...execaArguments);\n\n\tif (setBoundExeca !== undefined) {\n\t\tsetBoundExeca(boundExeca, createNested, boundOptions);\n\t}\n\n\treturn boundExeca;\n};\n\nconst callBoundExeca = ({mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested}, firstArgument, ...nextArguments) => {\n\tif (isPlainObject(firstArgument)) {\n\t\treturn createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);\n\t}\n\n\tconst {file, commandArguments, options, isSync} = parseArguments({\n\t\tmapArguments,\n\t\tfirstArgument,\n\t\tnextArguments,\n\t\tdeepOptions,\n\t\tboundOptions,\n\t});\n\treturn isSync\n\t\t? execaCoreSync(file, commandArguments, options)\n\t\t: execaCoreAsync(file, commandArguments, options, createNested);\n};\n\nconst parseArguments = ({mapArguments, firstArgument, nextArguments, deepOptions, boundOptions}) => {\n\tconst callArguments = isTemplateString(firstArgument)\n\t\t? parseTemplates(firstArgument, nextArguments)\n\t\t: [firstArgument, ...nextArguments];\n\tconst [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);\n\tconst mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);\n\tconst {\n\t\tfile = initialFile,\n\t\tcommandArguments = initialArguments,\n\t\toptions = mergedOptions,\n\t\tisSync = false,\n\t} = mapArguments({file: initialFile, commandArguments: initialArguments, options: mergedOptions});\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tisSync,\n\t};\n};\n", "// Main logic for `execaCommand()`\nexport const mapCommandAsync = ({file, commandArguments}) => parseCommand(file, commandArguments);\n\n// Main logic for `execaCommandSync()`\nexport const mapCommandSync = ({file, commandArguments}) => ({...parseCommand(file, commandArguments), isSync: true});\n\n// Convert `execaCommand(command)` into `execa(file, ...commandArguments)`\nconst parseCommand = (command, unusedArguments) => {\n\tif (unusedArguments.length > 0) {\n\t\tthrow new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);\n\t}\n\n\tconst [file, ...commandArguments] = parseCommandString(command);\n\treturn {file, commandArguments};\n};\n\n// Convert `command` string into an array of file or arguments to pass to $`${...fileOrCommandArguments}`\nexport const parseCommandString = command => {\n\tif (typeof command !== 'string') {\n\t\tthrow new TypeError(`The command must be a string: ${String(command)}.`);\n\t}\n\n\tconst trimmedCommand = command.trim();\n\tif (trimmedCommand === '') {\n\t\treturn [];\n\t}\n\n\tconst tokens = [];\n\tfor (const token of trimmedCommand.split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens.at(-1);\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n\nconst SPACES_REGEXP = / +/g;\n", "// Sets `$.sync` and `$.s`\nexport const setScriptSync = (boundExeca, createNested, boundOptions) => {\n\tboundExeca.sync = createNested(mapScriptSync, boundOptions);\n\tboundExeca.s = boundExeca.sync;\n};\n\n// Main logic for `$`\nexport const mapScriptAsync = ({options}) => getScriptOptions(options);\n\n// Main logic for `$.sync`\nconst mapScriptSync = ({options}) => ({...getScriptOptions(options), isSync: true});\n\n// `$` is like `execa` but with script-friendly options: `{stdin: 'inherit', preferLocal: true}`\nconst getScriptOptions = options => ({options: {...getScriptStdinOption(options), ...options}});\n\nconst getScriptStdinOption = ({input, inputFile, stdio}) => input === undefined && inputFile === undefined && stdio === undefined\n\t? {stdin: 'inherit'}\n\t: {};\n\n// When using $(...).pipe(...), most script-friendly options should apply to both commands.\n// However, some options (like `stdin: 'inherit'`) would create issues with piping, i.e. cannot be deep.\nexport const deepScriptOptions = {preferLocal: true};\n", "import {createExeca} from './lib/methods/create.js';\nimport {mapCommandAsync, mapCommandSync} from './lib/methods/command.js';\nimport {mapNode} from './lib/methods/node.js';\nimport {mapScriptAsync, setScriptSync, deepScriptOptions} from './lib/methods/script.js';\nimport {getIpcExport} from './lib/ipc/methods.js';\n\nexport {parseCommandString} from './lib/methods/command.js';\nexport {ExecaError, ExecaSyncError} from './lib/return/final-error.js';\n\nexport const execa = createExeca(() => ({}));\nexport const execaSync = createExeca(() => ({isSync: true}));\nexport const execaCommand = createExeca(mapCommandAsync);\nexport const execaCommandSync = createExeca(mapCommandSync);\nexport const execaNode = createExeca(mapNode);\nexport const $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);\n\nconst {\n\tsendMessage,\n\tgetOneMessage,\n\tgetEachMessage,\n\tgetCancelSignal,\n} = getIpcExport();\nexport {\n\tsendMessage,\n\tgetOneMessage,\n\tgetEachMessage,\n\tgetCancelSignal,\n};\n", "import { Action, Icon, ActionPanel, Keyboard } from \"@raycast/api\";\nimport { homedir } from \"os\";\nimport { stopService, restartService, startService, runService, Service } from \"./services\";\n\nexport function StopService(props: { name: string }) {\n  if (props.name == \"--all\") {\n    return (\n      <Action\n        icon={Icon.Stop}\n        title=\"Stop All Services\"\n        onAction={() => stopService(props.name)}\n        shortcut={{ modifiers: [\"cmd\"], key: \"x\" }}\n      />\n    );\n  }\n  return <Action icon={Icon.Stop} title=\"Stop Service\" onAction={() => stopService(props.name)} />;\n}\n\nexport function RestartService(props: { name: string }) {\n  if (props.name == \"--all\") {\n    return (\n      <Action\n        icon={Icon.RotateAntiClockwise}\n        title=\"Restart All Services\"\n        onAction={() => restartService(props.name)}\n        shortcut={{ modifiers: [\"cmd\"], key: \"r\" }}\n      />\n    );\n  }\n  return <Action icon={Icon.RotateAntiClockwise} title=\"Restart Service\" onAction={() => restartService(props.name)} />;\n}\n\nexport function StartService(props: { name: string }) {\n  if (props.name == \"--all\") {\n    return (\n      <Action\n        icon={Icon.Play}\n        title=\"Start All Services\"\n        onAction={() => startService(props.name)}\n        shortcut={{ modifiers: [\"cmd\"], key: \"s\" }}\n      />\n    );\n  }\n  return <Action icon={Icon.Play} title=\"Start Service\" onAction={() => startService(props.name)} />;\n}\n\nexport function RunService(props: { name: string }) {\n  return <Action icon={Icon.ForwardFilled} title=\"Run Service\" onAction={() => runService(props.name)} />;\n}\n\nexport function PlistActions(props: { path: string }) {\n  const path = props.path.replace(/^~/, homedir());\n  return (\n    <ActionPanel.Section title=\"Plist\">\n      <Action.ShowInFinder title=\"Show Plist File in Finder\" path={path} shortcut={{ modifiers: [\"cmd\"], key: \"f\" }} />\n      <Action.OpenWith title=\"Open Plist File With\" path={path} shortcut={Keyboard.Shortcut.Common.OpenWith} />\n      <Action.CopyToClipboard\n        title=\"Copy Plist File Path\"\n        content={path}\n        shortcut={Keyboard.Shortcut.Common.CopyPath}\n      />\n    </ActionPanel.Section>\n  );\n}\n\nexport function AllActions() {\n  return (\n    <ActionPanel.Section title=\"Manage All Services\">\n      <StartService name=\"--all\" />\n      <StopService name=\"--all\" />\n      <RestartService name=\"--all\" />\n    </ActionPanel.Section>\n  );\n}\n\nexport function BrewActions(props: { data: Service }) {\n  if (props.data.status === \"started\" || props.data.status === \"running\") {\n    return (\n      <ActionPanel>\n        <ActionPanel.Section title=\"Manage Service\">\n          <StopService name={props.data.name} />\n          <RestartService name={props.data.name} />\n        </ActionPanel.Section>\n        <PlistActions path={props.data.path} />\n        <AllActions />\n      </ActionPanel>\n    );\n  } else if (props.data.status === \"stopped\" || props.data.status === \"none\") {\n    return (\n      <ActionPanel title=\"Manage Service\">\n        <StartService name={props.data.name} />\n        <RunService name={props.data.name} />\n        <AllActions />\n      </ActionPanel>\n    );\n  } else {\n    return (\n      <ActionPanel title=\"Manage Service\">\n        <StopService name={props.data.name} />\n        <RestartService name={props.data.name} />\n        <AllActions />\n      </ActionPanel>\n    );\n  }\n}\n"],
  "mappings": "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OAAO,YACP,YAAY,8BACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,wBACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,mBACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,cACZ,SAAS,MACT,EACA,CACA,KAAK,YACL,OAAO,GACP,OAAO,YACP,YAAY,+BACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,SACP,YAAY,+CACZ,SAAS,OACT,EACA,CACA,KAAK,SACL,OAAO,GACP,OAAO,SACP,YAAY,+CACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,UACP,YAAY,WACZ,SAAS,QACT,OAAO,EACP,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,QACP,YAAY,SACZ,SAAS,QACT,OAAO,EACP,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,QACP,YAAY,mCACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,QACP,YAAY,gDACZ,SAAS,OACT,EACA,CACA,KAAK,WACL,OAAO,GACP,OAAO,YACP,YAAY,oCACZ,SAAS,OACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,QACP,YAAY,qDACZ,SAAS,OACT,EACA,CACA,KAAK,SACL,OAAO,GACP,OAAO,SACP,YAAY,mCACZ,SAAS,KACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,OACP,YAAY,oBACZ,SAAS,KACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,OACP,YAAY,eACZ,SAAS,KACT,EACA,CACA,KAAK,YACL,OAAO,GACP,OAAO,YACP,YAAY,mBACZ,SAAS,KACT,EACA,CACA,KAAK,UACL,OAAO,GACP,OAAO,YACP,YAAY,mBACZ,SAAS,KACT,EACA,CACA,KAAK,WACL,OAAO,GACP,OAAO,SACP,YAAY,+BACZ,SAAS,KACT,EACA,CACA,KAAK,QACL,OAAO,GACP,OAAO,YACP,YAAY,mBACZ,SAAS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",
  "names": ["require_windows", "__commonJSMin", "exports", "module", "isexe", "sync", "fs", "checkPathExt", "path", "options", "pathext", "i", "p", "checkStat", "stat", "cb", "er", "require_mode", "__commonJSMin", "exports", "module", "isexe", "sync", "fs", "path", "options", "cb", "er", "stat", "checkStat", "checkMode", "mod", "uid", "gid", "myUid", "myGid", "u", "g", "o", "ug", "ret", "require_isexe", "__commonJSMin", "exports", "module", "fs", "core", "isexe", "sync", "path", "options", "cb", "resolve", "reject", "er", "is", "require_which", "__commonJSMin", "exports", "module", "isWindows", "path", "COLON", "isexe", "getNotFoundError", "cmd", "getPathInfo", "opt", "colon", "pathEnv", "pathExtExe", "pathExt", "which", "cb", "found", "step", "i", "resolve", "reject", "ppRaw", "pathPart", "pCmd", "p", "subStep", "ii", "ext", "er", "is", "res", "whichSync", "j", "cur", "require_path_key", "__commonJSMin", "exports", "module", "pathKey", "options", "environment", "key", "require_resolveCommand", "__commonJSMin", "exports", "module", "path", "which", "getPathKey", "resolveCommandAttempt", "parsed", "withoutPathExt", "env", "cwd", "hasCustomCwd", "shouldSwitchCwd", "resolved", "resolveCommand", "require_escape", "__commonJSMin", "exports", "module", "metaCharsRegExp", "escapeCommand", "arg", "escapeArgument", "doubleEscapeMetaChars", "require_shebang_regex", "__commonJSMin", "exports", "module", "require_shebang_command", "__commonJSMin", "exports", "module", "shebangRegex", "string", "match", "path", "argument", "binary", "require_readShebang", "__commonJSMin", "exports", "module", "fs", "shebangCommand", "readShebang", "command", "buffer", "fd", "require_parse", "__commonJSMin", "exports", "module", "path", "resolveCommand", "escape", "readShebang", "isWin", "isExecutableRegExp", "isCmdShimRegExp", "detectShebang", "parsed", "shebang", "parseNonShell", "commandFile", "needsShell", "needsDoubleEscapeMetaChars", "arg", "shellCommand", "parse", "command", "args", "options", "require_enoent", "__commonJSMin", "exports", "module", "isWin", "notFoundError", "original", "syscall", "hookChildProcess", "cp", "parsed", "originalEmit", "name", "arg1", "err", "verifyENOENT", "status", "verifyENOENTSync", "require_cross_spawn", "__commonJSMin", "exports", "module", "cp", "parse", "enoent", "spawn", "command", "args", "options", "parsed", "spawned", "spawnSync", "result", "manage_services_exports", "__export", "Command", "__toCommonJS", "import_react", "import_api", "import_fs", "import_os", "import_api", "isPlainObject", "value", "prototype", "import_node_url", "safeNormalizeFileUrl", "file", "name", "fileString", "normalizeFileUrl", "normalizeParameters", "rawFile", "rawArguments", "rawOptions", "filePath", "safeNormalizeFileUrl", "commandArguments", "options", "isPlainObject", "commandArgument", "normalizedArguments", "nullByteArgument", "normalizedArgument", "import_node_child_process", "import_node_string_decoder", "objectToString", "isArrayBuffer", "value", "isUint8Array", "bufferToUint8Array", "buffer", "textEncoder", "stringToUint8Array", "string", "textDecoder", "uint8ArrayToString", "uint8Array", "joinToString", "uint8ArraysOrStrings", "encoding", "uint8ArraysToStrings", "uint8ArrayOrString", "decoder", "strings", "finalString", "joinToUint8Array", "concatUint8Arrays", "stringsToUint8Arrays", "uint8Arrays", "result", "getJoinLength", "index", "joinLength", "isTemplateString", "templates", "parseTemplates", "expressions", "tokens", "index", "template", "parseTemplate", "file", "commandArguments", "nextTokens", "leadingWhitespaces", "trailingWhitespaces", "splitByWhitespaces", "newTokens", "concatTokens", "expression", "expressionTokens", "parseExpression", "rawTemplate", "templateStart", "DELIMITERS", "templateIndex", "rawIndex", "rawCharacter", "nextRawCharacter", "ESCAPE_LENGTH", "isSeparated", "typeOfExpression", "isPlainObject", "getSubprocessResult", "stdout", "isUint8Array", "uint8ArrayToString", "import_node_child_process", "import_node_util", "import_node_process", "isStandardStream", "stream", "STANDARD_STREAMS", "process", "STANDARD_STREAMS_ALIASES", "getStreamName", "fdNumber", "normalizeFdSpecificOptions", "options", "optionsCopy", "optionName", "FD_SPECIFIC_OPTIONS", "normalizeFdSpecificOption", "optionBaseArray", "getStdioLength", "optionArray", "normalizeFdSpecificValue", "addDefaultValue", "stdio", "STANDARD_STREAMS_ALIASES", "optionValue", "isPlainObject", "normalizeOptionObject", "fdName", "compareFdName", "fdNumber", "parseFdName", "fdNameA", "fdNameB", "getFdNameOrder", "parseFd", "regexpResult", "FD_REGEXP", "DEFAULT_OPTIONS", "verboseDefault", "getFdSpecificValue", "isVerbose", "verbose", "fdNumber", "getFdVerbose", "isFullVerbose", "getVerboseFunction", "fdVerbose", "isVerboseFunction", "getFdGenericVerbose", "getFdSpecificValue", "VERBOSE_VALUES", "import_node_fs", "import_node_util", "import_node_process", "import_node_util", "joinCommand", "filePath", "rawArguments", "fileAndArguments", "command", "escapedCommand", "fileAndArgument", "quoteString", "escapeControlCharacters", "escapeLines", "lines", "line", "SPECIAL_CHAR_REGEXP", "character", "escapeControlCharacter", "commonEscape", "COMMON_ESCAPES", "codepoint", "codepointHex", "ASTRAL_START", "getSpecialCharRegExp", "escapedArgument", "NO_ESCAPE_REGEXP", "import_node_process", "isUnicodeSupported", "env", "process", "TERM", "TERM_PROGRAM", "common", "specialMainSymbols", "specialFallbackSymbols", "mainSymbols", "fallbackSymbols", "shouldUseMain", "isUnicodeSupported", "figures", "figures_default", "replacements", "import_node_tty", "hasColors", "tty", "format", "open", "close", "input", "openCode", "closeCode", "string", "index", "result", "lastIndex", "reset", "bold", "dim", "italic", "underline", "overline", "inverse", "hidden", "strikethrough", "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "gray", "bgBlack", "bgRed", "bgGreen", "bgYellow", "bgBlue", "bgMagenta", "bgCyan", "bgWhite", "bgGray", "redBright", "greenBright", "yellowBright", "blueBright", "magentaBright", "cyanBright", "whiteBright", "bgRedBright", "bgGreenBright", "bgYellowBright", "bgBlueBright", "bgMagentaBright", "bgCyanBright", "bgWhiteBright", "defaultVerboseFunction", "type", "message", "timestamp", "piped", "commandId", "failed", "reject", "timestampString", "serializeTimestamp", "icon", "ICONS", "color", "COLORS", "gray", "padField", "field", "padding", "getFinalIcon", "figures_default", "identity", "string", "bold", "redBright", "yellowBright", "applyVerboseOnLines", "printedLines", "verboseInfo", "fdNumber", "verboseFunction", "getVerboseFunction", "verboseLine", "verboseObject", "applyVerboseFunction", "printedLine", "appendNewline", "verboseLog", "type", "verboseMessage", "fdNumber", "verboseInfo", "result", "verboseObject", "getVerboseObject", "printedLines", "getPrintedLines", "finalLines", "applyVerboseOnLines", "STDERR_FD", "escapedCommand", "commandId", "piped", "options", "message", "getPrintedLine", "defaultVerboseFunction", "serializeVerboseMessage", "messageString", "escapeLines", "TAB_SIZE", "logCommand", "escapedCommand", "verboseInfo", "isVerbose", "verboseLog", "getVerboseInfo", "verbose", "escapedCommand", "rawOptions", "validateVerbose", "commandId", "getCommandId", "isVerbose", "COMMAND_ID", "fdVerbose", "VERBOSE_VALUES", "isVerboseFunction", "allowedValues", "allowedValue", "import_node_process", "getStartTime", "getDurationMs", "startTime", "handleCommand", "filePath", "rawArguments", "rawOptions", "startTime", "getStartTime", "command", "escapedCommand", "joinCommand", "verbose", "normalizeFdSpecificOption", "verboseInfo", "getVerboseInfo", "logCommand", "import_node_path", "import_node_process", "import_cross_spawn", "import_node_process", "import_node_path", "pathKey", "options", "env", "platform", "key", "import_node_util", "import_node_child_process", "import_node_path", "import_node_url", "execFileOriginal", "execFileCallback", "toPath", "urlOrPath", "traversePathUp", "startPath", "currentPath", "path", "toPath", "previousPath", "TEN_MEGABYTES_IN_BYTES", "npmRunPath", "cwd", "process", "pathOption", "pathKey", "preferLocal", "execPath", "addExecPath", "cwdPath", "path", "toPath", "result", "pathParts", "applyPreferLocal", "applyExecPath", "directory", "traversePathUp", "pathPart", "npmRunPathEnv", "env", "options", "pathName", "import_promises", "getFinalError", "originalError", "message", "isSync", "ErrorClass", "ExecaSyncError", "ExecaError", "options", "DiscardedError", "setErrorName", "value", "execaErrorSymbol", "isExecaError", "error", "isErrorInstance", "import_node_os", "import_node_os", "getRealtimeSignals", "length", "SIGRTMAX", "SIGRTMIN", "getRealtimeSignal", "value", "index", "import_node_os", "SIGNALS", "getSignals", "realtimeSignals", "getRealtimeSignals", "SIGNALS", "normalizeSignal", "name", "defaultNumber", "description", "action", "forced", "standard", "constantSignal", "supported", "getSignalsByName", "signals", "getSignals", "getSignalByName", "name", "number", "description", "supported", "action", "forced", "standard", "signalsByName", "getSignalsByNumber", "length", "signalsA", "value", "getSignalByNumber", "signal", "findSignalByNumber", "signalA", "signalsByNumber", "normalizeKillSignal", "killSignal", "optionName", "normalizeSignal", "normalizeSignalArgument", "signal", "signalNameOrInteger", "normalizeSignalInteger", "normalizeSignalName", "getAvailableSignals", "signalInteger", "signalsIntegerToName", "getSignalsIntegerToName", "signalName", "getAvailableSignalNames", "getAvailableSignalIntegers", "signalIntegerTwo", "getSignalDescription", "signalsByName", "normalizeForceKillAfterDelay", "forceKillAfterDelay", "DEFAULT_FORCE_KILL_TIMEOUT", "subprocessKill", "kill", "killSignal", "onInternalError", "context", "controller", "signalOrError", "errorArgument", "signal", "error", "parseKillArguments", "emitKillError", "killResult", "setKillTimeout", "isErrorInstance", "normalizeSignalArgument", "killOnTimeout", "controllerSignal", "import_node_events", "onAbortedSignal", "mainSignal", "stopSignal", "validateCancelSignal", "cancelSignal", "throwOnCancel", "subprocess", "gracefulCancel", "context", "controller", "terminateOnCancel", "signal", "onAbortedSignal", "import_promises", "import_node_util", "validateIpcMethod", "methodName", "isSubprocess", "ipc", "isConnected", "validateIpcOption", "validateConnection", "getMethodName", "getOtherProcessName", "throwOnEarlyDisconnect", "throwOnStrictDeadlockError", "getStrictResponseError", "error", "throwOnMissingStrict", "throwOnStrictDisconnect", "getAbortDisconnectError", "throwOnMissingParent", "handleEpipeError", "handleSerializationError", "message", "isSerializationError", "code", "SERIALIZATION_ERROR_CODES", "SERIALIZATION_ERROR_MESSAGES", "serializationErrorMessage", "parameters", "getNamespaceName", "disconnect", "anyProcess", "createDeferred", "methods", "promise", "resolve", "reject", "getToStream", "destination", "to", "options", "fileDescriptors", "SUBPROCESS_OPTIONS", "fdNumber", "getFdNumber", "destinationStream", "getInvalidStdioOptionMessage", "getFromStream", "source", "from", "sourceStream", "fdName", "isWritable", "parseFdNumber", "validateFdNumber", "parseFd", "validOptions", "defaultValue", "getOptionName", "fileDescriptor", "getUsedDescriptor", "optionName", "optionValue", "getInvalidStdioOption", "serializeOptionValue", "stdin", "stdout", "stderr", "stdio", "usedDescriptor", "value", "import_node_events", "import_node_events", "incrementMaxListeners", "eventEmitter", "maxListenersIncrement", "signal", "maxListeners", "import_node_events", "import_node_events", "import_promises", "addReference", "channel", "reference", "addReferenceCount", "removeReference", "removeReferenceCount", "undoAddedReferences", "isSubprocess", "redoAddedReferences", "onMessage", "anyProcess", "channel", "isSubprocess", "ipcEmitter", "wrappedMessage", "handleStrictResponse", "handleAbort", "INCOMING_MESSAGES", "incomingMessages", "waitForOutgoingMessages", "message", "handleStrictRequest", "onDisconnect", "boundOnMessage", "abortOnDisconnect", "redoAddedReferences", "getIpcEmitter", "anyProcess", "channel", "isSubprocess", "IPC_EMITTERS", "ipcEmitter", "forwardEvents", "boundOnMessage", "onMessage", "onDisconnect", "undoAddedReferences", "isConnected", "handleSendStrict", "anyProcess", "channel", "isSubprocess", "message", "strict", "ipcEmitter", "getIpcEmitter", "hasListeners", "hasMessageListeners", "count", "REQUEST_TYPE", "validateStrictDeadlock", "outgoingMessages", "wrappedMessage", "id", "STRICT_RESPONSES", "handleStrictRequest", "response", "RESPONSE_TYPE", "sendMessage", "error", "handleStrictResponse", "waitForStrictResponse", "deferred", "createDeferred", "controller", "isDeadlock", "throwOnDisconnect", "throwOnStrictDeadlockError", "throwOnMissingStrict", "signal", "incrementMaxListeners", "throwOnStrictDisconnect", "startSendMessage", "anyProcess", "wrappedMessage", "strict", "OUTGOING_MESSAGES", "outgoingMessages", "onMessageSent", "createDeferred", "id", "outgoingMessage", "endSendMessage", "waitForOutgoingMessages", "ipcEmitter", "hasMessageListeners", "validateStrictDeadlock", "getMinListenerCount", "SUBPROCESS_OPTIONS", "getFdSpecificValue", "sendMessage", "anyProcess", "channel", "isSubprocess", "ipc", "message", "strict", "methodName", "validateIpcMethod", "sendMessageAsync", "wrappedMessage", "handleSendStrict", "outgoingMessagesState", "startSendMessage", "sendOneMessage", "error", "disconnect", "endSendMessage", "sendMethod", "getSendMethod", "waitForStrictResponse", "handleEpipeError", "handleSerializationError", "PROCESS_SEND_METHODS", "sendAbort", "subprocess", "message", "methodName", "validateConnection", "sendOneMessage", "GRACEFUL_CANCEL_TYPE", "getCancelSignal", "anyProcess", "channel", "isSubprocess", "ipc", "startIpc", "cancelController", "cancelListening", "throwOnMissingParent", "abortOnDisconnect", "getIpcEmitter", "handleAbort", "wrappedMessage", "getAbortDisconnectError", "validateGracefulCancel", "gracefulCancel", "cancelSignal", "ipc", "serialization", "throwOnGracefulCancel", "subprocess", "forceKillAfterDelay", "context", "controller", "sendOnAbort", "signal", "onAbortedSignal", "reason", "getReason", "sendAbort", "killOnTimeout", "error", "import_promises", "validateTimeout", "timeout", "throwOnTimeout", "subprocess", "context", "controller", "killAfterTimeout", "signal", "DiscardedError", "import_node_process", "import_node_path", "mapNode", "options", "handleNodeOption", "file", "commandArguments", "shouldHandleNode", "nodePath", "nodeOptions", "nodeOption", "cwd", "formerNodePath", "normalizedNodePath", "safeNormalizeFileUrl", "resolvedNodePath", "path", "newOptions", "import_node_v8", "validateIpcInputOption", "ipcInput", "ipc", "serialization", "validateIpcInput", "validateAdvancedInput", "error", "validateJsonInput", "sendIpcInput", "subprocess", "validateEncoding", "encoding", "ENCODINGS", "correctEncoding", "getCorrectEncoding", "serializeEncoding", "correctEncodings", "TEXT_ENCODINGS", "BINARY_ENCODINGS", "lowerEncoding", "ENCODING_ALIASES", "import_node_fs", "import_node_path", "import_node_process", "normalizeCwd", "cwd", "getDefaultCwd", "cwdString", "safeNormalizeFileUrl", "path", "process", "error", "fixCwdError", "originalMessage", "cwdStat", "normalizeOptions", "filePath", "rawArguments", "rawOptions", "normalizeCwd", "processedFile", "processedArguments", "processedOptions", "handleNodeOption", "file", "commandArguments", "initialOptions", "crossSpawn", "fdOptions", "normalizeFdSpecificOptions", "options", "addDefaultOptions", "validateTimeout", "validateEncoding", "validateIpcInputOption", "validateCancelSignal", "validateGracefulCancel", "normalizeFileUrl", "getEnv", "normalizeKillSignal", "normalizeForceKillAfterDelay", "lines", "fdNumber", "BINARY_ENCODINGS", "process", "path", "extendEnv", "preferLocal", "cwd", "localDirectory", "encoding", "reject", "cleanup", "all", "windowsHide", "killSignal", "forceKillAfterDelay", "gracefulCancel", "ipcInput", "ipc", "serialization", "envOption", "node", "nodePath", "env", "npmRunPathEnv", "import_node_util", "stripFinalNewline", "input", "stripFinalNewlineString", "stripFinalNewlineBinary", "LF", "CR", "LF_BINARY", "CR_BINARY", "import_node_events", "import_promises", "isStream", "stream", "checkOpen", "isWritableStream", "isReadableStream", "isDuplexStream", "options", "a", "c", "#n", "#r", "#e", "e", "t", "#s", "#i", "n", "i", "o", "r", "u", "h", "s", "getAsyncIterable", "stream", "isReadableStream", "nodeImports", "getStreamIterable", "toString", "h", "controller", "state", "handleStreamEnd", "chunk", "error", "getStreamContents", "stream", "init", "convertChunk", "getSize", "truncateChunk", "addChunk", "getFinalChunk", "finalize", "maxBuffer", "asyncIterable", "getAsyncIterable", "state", "chunk", "chunkType", "getChunkType", "convertedChunk", "appendChunk", "appendFinalChunk", "error", "normalizedError", "chunkSize", "newLength", "addNewChunk", "truncatedChunk", "MaxBufferError", "typeOfChunk", "prototypeName", "objectToString", "identity", "value", "noop", "getContentsProperty", "contents", "throwObjectStream", "chunk", "getLengthProperty", "convertedChunk", "getStreamAsArray", "stream", "options", "getStreamContents", "arrayMethods", "initArray", "increment", "addArrayChunk", "convertedChunk", "contents", "identity", "noop", "getContentsProperty", "getStreamAsArrayBuffer", "stream", "options", "getStreamContents", "arrayBufferMethods", "initArrayBuffer", "useTextEncoder", "chunk", "textEncoder", "useUint8Array", "useUint8ArrayWithOffset", "truncateArrayBufferChunk", "convertedChunk", "chunkSize", "addArrayBufferChunk", "contents", "previousLength", "length", "newContents", "hasArrayBufferResize", "resizeArrayBuffer", "resizeArrayBufferSlow", "arrayBuffer", "getNewContentsLength", "SCALE_FACTOR", "finalizeArrayBuffer", "throwObjectStream", "getLengthProperty", "noop", "getStreamAsString", "stream", "options", "getStreamContents", "stringMethods", "initString", "useTextDecoder", "chunk", "textDecoder", "addStringChunk", "convertedChunk", "contents", "truncateStringChunk", "chunkSize", "getFinalStringChunk", "finalChunk", "identity", "throwObjectStream", "getLengthProperty", "getContentsProperty", "nodeImports", "handleMaxBuffer", "error", "stream", "readableObjectMode", "lines", "encoding", "fdNumber", "MaxBufferError", "unit", "getMaxBufferUnit", "checkIpcMaxBuffer", "subprocess", "ipcOutput", "maxBuffer", "getMaxBufferMessage", "streamName", "threshold", "getMaxBufferInfo", "getFdSpecificValue", "getStreamName", "isMaxBufferSync", "resultError", "output", "result", "getMaxBufferSync", "truncateMaxBufferSync", "isMaxBuffer", "maxBufferValue", "stdoutMaxBuffer", "createMessages", "stdio", "all", "ipcOutput", "originalError", "signal", "signalDescription", "exitCode", "escapedCommand", "timedOut", "isCanceled", "isGracefullyCanceled", "isMaxBuffer", "isForcefullyTerminated", "forceKillAfterDelay", "killSignal", "maxBuffer", "timeout", "cwd", "errorCode", "prefix", "getErrorPrefix", "originalMessage", "getOriginalMessage", "suffix", "shortMessage", "messageStdio", "message", "ipcMessage", "serializeIpcMessage", "messagePart", "escapeLines", "stripFinalNewline", "serializeMessagePart", "forcefulSuffix", "getForcefulSuffix", "getMaxBufferMessage", "getSignalDescription", "DiscardedError", "isExecaError", "escapedOriginalMessage", "fixCwdError", "messageItem", "serializeMessageItem", "isUint8Array", "uint8ArrayToString", "makeSuccessResult", "command", "escapedCommand", "stdio", "all", "ipcOutput", "cwd", "startTime", "omitUndefinedProperties", "getDurationMs", "makeEarlyError", "error", "fileDescriptors", "options", "isSync", "makeError", "originalError", "timedOut", "isCanceled", "isGracefullyCanceled", "isMaxBuffer", "isForcefullyTerminated", "rawExitCode", "rawSignal", "timeoutDuration", "timeout", "forceKillAfterDelay", "killSignal", "maxBuffer", "exitCode", "signal", "signalDescription", "normalizeExitPayload", "originalMessage", "shortMessage", "message", "createMessages", "getFinalError", "getErrorProperties", "result", "value", "getSignalDescription", "toZeroIfInfinity", "value", "parseNumber", "milliseconds", "parseBigint", "parseMilliseconds", "isZero", "value", "pluralize", "word", "count", "SECOND_ROUNDING_EPSILON", "ONE_DAY_IN_MILLISECONDS", "prettyMilliseconds", "milliseconds", "options", "isBigInt", "sign", "result", "floorDecimals", "decimalDigits", "flooredInterimValue", "add", "long", "short", "valueString", "wholeDigits", "minLength", "parsed", "parseMilliseconds", "days", "seconds", "microseconds", "nanoseconds", "millisecondsAndBelow", "millisecondsDecimalDigits", "roundedMilliseconds", "millisecondsString", "secondsDecimalDigits", "secondsFixed", "secondsString", "separator", "logError", "result", "verboseInfo", "verboseLog", "logResult", "result", "verboseInfo", "isVerbose", "logError", "logDuration", "verboseMessage", "prettyMilliseconds", "verboseLog", "handleResult", "result", "verboseInfo", "reject", "logResult", "import_node_fs", "getStdioItemType", "value", "optionName", "isAsyncGenerator", "isSyncGenerator", "isUrl", "isFilePathObject", "isWebStream", "isStream", "isUint8Array", "isAsyncIterableObject", "isIterableObject", "isTransformStream", "getTransformStreamType", "isTransformOptions", "getTransformObjectType", "isDuplexStream", "getDuplexType", "getGeneratorObjectType", "validateNonGeneratorType", "final", "binary", "objectMode", "typeName", "checkUndefinedOption", "checkBooleanOption", "transform", "isGenerator", "isPlainObject", "isRegularUrl", "isFilePathString", "file", "isUnknownStdioString", "type", "KNOWN_STDIO_STRINGS", "isReadableStream", "isWritableStream", "isObject", "TRANSFORM_TYPES", "FILE_TYPES", "SPECIAL_DUPLICATE_TYPES_SYNC", "SPECIAL_DUPLICATE_TYPES", "FORBID_DUPLICATE_TYPES", "TYPE_TO_MESSAGE", "getTransformObjectModes", "objectMode", "index", "newTransforms", "direction", "getOutputObjectModes", "getInputObjectModes", "writableObjectMode", "readableObjectMode", "getFdObjectMode", "stdioItems", "lastTransform", "type", "TRANSFORM_TYPES", "normalizeTransforms", "stdioItems", "optionName", "direction", "options", "type", "TRANSFORM_TYPES", "getTransforms", "encoding", "transforms", "newTransforms", "index", "stdioItem", "normalizeTransform", "sortTransforms", "normalizeDuplex", "normalizeTransformStream", "normalizeGenerator", "transform", "writableObjectMode", "readableObjectMode", "objectMode", "value", "isPlainObject", "getTransformObjectModes", "final", "binaryOption", "preserveNewlines", "binary", "BINARY_ENCODINGS", "import_node_process", "getStreamDirection", "stdioItems", "fdNumber", "optionName", "directions", "stdioItem", "getStdioItemDirection", "DEFAULT_DIRECTION", "type", "value", "KNOWN_DIRECTIONS", "guessStreamDirection", "anyDirection", "alwaysInput", "isWritableStream", "isReadableStream", "standardStreamDirection", "getStandardStreamDirection", "isStream", "process", "normalizeIpcStdioArray", "stdioArray", "ipc", "normalizeStdioOption", "stdio", "ipc", "buffer", "options", "verboseInfo", "isSync", "stdioArray", "getStdioArray", "stdioOption", "fdNumber", "addDefaultValue", "normalizeStdioSync", "normalizeIpcStdioArray", "STANDARD_STREAMS_ALIASES", "alias", "hasAlias", "length", "_", "item", "isFullVerbose", "isOutputPipeOnly", "import_node_fs", "import_node_tty", "handleNativeStream", "stdioItem", "type", "isStdioArray", "fdNumber", "direction", "isSync", "handleNativeStreamSync", "handleNativeStreamAsync", "value", "optionName", "targetFd", "getTargetFd", "isStream", "targetFdNumber", "getTargetFdNumber", "tty", "serializeOptionValue", "bufferToUint8Array", "standardStreamIndex", "STANDARD_STREAMS", "getStandardStream", "standardStream", "handleInputOptions", "input", "inputFile", "fdNumber", "handleInputOption", "handleInputFileOption", "getInputType", "isReadableStream", "isUint8Array", "getInputFileType", "isUrl", "isFilePathString", "filterDuplicates", "stdioItems", "stdioItemOne", "indexOne", "stdioItemTwo", "indexTwo", "getDuplicateStream", "type", "value", "optionName", "direction", "fileDescriptors", "isSync", "otherStdioItems", "getOtherStdioItems", "validateDuplicateStreamSync", "SPECIAL_DUPLICATE_TYPES", "getDuplicateStreamInstance", "FORBID_DUPLICATE_TYPES", "validateDuplicateTransform", "stdioItem", "SPECIAL_DUPLICATE_TYPES_SYNC", "duplicateStdioItems", "hasSameValue", "differentStdioItem", "throwOnDuplicateStream", "secondValue", "duplicateStdioItem", "transform", "TYPE_TO_MESSAGE", "handleStdio", "addProperties", "options", "verboseInfo", "isSync", "initialFileDescriptors", "normalizeStdioOption", "stdioOption", "fdNumber", "getFileDescriptor", "fileDescriptors", "getFinalFileDescriptors", "stdioItems", "forwardStdio", "optionName", "getStreamName", "initialStdioItems", "isStdioArray", "initializeStdioItems", "direction", "getStreamDirection", "stdioItem", "handleNativeStream", "normalizedStdioItems", "normalizeTransforms", "objectMode", "getFdObjectMode", "validateFileObjectMode", "value", "initializeStdioItem", "handleInputOptions", "filterDuplicates", "validateStdioArray", "validateStreams", "getStdioItemType", "INVALID_STDIO_ARRAY_OPTIONS", "validateFileStdio", "type", "isRegularUrl", "isUnknownStdioString", "fileStdioItem", "FILE_TYPES", "fileDescriptor", "getFinalFileDescriptor", "error", "cleanupCustomStreams", "finalStdioItems", "addStreamProperties", "duplicateStream", "getDuplicateStream", "stream", "isStandardStream", "handleStdioSync", "options", "verboseInfo", "handleStdio", "addPropertiesSync", "forbiddenIfSync", "type", "optionName", "throwInvalidSyncValue", "TYPE_TO_MESSAGE", "forbiddenNativeIfSync", "value", "addProperties", "bufferToUint8Array", "file", "stripNewline", "value", "stripFinalNewline", "fdNumber", "getStripFinalNewline", "import_node_stream", "getSplitLinesGenerator", "binary", "preserveNewlines", "skipped", "state", "initializeSplitLines", "splitLinesSync", "chunk", "objectMode", "item", "splitLinesItemSync", "transform", "final", "splitGenerator", "linesFinal", "previousChunks", "start", "end", "newlineLength", "getNewlineLength", "line", "concatString", "getAppendNewlineGenerator", "readableObjectMode", "appendNewlineGenerator", "isWindowsNewline", "unixNewline", "windowsNewline", "LF", "concatBytes", "linesStringInfo", "linesUint8ArrayInfo", "firstChunk", "secondChunk", "concatUint8Array", "import_node_buffer", "getValidateTransformInput", "writableObjectMode", "optionName", "validateStringTransformInput", "chunk", "isUint8Array", "getValidateTransformReturn", "readableObjectMode", "validateObjectTransformReturn", "validateStringTransformReturn", "validateEmptyReturn", "import_node_buffer", "import_node_string_decoder", "getEncodingTransformGenerator", "binary", "encoding", "skipped", "encodingUint8ArrayGenerator", "stringDecoder", "encodingStringGenerator", "encodingStringFinal", "textEncoder", "chunk", "bufferToUint8Array", "isUint8Array", "lastChunk", "import_node_util", "pushChunks", "getChunks", "state", "getChunksArguments", "transformStream", "chunk", "transformChunk", "generators", "index", "transform", "identityGenerator", "transformedChunk", "finalChunks", "final", "generatorFinalChunks", "finalChunk", "destroyTransform", "currentIterable", "error", "pushChunksSync", "getChunksSync", "getChunksArguments", "transformStream", "done", "chunk", "error", "runTransformSync", "generators", "chunks", "transformChunkSync", "finalChunksSync", "index", "transform", "identityGenerator", "transformedChunk", "final", "generatorFinalChunksSync", "finalChunk", "generatorToStream", "value", "transform", "final", "writableObjectMode", "readableObjectMode", "optionName", "encoding", "state", "generators", "addInternalGenerators", "transformAsync", "isAsyncGenerator", "finalAsync", "transformMethod", "pushChunks", "transformChunk", "pushChunksSync", "transformChunkSync", "finalMethod", "finalChunks", "finalChunksSync", "destroyMethod", "destroyTransform", "chunk", "done", "runGeneratorsSync", "chunks", "stdioItems", "isInput", "type", "reversedGenerators", "runTransformSync", "binary", "preserveNewlines", "getValidateTransformInput", "getEncodingTransformGenerator", "getSplitLinesGenerator", "getValidateTransformReturn", "getAppendNewlineGenerator", "addInputOptionsSync", "fileDescriptors", "options", "fdNumber", "getInputFdNumbers", "addInputOptionSync", "direction", "stdioItems", "allStdioItems", "contents", "type", "optionName", "TYPE_TO_MESSAGE", "transformedContents", "applySingleInputGeneratorsSync", "joinToUint8Array", "newContents", "runGeneratorsSync", "validateSerializable", "invalidItem", "item", "isUint8Array", "import_node_fs", "shouldLogOutput", "stdioItems", "encoding", "verboseInfo", "fdNumber", "isFullVerbose", "BINARY_ENCODINGS", "fdUsesVerbose", "type", "value", "PIPED_STDIO_VALUES", "TRANSFORM_TYPES", "logLines", "linesIterable", "stream", "line", "isPipingStream", "logLine", "logLinesSync", "linesArray", "verboseMessage", "serializeVerboseMessage", "verboseLog", "transformOutputSync", "fileDescriptors", "output", "options", "isMaxBuffer", "verboseInfo", "state", "outputFiles", "result", "fdNumber", "transformOutputResultSync", "buffer", "encoding", "lines", "stripFinalNewline", "maxBuffer", "truncatedResult", "truncateMaxBufferSync", "uint8ArrayResult", "bufferToUint8Array", "stdioItems", "objectMode", "chunks", "runOutputGeneratorsSync", "serializedResult", "finalResult", "serializeChunks", "logOutputSync", "returnedResult", "writeToFiles", "error", "runGeneratorsSync", "joinToUint8Array", "joinToString", "splitLinesSync", "shouldLogOutput", "linesArray", "logLinesSync", "path", "type", "FILE_TYPES", "pathString", "getAllSync", "stdout", "stderr", "options", "stripNewline", "isUint8Array", "concatUint8Arrays", "import_node_events", "waitForExit", "subprocess", "context", "exitCode", "signal", "waitForExitOrError", "spawnPayload", "exitPayload", "waitForSubprocessExit", "waitForSuccessfulExit", "exitPromise", "isSubprocessErrorExit", "isFailedExit", "DiscardedError", "getExitResultSync", "error", "exitCode", "signal", "output", "maxBuffer", "resultError", "getResultError", "timedOut", "isMaxBuffer", "isMaxBufferSync", "isFailedExit", "DiscardedError", "execaCoreSync", "rawFile", "rawArguments", "rawOptions", "file", "commandArguments", "command", "escapedCommand", "startTime", "verboseInfo", "options", "fileDescriptors", "handleSyncArguments", "result", "spawnSubprocessSync", "handleResult", "handleCommand", "syncOptions", "normalizeSyncOptions", "normalizeOptions", "validateSyncOptions", "handleStdioSync", "ipc", "ipcInput", "detached", "cancelSignal", "throwInvalidSyncOption", "value", "syncResult", "runSubprocessSync", "resultError", "exitCode", "signal", "timedOut", "isMaxBuffer", "getExitResultSync", "output", "error", "transformOutputSync", "stdio", "stdioOutput", "fdNumber", "stripNewline", "all", "getAllSync", "getSyncResult", "addInputOptionsSync", "normalizedOptions", "normalizeSpawnSyncOptions", "makeEarlyError", "encoding", "maxBuffer", "getMaxBufferSync", "makeSuccessResult", "makeError", "import_node_events", "import_node_child_process", "import_node_process", "import_node_events", "getOneMessage", "anyProcess", "channel", "isSubprocess", "ipc", "reference", "filter", "validateIpcMethod", "isConnected", "getOneMessageAsync", "addReference", "ipcEmitter", "getIpcEmitter", "controller", "getMessage", "throwOnDisconnect", "throwOnStrictError", "error", "disconnect", "removeReference", "signal", "message", "throwOnEarlyDisconnect", "getStrictResponseError", "import_node_events", "getEachMessage", "anyProcess", "channel", "isSubprocess", "ipc", "reference", "loopOnMessages", "shouldAwait", "validateIpcMethod", "isConnected", "addReference", "ipcEmitter", "getIpcEmitter", "controller", "state", "stopOnDisconnect", "abortOnStrictError", "iterateOnMessages", "error", "getStrictResponseError", "message", "throwIfStrictError", "removeReference", "disconnect", "addIpcMethods", "subprocess", "ipc", "getIpcMethods", "getIpcExport", "anyProcess", "process", "isSubprocess", "getCancelSignal", "sendMessage", "getOneMessage", "getEachMessage", "import_node_child_process", "import_node_stream", "handleEarlyError", "error", "command", "escapedCommand", "fileDescriptors", "options", "startTime", "verboseInfo", "cleanupCustomStreams", "subprocess", "createDummyStreams", "readable", "writable", "duplex", "earlyError", "makeEarlyError", "promise", "handleDummyPromise", "stdin", "createDummyStream", "stdout", "stderr", "extraStdio", "all", "stdio", "stream", "handleResult", "import_node_fs", "import_node_buffer", "import_node_stream", "handleStdioAsync", "options", "verboseInfo", "handleStdio", "addPropertiesAsync", "forbiddenIfAsync", "type", "optionName", "TYPE_TO_MESSAGE", "addProperties", "generatorToStream", "value", "transform", "writableObjectMode", "readableObjectMode", "objectMode", "file", "import_node_events", "import_node_stream", "import_promises", "mergeStreams", "streams", "stream", "validateStream", "objectMode", "readableObjectMode", "highWaterMark", "getHighWaterMark", "passThroughStream", "MergedStream", "highWaterMarks", "readableHighWaterMark", "PassThroughStream", "#streams", "#ended", "#aborted", "#onFinished", "#unpipeEvent", "#streamPromises", "onMergedStreamFinished", "streamPromise", "endWhenStreamsDone", "unpipeEvent", "updateMaxListeners", "PASSTHROUGH_LISTENERS_COUNT", "controller", "onMergedStreamEnd", "onInputStreamsUnpipe", "signal", "error", "errorOrAbortStream", "unpipedStream", "ended", "aborted", "onFinished", "PASSTHROUGH_LISTENERS_PER_STREAM", "afterMergedStreamFinished", "onInputStreamEnd", "onInputStreamUnpipe", "abortStream", "endStream", "isAbortError", "errorStream", "noop", "increment", "maxListeners", "import_promises", "pipeStreams", "source", "destination", "onSourceFinish", "onDestinationFinish", "isStandardStream", "endDestinationStream", "abortSourceStream", "pipeOutputAsync", "subprocess", "fileDescriptors", "controller", "pipeGroups", "fdNumber", "stdioItems", "direction", "stream", "type", "TRANSFORM_TYPES", "pipeTransform", "pipeStdioItem", "outputStream", "inputStreams", "inputStream", "mergeStreams", "pipeStreams", "streamProperty", "SUBPROCESS_STREAM_PROPERTIES", "setStandardStreamMaxListeners", "outputStreams", "signal", "isStandardStream", "incrementMaxListeners", "MAX_LISTENERS_INCREMENT", "import_node_events", "signals", "processOk", "process", "kExitEmitter", "global", "ObjectDefineProperty", "Emitter", "ev", "fn", "list", "i", "code", "signal", "ret", "SignalExitBase", "signalExitWrap", "handler", "cb", "opts", "SignalExitFallback", "SignalExit", "#hupSig", "#emitter", "#process", "#originalProcessEmit", "#originalProcessReallyExit", "#sigListeners", "#loaded", "sig", "signals", "listeners", "count", "p", "s", "a", "#processEmit", "#processReallyExit", "listener", "args", "og", "onExit", "load", "unload", "cleanupOnExit", "subprocess", "cleanup", "detached", "signal", "removeExitHandler", "onExit", "normalizePipeArguments", "source", "sourcePromise", "boundOptions", "createNested", "pipeArguments", "startTime", "getStartTime", "destination", "destinationStream", "destinationError", "from", "unpipeSignal", "getDestinationStream", "sourceStream", "sourceError", "getSourceStream", "sourceOptions", "fileDescriptors", "SUBPROCESS_OPTIONS", "to", "getDestination", "getToStream", "error", "firstArgument", "mapDestinationArguments", "rawFile", "rawArguments", "rawOptions", "normalizeParameters", "options", "getFromStream", "handlePipeArgumentsError", "sourceStream", "sourceError", "destinationStream", "destinationError", "fileDescriptors", "sourceOptions", "startTime", "error", "getPipeArgumentsError", "createNonCommandError", "abortSourceStream", "endDestinationStream", "makeEarlyError", "PIPE_COMMAND_MESSAGE", "waitForBothSubprocesses", "subprocessPromises", "sourceStatus", "sourceReason", "sourceResult", "destinationStatus", "destinationReason", "destinationResult", "import_promises", "pipeSubprocessStream", "sourceStream", "destinationStream", "maxListenersController", "mergedStream", "MERGED_STREAMS", "pipeMoreSubprocessStream", "pipeFirstSubprocessStream", "incrementMaxListeners", "SOURCE_LISTENERS_PER_PIPE", "DESTINATION_LISTENERS_PER_PIPE", "cleanupMergedStreamsMap", "mergeStreams", "pipeStreams", "import_node_util", "unpipeOnAbort", "unpipeSignal", "unpipeContext", "unpipeOnSignalAbort", "sourceStream", "mergedStream", "fileDescriptors", "sourceOptions", "startTime", "error", "createNonCommandError", "pipeToSubprocess", "sourceInfo", "pipeArguments", "isPlainObject", "destination", "normalizedInfo", "normalizePipeArguments", "promise", "handlePipePromise", "sourcePromise", "sourceStream", "sourceOptions", "sourceError", "destinationStream", "destinationError", "unpipeSignal", "fileDescriptors", "startTime", "subprocessPromises", "getSubprocessPromises", "handlePipeArgumentsError", "maxListenersController", "mergedStream", "pipeSubprocessStream", "waitForBothSubprocesses", "unpipeOnAbort", "import_promises", "import_node_events", "import_node_stream", "iterateOnSubprocessStream", "subprocessStdout", "subprocess", "binary", "shouldEncode", "encoding", "preserveNewlines", "controller", "stopReadingOnExit", "iterateOnStream", "iterateForResult", "stream", "onStreamEnd", "lines", "stripFinalNewline", "allMixed", "stopReadingOnStreamEnd", "objectMode", "shouldSplit", "onStdoutChunk", "HIGH_WATER_MARK", "iterateOnData", "DEFAULT_OBJECT_HIGH_WATER_MARK", "generators", "getGenerators", "chunk", "transformChunkSync", "error", "finalChunksSync", "getEncodingTransformGenerator", "getSplitLinesGenerator", "getStreamOutput", "stream", "onStreamEnd", "fdNumber", "encoding", "buffer", "maxBuffer", "lines", "allMixed", "stripFinalNewline", "verboseInfo", "streamInfo", "logPromise", "logOutputAsync", "resumeStream", "stripFinalNewlineValue", "getStripFinalNewline", "iterable", "iterateForResult", "output", "getStreamContents", "fileDescriptors", "shouldLogOutput", "linesIterable", "logLines", "readableObjectMode", "getStreamAsArray", "getStreamAsArrayBuffer", "getStreamAsString", "error", "handleBufferedData", "handleMaxBuffer", "getBufferedData", "streamPromise", "bufferedData", "isArrayBuffer", "import_promises", "waitForStream", "stream", "fdNumber", "streamInfo", "isSameDirection", "stopOnExit", "state", "handleStdinDestroy", "abortController", "error", "handleStreamError", "originalStdin", "subprocess", "spyOnStdinDestroy", "subprocessStdin", "_destroy", "destroyArguments", "setStdinCleanedUp", "exitCode", "signalCode", "shouldIgnoreStreamError", "isStreamEpipe", "isStreamAbort", "isInputFileDescriptor", "fileDescriptors", "waitForStdioStreams", "subprocess", "encoding", "buffer", "maxBuffer", "lines", "stripFinalNewline", "verboseInfo", "streamInfo", "stream", "fdNumber", "waitForSubprocessStream", "allMixed", "onStreamEnd", "waitForStream", "isInputFileDescriptor", "output", "getStreamOutput", "makeAllStream", "stdout", "stderr", "all", "mergeStreams", "waitForAllStream", "subprocess", "encoding", "buffer", "maxBuffer", "lines", "stripFinalNewline", "verboseInfo", "streamInfo", "waitForSubprocessStream", "getAllStream", "getAllMixed", "bufferStdout", "bufferStderr", "import_node_events", "shouldLogIpc", "verboseInfo", "isFullVerbose", "logIpcOutput", "message", "verboseMessage", "serializeVerboseMessage", "verboseLog", "waitForIpcOutput", "subprocess", "bufferArray", "maxBufferArray", "ipc", "ipcOutput", "verboseInfo", "isVerbose", "shouldLogIpc", "buffer", "getFdSpecificValue", "maxBuffer", "message", "loopOnMessages", "checkIpcMaxBuffer", "logIpcOutput", "getBufferedIpcOutput", "ipcOutputPromise", "waitForSubprocessResult", "subprocess", "encoding", "buffer", "maxBuffer", "lines", "timeout", "cancelSignal", "gracefulCancel", "forceKillAfterDelay", "stripFinalNewline", "ipc", "ipcInput", "context", "verboseInfo", "fileDescriptors", "originalStreams", "onInternalError", "controller", "exitPromise", "waitForExit", "streamInfo", "stdioPromises", "waitForStdioStreams", "allPromise", "waitForAllStream", "ipcOutput", "ipcOutputPromise", "waitForIpcOutput", "originalPromises", "waitForOriginalStreams", "customStreamsEndPromises", "waitForCustomStreamsEnd", "waitForSuccessfulExit", "sendIpcInput", "throwOnSubprocessError", "throwOnTimeout", "throwOnCancel", "throwOnGracefulCancel", "error", "stdioPromise", "getBufferedData", "getBufferedIpcOutput", "stream", "fdNumber", "waitForStream", "stdioItems", "value", "isStream", "isStandardStream", "type", "TRANSFORM_TYPES", "signal", "initializeConcurrentStreams", "addConcurrentStream", "concurrentStreams", "stream", "waitName", "weakMap", "promises", "promise", "createDeferred", "waitForConcurrentStreams", "resolve", "subprocess", "isSubprocessExit", "import_node_stream", "import_node_util", "import_promises", "safeWaitForSubprocessStdin", "subprocessStdin", "waitForSubprocessStdin", "safeWaitForSubprocessStdout", "subprocessStdout", "waitForSubprocessStdout", "waitForSubprocess", "subprocess", "error", "destroyOtherStream", "stream", "isOpen", "isStreamAbort", "createReadable", "subprocess", "concurrentStreams", "encoding", "from", "binaryOption", "preserveNewlines", "binary", "BINARY_ENCODINGS", "subprocessStdout", "waitReadableDestroy", "getSubprocessStdout", "readableEncoding", "readableObjectMode", "readableHighWaterMark", "getReadableOptions", "read", "onStdoutDataDone", "getReadableMethods", "readable", "onReadableDestroy", "onStdoutFinished", "getFromStream", "addConcurrentStream", "DEFAULT_OBJECT_HIGH_WATER_MARK", "createDeferred", "onStdoutData", "iterateOnSubprocessStream", "onRead", "value", "done", "subprocessStdin", "waitForSubprocessStdout", "safeWaitForSubprocessStdin", "error", "destroyOtherReadable", "waitForConcurrentStreams", "waitForSubprocess", "stream", "destroyOtherStream", "import_node_stream", "import_node_util", "createWritable", "subprocess", "concurrentStreams", "to", "subprocessStdin", "waitWritableFinal", "waitWritableDestroy", "getSubprocessStdin", "writable", "getWritableMethods", "onWritableDestroy", "onStdinFinished", "getToStream", "addConcurrentStream", "onWrite", "onWritableFinal", "chunk", "encoding", "done", "waitForConcurrentStreams", "subprocessStdout", "waitForSubprocessStdin", "error", "safeWaitForSubprocessStdout", "destroyOtherWritable", "waitForSubprocess", "stream", "destroyOtherStream", "import_node_stream", "import_node_util", "createDuplex", "subprocess", "concurrentStreams", "encoding", "from", "to", "binaryOption", "preserveNewlines", "binary", "BINARY_ENCODINGS", "subprocessStdout", "waitReadableDestroy", "getSubprocessStdout", "subprocessStdin", "waitWritableFinal", "waitWritableDestroy", "getSubprocessStdin", "readableEncoding", "readableObjectMode", "readableHighWaterMark", "getReadableOptions", "read", "onStdoutDataDone", "getReadableMethods", "duplex", "getWritableMethods", "onDuplexDestroy", "onStdoutFinished", "onStdinFinished", "error", "onReadableDestroy", "onWritableDestroy", "createIterable", "subprocess", "encoding", "from", "binaryOption", "preserveNewlines", "binary", "BINARY_ENCODINGS", "subprocessStdout", "getFromStream", "onStdoutData", "iterateOnSubprocessStream", "iterateOnStdoutData", "addConvertedStreams", "subprocess", "encoding", "concurrentStreams", "initializeConcurrentStreams", "createReadable", "createWritable", "createDuplex", "createIterable", "mergePromise", "subprocess", "promise", "property", "descriptor", "descriptors", "value", "nativePromisePrototype", "execaCoreAsync", "rawFile", "rawArguments", "rawOptions", "createNested", "file", "commandArguments", "command", "escapedCommand", "startTime", "verboseInfo", "options", "fileDescriptors", "handleAsyncArguments", "subprocess", "promise", "spawnSubprocessAsync", "pipeToSubprocess", "mergePromise", "SUBPROCESS_OPTIONS", "handleCommand", "normalizedOptions", "normalizeOptions", "handleAsyncOptions", "handleStdioAsync", "timeout", "signal", "error", "handleEarlyError", "controller", "originalStreams", "pipeOutputAsync", "cleanupOnExit", "context", "onInternalError", "createDeferred", "subprocessKill", "makeAllStream", "addConvertedStreams", "addIpcMethods", "handlePromise", "errorInfo", "exitCode", "stdioResults", "allResult", "ipcOutput", "waitForSubprocessResult", "stdio", "stdioResult", "fdNumber", "stripNewline", "all", "result", "getAsyncResult", "handleResult", "makeError", "MaxBufferError", "makeSuccessResult", "mergeOptions", "boundOptions", "options", "newOptions", "optionName", "optionValue", "mergeOption", "boundOptionValue", "DEEP_OPTIONS", "isPlainObject", "FD_SPECIFIC_OPTIONS", "createExeca", "mapArguments", "boundOptions", "deepOptions", "setBoundExeca", "createNested", "boundExeca", "execaArguments", "callBoundExeca", "firstArgument", "nextArguments", "isPlainObject", "mergeOptions", "file", "commandArguments", "options", "isSync", "parseArguments", "execaCoreSync", "execaCoreAsync", "callArguments", "isTemplateString", "parseTemplates", "initialFile", "initialArguments", "initialOptions", "normalizeParameters", "mergedOptions", "mapCommandAsync", "file", "commandArguments", "parseCommand", "mapCommandSync", "command", "unusedArguments", "parseCommandString", "trimmedCommand", "tokens", "token", "SPACES_REGEXP", "previousToken", "setScriptSync", "boundExeca", "createNested", "boundOptions", "mapScriptSync", "mapScriptAsync", "options", "getScriptOptions", "getScriptStdinOption", "input", "inputFile", "stdio", "deepScriptOptions", "execa", "createExeca", "execaSync", "execaCommand", "mapCommandAsync", "execaCommandSync", "mapCommandSync", "execaNode", "mapNode", "$", "mapScriptAsync", "deepScriptOptions", "setScriptSync", "sendMessage", "getOneMessage", "getEachMessage", "getCancelSignal", "getIpcExport", "createIcon", "status", "runShellScript", "command", "stdout", "execaCommand", "preferences", "brewPath", "getServices", "fs", "data", "runShellScript", "lines", "i", "res", "line", "split", "status", "stopService", "service", "toast", "d", "startService", "restartService", "runService", "services", "s", "import_api", "import_api", "import_os", "import_jsx_runtime", "StopService", "props", "stopService", "RestartService", "restartService", "StartService", "startService", "RunService", "runService", "PlistActions", "path", "AllActions", "BrewActions", "import_jsx_runtime", "Command", "services", "setServices", "getServices", "service", "d", "createIcon", "BrewActions"]
}

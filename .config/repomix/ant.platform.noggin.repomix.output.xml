<repomix>This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/package.json, **/tsconfig.json, **/gateways/noggin/src/**/*.ts, **/lib-platform/src/**/*.ts
- Files matching these patterns are excluded: **/data/, **/gen/, **/*.log, **@anterior/models/data/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)</notes><additional_info></additional_info></file_summary><directory_structure>codegen/
  anterior-schemas/
    static/
      ts/
        package.json
        tsconfig.json
    package.json
    tsconfig.json
  models/
    ts/
      package.json
      tsconfig.json
  openapi-client/
    ts/
      package.json
      tsconfig.json
  proto/
    ts/
      package.json
      tsconfig.json
experimental/
  clinical_tool/
    frontend/
      package.json
      tsconfig.json
  inpatient-demo/
    package.json
    tsconfig.json
  keynote/
    package.json
    tsconfig.json
  noods/
    package.json
    tsconfig.json
gateways/
  noggin/
    src/
      @anterior/
        models/
          events/
            stems/
              attach_clinicals_to_stem_v1_1.ts
              attach_criteria_to_stem_v1_1.ts
              attach_services_to_stem_v1_1.ts
              create_determination_v1_1.ts
              create_stem_v1_1.ts
              stem_log_v1_1.ts
              stem_meta_v1_1.ts
          s3/
            clinical_extraction.ts
            criteria_document.ts
            criteria_extraction.ts
            determination.ts
            healthhelp.ts
          shared/
            backend_config.ts
            frontend_config.ts
            pdf_section_v01_20250514.ts
            text_section_v01_20250514.ts
            webhook_api_v1x0.ts
          workflows/
            flonotes/
              process_flonotes_llm/
                process_flonotes_llm_egress.ts
                process_flonotes_llm_ingress.ts
            pdfs/
              process_pdf_standalone/
                process_pdf_standalone_egress.ts
                process_pdf_standalone_ingress.ts
      agents/
        app.ts
        infra.ts
        main.ts
        platform.ts
      ahip/
        app.ts
        infra.ts
        main.ts
        platform.ts
      auth/
        app.ts
        jwt.ts
        main.ts
      chat/
        models/
          extracts.ts
          message.ts
        orchestrator/
          tools/
            mnr.ts
          anthropic.ts
          index.ts
          types.ts
        app.ts
        infra.ts
        main.ts
        parser.test.ts
        parser.ts
        platform.ts
      flobot/
        app.ts
        main.ts
      flonotes/
        test-e2e/
          flonotes.spec.ts
        app.ts
        infra.ts
        main.ts
        platform.ts
      flopilot/
        app.ts
        infra.ts
        main.ts
        platform.ts
      health/
        app.ts
        main.ts
      hello-world/
        test-e2e/
          greet.spec.ts
          health.spec.ts
          latest.spec.ts
        test-integration/
          hello.test.ts
        app.ts
        hello.test.ts
        hello.ts
      notes/
        handlers/
          notes.ts
        schemas/
          api.ts
          flows.ts
          models.ts
          types.ts
        app.ts
        infra.ts
        main.ts
        platform.ts
      pdfs/
        models/
          flows.ts
          schemas.ts
        app.ts
        infra.ts
        main.ts
        platform.ts
      stems/
        events/
          emit-stem-event.ts
          to-event-schema.ts
        handlers/
          attach-clinicals.ts
          attach-criteria.ts
          attach-services.ts
          create-stem.ts
          rollup.ts
        schemas/
          events.ts
        utils/
          common.ts
        app.ts
        infra.ts
        main.ts
        platform.ts
      tasks/
        handlers/
          mnr.ts
          populate-note-template.ts
          project-log-events.ts
          run-igg.ts
          validate-clinicals.ts
        utils/
          artifacts.ts
        app.ts
        infra.ts
        main.ts
        platform.ts
        schemas.ts
      config.ts
      index.ts
      migrate.ts
    package.json
    tsconfig.json
  noodle/
    package.json
    tsconfig.json
infra/
  cdktf/
    package.json
    tsconfig.json
lib/
  ts/
    lib-infra/
      package.json
      tsconfig.json
    lib-platform/
      src/
        app.test.ts
        app.ts
        assoc.contract.ts
        assoc.test.ts
        assoc.ts
        async.ts
        auth.test.ts
        auth.ts
        blob.contract.ts
        blob.test.ts
        blob.ts
        body.test.ts
        body.ts
        config.test.ts
        config.ts
        cors.test.ts
        cors.ts
        errors.ts
        events.contract.ts
        events.test.ts
        events.ts
        flows.test.ts
        flows.ts
        ids.test.ts
        ids.ts
        in-memory.test.ts
        in-memory.ts
        invariant.test.ts
        invariant.ts
        json.test.ts
        json.ts
        jwt.ts
        kv.contract.ts
        kv.test.ts
        kv.ts
        log.ts
        object.test.ts
        object.ts
        projector.test.ts
        projector.ts
        queue.ts
        schema.test.ts
        schema.ts
        secrets.test.ts
        secrets.ts
        serializer.ts
        tasks.ts
        test.ts
        types.ts
        url.test.ts
        url.ts
        utils.ts
        worker.ts
        zod.ts
      package.json
      tsconfig.json
surfaces/
  cortex/
    package.json
    tsconfig.json
  neuron/
    src/
      docs/
        package.json
        tsconfig.json
    package.json
    tsconfig.json
tests/
  e2e/
    package.json
    tsconfig.json
tools/
  prettier-dependencies/
    package.json
package.json
tsconfig.json</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="codegen/models/ts/package.json">{
	&quot;name&quot;: &quot;@anterior/models&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;main&quot;: &quot;dist/index.js&quot;,
	&quot;module&quot;: &quot;dist/index.js&quot;,
	&quot;types&quot;: &quot;dist/index.d.ts&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;exports&quot;: {
		&quot;./package.json&quot;: &quot;./package.json&quot;,
		&quot;.&quot;: {
			&quot;types&quot;: &quot;./dist/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/index.js&quot;,
			&quot;require&quot;: &quot;./dist/index.js&quot;
		},
		&quot;./*&quot;: {
			&quot;types&quot;: &quot;./dist/*.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/*.js&quot;,
			&quot;require&quot;: &quot;./dist/*.js&quot;
		}
	},
	&quot;files&quot;: [
		&quot;dist&quot;
	],
	&quot;scripts&quot;: {
		&quot;build&quot;: &quot;tsup&quot;,
		&quot;build:watch&quot;: &quot;tsup --watch&quot;,
		&quot;lint&quot;: &quot;tsc&quot;,
		&quot;test&quot;: &quot;echo no tests&quot;
	},
	&quot;dependencies&quot;: {
		&quot;tsup&quot;: &quot;^8.2.4&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;esbuild&quot;: &quot;0.24.0&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;typescript&quot;: &quot;^5&quot;,
		&quot;zod&quot;: &quot;^3&quot;
	}
}</file><file path="codegen/models/ts/tsconfig.json">{
	&quot;extends&quot;: &quot;../../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		// Building for a library in a monorepo
		&quot;rootDir&quot;: &quot;./src&quot;,
		&quot;declarationDir&quot;: &quot;./dist&quot;,
		&quot;tsBuildInfoFile&quot;: &quot;./dist/tsconfig.tsbuildinfo&quot;,
		&quot;outDir&quot;: &quot;./dist&quot;,
		&quot;declaration&quot;: true,
		&quot;composite&quot;: true,
		&quot;sourceMap&quot;: true,
		&quot;declarationMap&quot;: true
	},
	&quot;include&quot;: [&quot;src/**/*&quot;]
}</file><file path="codegen/openapi-client/ts/package.json">{
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;name&quot;: &quot;@anterior/openapi&quot;,
	&quot;main&quot;: &quot;dist/index.js&quot;,
	&quot;module&quot;: &quot;dist/index.js&quot;,
	&quot;types&quot;: &quot;dist/index.d.ts&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;exports&quot;: {
		&quot;./package.json&quot;: &quot;./package.json&quot;,
		&quot;.&quot;: {
			&quot;types&quot;: &quot;./dist/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/index.js&quot;,
			&quot;require&quot;: &quot;./dist/index.js&quot;
		},
		&quot;./*&quot;: {
			&quot;types&quot;: &quot;./dist/*.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/*.js&quot;,
			&quot;require&quot;: &quot;./dist/*.js&quot;
		}
	},
	&quot;files&quot;: [
		&quot;dist&quot;
	],
	&quot;scripts&quot;: {
		&quot;build&quot;: &quot;tsup&quot;,
		&quot;build:watch&quot;: &quot;tsup --watch&quot;,
		&quot;generate&quot;: &quot;npx orval --config ./orval.config.ts&quot;,
		&quot;format&quot;: &quot;npx prettier --write ./src&quot;,
		&quot;lint&quot;: &quot;tsc&quot;,
		&quot;test&quot;: &quot;echo no test&quot;
	},
	&quot;dependencies&quot;: {
		&quot;case-anything&quot;: &quot;^3.1.0&quot;,
		&quot;orval&quot;: &quot;7.3.0&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@faker-js/faker&quot;: &quot;^8.4.1&quot;,
		&quot;@types/node&quot;: &quot;^20.12.8&quot;,
		&quot;esbuild&quot;: &quot;0.24.0&quot;,
		&quot;msw&quot;: &quot;^2.3.5&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;,
		&quot;tsup&quot;: &quot;^8.2.4&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;@tanstack/react-query&quot;: &quot;^5.44.4&quot;,
		&quot;zod&quot;: &quot;^3&quot;,
		&quot;typescript&quot;: &quot;^5&quot;,
		&quot;react&quot;: &quot;^18 || ^19&quot;,
		&quot;react-dom&quot;: &quot;^18 || ^19&quot;
	}
}</file><file path="codegen/openapi-client/ts/tsconfig.json">{
	&quot;extends&quot;: &quot;../../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		// Turn off some strict checks
		&quot;noUncheckedIndexedAccess&quot;: false,
		&quot;noImplicitOverride&quot;: false,
		&quot;noImplicitReturns&quot;: false,
		&quot;noFallthroughCasesInSwitch&quot;: false,
		&quot;exactOptionalPropertyTypes&quot;: false,
		&quot;noPropertyAccessFromIndexSignature&quot;: false,

		// For code that will run in the browser
		&quot;lib&quot;: [&quot;ES2022&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],

		// Building for a library in a monorepo
		&quot;rootDir&quot;: &quot;./src&quot;,
		&quot;declarationDir&quot;: &quot;./dist&quot;,
		&quot;tsBuildInfoFile&quot;: &quot;./dist/tsconfig.tsbuildinfo&quot;,
		&quot;outDir&quot;: &quot;./dist&quot;,
		&quot;declaration&quot;: true,
		&quot;composite&quot;: true,
		&quot;sourceMap&quot;: true,
		&quot;declarationMap&quot;: true
	},
	&quot;include&quot;: [&quot;src/**/*&quot;]
}</file><file path="codegen/proto/ts/package.json">{
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;name&quot;: &quot;@anterior/proto&quot;,
	&quot;main&quot;: &quot;dist/index.js&quot;,
	&quot;module&quot;: &quot;dist/index.js&quot;,
	&quot;types&quot;: &quot;dist/index.d.ts&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;exports&quot;: {
		&quot;./package.json&quot;: &quot;./package.json&quot;,
		&quot;.&quot;: {
			&quot;types&quot;: &quot;./dist/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/index.js&quot;,
			&quot;require&quot;: &quot;./dist/index.js&quot;
		},
		&quot;./*&quot;: {
			&quot;types&quot;: &quot;./dist/*.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/*.js&quot;,
			&quot;require&quot;: &quot;./dist/*.js&quot;
		}
	},
	&quot;files&quot;: [
		&quot;dist&quot;
	],
	&quot;scripts&quot;: {
		&quot;build&quot;: &quot;tsup&quot;,
		&quot;build:watch&quot;: &quot;tsup --watch&quot;,
		&quot;format&quot;: &quot;npx prettier --write ./src&quot;,
		&quot;lint&quot;: &quot;tsc&quot;,
		&quot;test&quot;: &quot;echo no tests&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@bufbuild/protobuf&quot;: &quot;^1.10.0&quot;,
		&quot;nice-grpc&quot;: &quot;^2.1.9&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;esbuild&quot;: &quot;0.24.0&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;,
		&quot;tsup&quot;: &quot;^8.2.4&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;typescript&quot;: &quot;^5&quot;
	}
}</file><file path="codegen/proto/ts/tsconfig.json">{
	&quot;extends&quot;: &quot;../../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		// Building for a library in a monorepo
		&quot;rootDir&quot;: &quot;./src&quot;,
		&quot;declarationDir&quot;: &quot;./dist&quot;,
		&quot;tsBuildInfoFile&quot;: &quot;./dist/tsconfig.tsbuildinfo&quot;,
		&quot;outDir&quot;: &quot;./dist&quot;,
		&quot;declaration&quot;: true,
		&quot;composite&quot;: true,
		&quot;sourceMap&quot;: true,
		&quot;declarationMap&quot;: true
	},
	&quot;include&quot;: [&quot;src/**/*&quot;]
}</file><file path="experimental/clinical_tool/frontend/package.json">{
	&quot;name&quot;: &quot;@anterior/clinical-tool-frontend&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;type&quot;: &quot;module&quot;,
	&quot;bin&quot;: {
		&quot;clinical-tool-frontend&quot;: &quot;server.cjs&quot;,
		&quot;clinical-tool-frontend-migrate&quot;: &quot;migrate.sh&quot;
	},
	&quot;scripts&quot;: {
		&quot;dev&quot;: &quot;VITE_PORT=${ANT_LISTEN_PORT:-3000} vite&quot;,
		&quot;start&quot;: &quot;VITE_PORT=${ANT_LISTEN_PORT:-3000} vite&quot;,
		&quot;build&quot;: &quot;vite build&quot;,
		&quot;preview&quot;: &quot;vite preview&quot;,
		&quot;test&quot;: &quot;echo no tests&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@types/react&quot;: &quot;^18.3.12&quot;,
		&quot;@types/react-dom&quot;: &quot;^18.3.1&quot;,
		&quot;autoprefixer&quot;: &quot;^10.4.20&quot;,
		&quot;axios&quot;: &quot;^1.7.7&quot;,
		&quot;express&quot;: &quot;^4.21.1&quot;,
		&quot;http-proxy-middleware&quot;: &quot;^3.0.3&quot;,
		&quot;lucide-react&quot;: &quot;^0.451.0&quot;,
		&quot;pino&quot;: &quot;^9.5.0&quot;,
		&quot;react&quot;: &quot;^18.3.1&quot;,
		&quot;react-dom&quot;: &quot;^18.3.1&quot;,
		&quot;react-router-dom&quot;: &quot;^6.26.2&quot;,
		&quot;typescript&quot;: &quot;^4.9.5&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@vitejs/plugin-react&quot;: &quot;^4.3.3&quot;,
		&quot;react-svg-pan-zoom&quot;: &quot;^3.13.1&quot;,
		&quot;react-tabs&quot;: &quot;^6.0.2&quot;,
		&quot;tailwindcss&quot;: &quot;^3.4.13&quot;,
		&quot;vite&quot;: &quot;^5.4.11&quot;
	}
}</file><file path="experimental/clinical_tool/frontend/tsconfig.json">{
	&quot;extends&quot;: &quot;../../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		&quot;allowJs&quot;: true,
		&quot;checkJs&quot;: false,
		&quot;noEmit&quot;: true,
		&quot;verbatimModuleSyntax&quot;: false,
		&quot;strict&quot;: false,
		&quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],
		&quot;target&quot;: &quot;ES2022&quot;,
		// &quot;module&quot;: &quot;esnext&quot;,
		// &quot;moduleResolution&quot;: &quot;node&quot;,
		&quot;exactOptionalPropertyTypes&quot;: false,
		&quot;strictNullChecks&quot;: false,
		&quot;jsx&quot;: &quot;react-jsx&quot;
	},
	&quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.js&quot;]
}</file><file path="experimental/inpatient-demo/package.json">{
	&quot;name&quot;: &quot;@anterior/inpatient-demo&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;type&quot;: &quot;module&quot;,
	&quot;scripts&quot;: {
		&quot;dev&quot;: &quot;vinxi dev&quot;,
		&quot;build&quot;: &quot;vinxi build&quot;,
		&quot;start&quot;: &quot;vinxi start&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/neuron&quot;: &quot;0.0.0&quot;,
		&quot;@tanstack/react-query&quot;: &quot;^5.51.21&quot;,
		&quot;@tanstack/react-query-devtools&quot;: &quot;^5.51.21&quot;,
		&quot;@tanstack/react-router&quot;: &quot;^1.49.2&quot;,
		&quot;@tanstack/react-table&quot;: &quot;^8.20.5&quot;,
		&quot;@tanstack/router-devtools&quot;: &quot;^1.49.2&quot;,
		&quot;@tanstack/router-plugin&quot;: &quot;^1.49.3&quot;,
		&quot;@tiptap/extension-placeholder&quot;: &quot;^2.6.6&quot;,
		&quot;@tiptap/pm&quot;: &quot;^2.6.6&quot;,
		&quot;@tiptap/react&quot;: &quot;^2.6.6&quot;,
		&quot;@tiptap/starter-kit&quot;: &quot;^2.6.6&quot;,
		&quot;@trpc/client&quot;: &quot;11.0.0-rc.477&quot;,
		&quot;@trpc/react-query&quot;: &quot;11.0.0-rc.477&quot;,
		&quot;@trpc/server&quot;: &quot;11.0.0-rc.477&quot;,
		&quot;react&quot;: &quot;^18.2.0&quot;,
		&quot;react-dom&quot;: &quot;^18.2.0&quot;,
		&quot;recharts&quot;: &quot;^2.12.7&quot;,
		&quot;redaxios&quot;: &quot;^0.5.1&quot;,
		&quot;superjson&quot;: &quot;^2.2.1&quot;,
		&quot;tailwind-variants&quot;: &quot;^0.2.1&quot;,
		&quot;vinxi&quot;: &quot;0.4.1&quot;,
		&quot;zod&quot;: &quot;^3.24.2&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@tailwindcss/container-queries&quot;: &quot;^0.1.1&quot;,
		&quot;@tailwindcss/typography&quot;: &quot;^0.5.15&quot;,
		&quot;@types/react&quot;: &quot;^18.2.47&quot;,
		&quot;@types/react-dom&quot;: &quot;^18.2.18&quot;,
		&quot;@vitejs/plugin-react&quot;: &quot;^4.3.1&quot;,
		&quot;autoprefixer&quot;: &quot;^10.4.20&quot;,
		&quot;postcss&quot;: &quot;^8.4.41&quot;,
		&quot;tailwindcss&quot;: &quot;^3.4.10&quot;,
		&quot;tailwindcss-animate&quot;: &quot;^1.0.7&quot;
	}
}</file><file path="experimental/inpatient-demo/tsconfig.json">{
	&quot;extends&quot;: &quot;../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		&quot;incremental&quot;: true,
		&quot;exactOptionalPropertyTypes&quot;: false,
		// The code is for frontend and runs in the DOM
		&quot;lib&quot;: [&quot;ES2023&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
		&quot;jsx&quot;: &quot;preserve&quot;
	}
}</file><file path="experimental/keynote/package.json">{
	&quot;name&quot;: &quot;@anterior/keynote&quot;,
	&quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;scripts&quot;: {
		&quot;dev&quot;: &quot;vinxi dev&quot;,
		&quot;build&quot;: &quot;vinxi build&quot;,
		&quot;start&quot;: &quot;vinxi start&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/neuron&quot;: &quot;0.0.0&quot;,
		&quot;@tanstack/react-query&quot;: &quot;^5.51.21&quot;,
		&quot;@tanstack/react-query-devtools&quot;: &quot;^5.51.21&quot;,
		&quot;@tanstack/react-router&quot;: &quot;^1.49.2&quot;,
		&quot;@tanstack/react-table&quot;: &quot;^8.20.5&quot;,
		&quot;@tanstack/router-devtools&quot;: &quot;^1.49.2&quot;,
		&quot;@tanstack/router-plugin&quot;: &quot;^1.49.3&quot;,
		&quot;@tiptap/extension-placeholder&quot;: &quot;^2.6.6&quot;,
		&quot;@tiptap/pm&quot;: &quot;^2.6.6&quot;,
		&quot;@tiptap/react&quot;: &quot;^2.6.6&quot;,
		&quot;@tiptap/starter-kit&quot;: &quot;^2.6.6&quot;,
		&quot;@trpc/client&quot;: &quot;11.0.0-rc.477&quot;,
		&quot;@trpc/react-query&quot;: &quot;11.0.0-rc.477&quot;,
		&quot;@trpc/server&quot;: &quot;11.0.0-rc.477&quot;,
		&quot;react&quot;: &quot;^18.2.0&quot;,
		&quot;react-dom&quot;: &quot;^18.2.0&quot;,
		&quot;recharts&quot;: &quot;^2.12.7&quot;,
		&quot;redaxios&quot;: &quot;^0.5.1&quot;,
		&quot;superjson&quot;: &quot;^2.2.1&quot;,
		&quot;tailwind-variants&quot;: &quot;^0.2.1&quot;,
		&quot;vinxi&quot;: &quot;0.4.1&quot;,
		&quot;zod&quot;: &quot;^3.24.2&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@tailwindcss/container-queries&quot;: &quot;^0.1.1&quot;,
		&quot;@tailwindcss/typography&quot;: &quot;^0.5.15&quot;,
		&quot;@types/react&quot;: &quot;^18.2.47&quot;,
		&quot;@types/react-dom&quot;: &quot;^18.2.18&quot;,
		&quot;@vitejs/plugin-react&quot;: &quot;^4.3.1&quot;,
		&quot;autoprefixer&quot;: &quot;^10.4.20&quot;,
		&quot;postcss&quot;: &quot;^8.4.41&quot;,
		&quot;tailwindcss&quot;: &quot;^3.4.10&quot;,
		&quot;tailwindcss-animate&quot;: &quot;^1.0.7&quot;
	}
}</file><file path="experimental/keynote/tsconfig.json">{
	&quot;extends&quot;: &quot;../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		&quot;incremental&quot;: true,
		&quot;exactOptionalPropertyTypes&quot;: false,
		// The code is for frontend and runs in the DOM
		&quot;lib&quot;: [&quot;ES2023&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
		&quot;jsx&quot;: &quot;preserve&quot;
	}
}</file><file path="experimental/noods/package.json">{
	&quot;name&quot;: &quot;@anterior/noods&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;private&quot;: true,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;scripts&quot;: {
		&quot;dev&quot;: &quot;bun run --hot src/index.ts&quot;,
		&quot;start&quot;: &quot;bun run src/index.ts&quot;,
		&quot;format&quot;: &quot;prettier --plugin prettier-plugin-organize-imports --ignore-path ../../.gitignore --write .&quot;,
		&quot;build&quot;: &quot;echo &apos;noodle build: Nothing to build&apos;&quot;,
		&quot;migrate&quot;: &quot;echo &apos;Nothing to migrate...&apos;&quot;,
		&quot;test&quot;: &quot;vitest run&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/models&quot;: &quot;0.0.0&quot;,
		&quot;@anterior/openapi&quot;: &quot;0.0.0&quot;,
		&quot;@anterior/proto&quot;: &quot;0.0.0&quot;,
		&quot;@hono/prometheus&quot;: &quot;^1.0.1&quot;,
		&quot;@hono/trpc-server&quot;: &quot;^0.3.2&quot;,
		&quot;@trpc/server&quot;: &quot;^11.0.0-rc.477&quot;,
		&quot;case-anything&quot;: &quot;^3.1.0&quot;,
		&quot;date-fns&quot;: &quot;^3.6.0&quot;,
		&quot;hono&quot;: &quot;^4.5.5&quot;,
		&quot;hono-pino&quot;: &quot;^0.1.1&quot;,
		&quot;is-what&quot;: &quot;^5.0.2&quot;,
		&quot;zod&quot;: &quot;^3.24.2&quot;,
		&quot;pino&quot;: &quot;^9.3.2&quot;,
		&quot;prom-client&quot;: &quot;^15.1.3&quot;,
		&quot;@t3-oss/env-core&quot;: &quot;^0.11.0&quot;,
		&quot;superjson&quot;: &quot;^2.2.1&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@faker-js/faker&quot;: &quot;^8.4.1&quot;,
		&quot;pino-pretty&quot;: &quot;^11.2.2&quot;,
		&quot;vitest&quot;: &quot;^2.0.5&quot;,
		&quot;typescript&quot;: &quot;^5.5.4&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;,
		&quot;eslint&quot;: &quot;^9.9.0&quot;,
		&quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,
		&quot;@types/eslint&quot;: &quot;^9.6.0&quot;,
		&quot;@types/eslint-config-prettier&quot;: &quot;^6.11.3&quot;,
		&quot;@types/eslint__js&quot;: &quot;^8.42.3&quot;
	}
}</file><file path="experimental/noods/tsconfig.json">{
	&quot;extends&quot;: &quot;../../tsconfig.json&quot;, // Root level tsconfig.json
	&quot;include&quot;: [&quot;src/**/*&quot;]
}</file><file path="gateways/noggin/src/@anterior/models/workflows/flonotes/process_flonotes_llm/process_flonotes_llm_egress.ts">import { z } from &quot;zod&quot;
⋮----
export type ProcessFlonotesLlmEgress = z.infer&lt;typeof processFlonotesLlmEgress&gt;</file><file path="gateways/noggin/src/@anterior/models/workflows/flonotes/process_flonotes_llm/process_flonotes_llm_ingress.ts">import { z } from &quot;zod&quot;
⋮----
export type ProcessFlonotesLlmIngress = z.infer&lt;typeof processFlonotesLlmIngress&gt;</file><file path="gateways/noggin/src/@anterior/models/workflows/pdfs/process_pdf_standalone/process_pdf_standalone_egress.ts">import { z } from &quot;zod&quot;
⋮----
export type ProcessPdfStandaloneEgress = z.infer&lt;typeof processPdfStandaloneEgress&gt;</file><file path="gateways/noggin/src/@anterior/models/workflows/pdfs/process_pdf_standalone/process_pdf_standalone_ingress.ts">import { z } from &quot;zod&quot;
⋮----
export type ProcessPdfStandaloneIngress = z.infer&lt;typeof processPdfStandaloneIngress&gt;</file><file path="gateways/noggin/src/auth/jwt.ts">/**
 * Authentication utilities for JWT handling
 *
 * Most of the auth handling is managed in the `authMiddleware` in lib-platform/src/jwt.ts
 * that middleare will extract the TokenContext and attach it to `ctx.auth`
 *
 * Here&apos;s a simple wrapper that API route handlers can use to access that info safely, or
 * raise a 401 in case that info is not present
 */
⋮----
import type { BaseContext, TokenContext } from &quot;@anterior/lib-platform/app&quot;;
import { HTTPException } from &quot;@anterior/lib-platform/app&quot;;
⋮----
export const parseAuthInfo = (ctx: BaseContext): TokenContext =&gt;</file><file path="gateways/noggin/src/chat/orchestrator/tools/mnr.ts">import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import type { Messages } from &quot;@anthropic-ai/sdk/resources/messages&quot;;
import type { Platform } from &quot;../../platform.ts&quot;;
⋮----
export interface MnrToolInput {
	clinicals_uri: string;
	guideline_uri: string;
	requested_service_description?: string;
	indication_description?: string;
	cpt_code?: string;
	icd_10_code?: string;
	hcpcs_code?: string;
}
⋮----
export class MnrTool
⋮----
constructor(logger: Logger, platform: Platform)
⋮----
getToolDefinition(): Messages.Tool
⋮----
async execute(input: MnrToolInput): Promise&lt;string&gt;</file><file path="gateways/noggin/src/chat/orchestrator/index.ts"></file><file path="gateways/noggin/src/chat/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import config from &quot;@anterior/lib-infra/config&quot;;
import { S3Bucket } from &quot;@anterior/lib-infra/s3&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;
⋮----
// todo:
// set filepaths for relevant stem/chat storage
⋮----
/**
 * Platform configuration for the chat application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for chat data and file uploads
 */</file><file path="gateways/noggin/src/chat/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import { InMemoryBlobStoreBackend } from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
// NB: for when we want to store chats similar to how we store
// pdfs and notes within noggin/src/notes (formerly llms)
// @ajit we&apos;ll likely want to store everything flopilot related
// in the same place within the same stem
//
// every new &quot;chat&quot; could comprise a new stem...we may have
// different types of stems over time, starting with &quot;chat&quot;
// the various elements of the chat: input pdfs, chat history,
// artifacts, the workflows that create them, could be stored
// as part of that stem
//
// note that we do not have any events for any of the noggin
// implementations yet...that&apos;s to come
⋮----
export interface Infra {
	logger: Logger;
	blobs: BlobStoreBackend;
}
⋮----
export function getInMemoryInfra(): Infra
⋮----
export interface Stores {
	readonly blobs: BlobStore;
}
⋮----
export class Platform
⋮----
public static inMemory(infra: Partial&lt;Infra&gt; =
⋮----
public static fromInfra(infra: Infra): Platform
⋮----
constructor(public readonly stores: Stores)
⋮----
get blobs(): BlobStore</file><file path="gateways/noggin/src/flonotes/test-e2e/flonotes.spec.ts">import test, { expect } from &quot;@playwright/test&quot;;
⋮----
/**
 * E2E Tests for Flonotes Noggin Application
 *
 * These tests validate the authentication flow and API functionality of the Flonotes Noggin app.
 */
⋮----
// Attempt to access API without authentication
⋮----
redirect: &quot;manual&quot;, // Don&apos;t follow redirects automatically
⋮----
// Should redirect to login
⋮----
// Validate redirect URL
⋮----
// TODO: Verify it includes the redirectTo parameter</file><file path="gateways/noggin/src/flonotes/app.ts">import {
	App,
	createStaticApp,
	type AppOptions,
	type EndpointSignature,
} from &quot;@anterior/lib-platform/app&quot;;
import { KeyMissingError } from &quot;@anterior/lib-platform/errors&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import type { ExecutionContext } from &quot;hono&quot;;
import { flonotesFeBlobs } from &quot;./infra.ts&quot;;
⋮----
import type { Platform } from &quot;./platform.ts&quot;;
⋮----
export interface FlonotesAppContext {
	logger: Logger;
	platform: Platform;
}
⋮----
export interface FlonotesAppService {
	GET: {
		&quot;/&quot;: EndpointSignature&lt;{}, object&gt;;
	};
}
⋮----
export type FlonotesApp = App&lt;FlonotesAppService, FlonotesAppContext&gt;;
⋮----
export function createFlonotesApp(baseCtx: FlonotesAppContext, options: AppOptions): FlonotesApp
⋮----
// serves static files from s3, including assets
// see createStaticApp for more details, in lib/ts/lib-platform/app.ts
⋮----
// serve static files from s3 by default</file><file path="gateways/noggin/src/flonotes/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import config from &quot;@anterior/lib-infra/config&quot;;
import { S3Bucket } from &quot;@anterior/lib-infra/s3&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;
⋮----
// DANGER! do not change this path, or risk overwriting
// production S3 data in other paths. We need to overhaul
// our bucket policy to restrict bucket path access to
// certain roles to prevent accidental deletion.
//
// NB: this is only used to pull the frontend app from s3
// and serve it to the user from noggin
⋮----
/**
 * Platform configuration for the Flonotes application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for note payloads and metadata
 * - Flows: LLM-based note generation pipeline
 *
 * Each service is configured with specific settings for the Flonotes
 * use case, ensuring proper isolation and resource management.
 */</file><file path="gateways/noggin/src/flonotes/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import { InMemoryBlobStoreBackend } from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
/**
 * Infrastructure interface defining the external resources needed by the platform.
 *
 * The platform can be deployed in different environments:
 * - Production: Resources managed by CDK/Terraform
 * - Docker/CI: Resources managed by Docker Compose
 * - Local/Testing: Resources represented by in-memory implementations
 *
 * This abstraction allows for environment-specific implementations
 * while maintaining a consistent interface for the application.
 */
export interface Infra {
	logger: Logger;
	blobs: BlobStoreBackend;
}
⋮----
/**
 * Creates an in-memory implementation of the infrastructure.
 *
 * This is not meant for production use! The in-memory implementation
 * is useful for:
 * - Unit testing: Fast, isolated test environment
 * - Local development: Quick setup without external dependencies
 *
 * Note that all data is lost when the process exits.
 */
export function getInMemoryInfra(): Infra
⋮----
/**
 * Application layer interface to the resource backends.
 *
 * This interface provides type-safe access to:
 * - Blob storage: For storing note payloads and metadata
 *
 * The interface ensures that all platform operations are properly
 * typed and validated against their schemas.
 */
export interface Stores {
	readonly blobs: BlobStore;
}
⋮----
/**
 * Core platform implementation for the Flonotes application.
 *
 * The platform provides:
 * 1. Factory methods for creating platform instances
 * 2. Type-safe access to storage and flow services
 * 3. Environment-specific resource management
 */
export class Platform
⋮----
/**
	 * Creates an in-memory platform instance for testing.
	 *
	 * This method allows for partial infrastructure overrides,
	 * making it easy to mock specific components while using
	 * real implementations for others.
	 */
public static inMemory(infra: Partial&lt;Infra&gt; =
⋮----
/**
	 * Creates a platform instance from infrastructure configuration.
	 *
	 * This method:
	 * 1. Sets up the message queue for flow scheduling
	 * 2. Initializes blob storage for note data
	 * 3. Configures proper serialization and validation
	 */
public static fromInfra(infra: Infra): Platform
⋮----
constructor(public readonly stores: Stores)
⋮----
/**
	 * Type-safe access to the blob storage service.
	 * Used for storing and retrieving note data.
	 */
get blobs(): BlobStore</file><file path="gateways/noggin/src/flopilot/app.ts">import {
	App,
	createStaticApp,
	type AppOptions,
	type EndpointSignature,
} from &quot;@anterior/lib-platform/app&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import { flopilotFeBlobs } from &quot;./infra.ts&quot;;
import type { Platform } from &quot;./platform.ts&quot;;
⋮----
export interface FlopilotAppContext {
	logger: Logger;
	platform: Platform;
}
⋮----
export interface FlopilotAppService {
	GET: {
		&quot;/&quot;: EndpointSignature&lt;{}, object&gt;;
	};
}
⋮----
export type FlopilotApp = App&lt;FlopilotAppService, FlopilotAppContext&gt;;
⋮----
export function createFlopilotApp(baseCtx: FlopilotAppContext, options: AppOptions): FlopilotApp
⋮----
// serves static files from s3, including assets
// see createStaticApp for more details, in lib/ts/lib-platform/app.ts
⋮----
// 🚨 Using `hono` outside `lib-platform` is a smell!</file><file path="gateways/noggin/src/flopilot/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import config from &quot;@anterior/lib-infra/config&quot;;
import { S3Bucket } from &quot;@anterior/lib-infra/s3&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;
⋮----
// 🚨 DANGER! do not change this path, or risk overwriting
// production S3 data in other paths. We need to overhaul
// our bucket policy to restrict bucket path access to
// certain roles to prevent accidental deletion.
//
// NB: this is only used to pull the frontend app from s3
// and serve it to the user from noggin
⋮----
/**
 * Platform configuration for the Flopilot application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for note payloads and metadata
 * - Flows: LLM-based note generation pipeline
 *
 * Each service is configured with specific settings for the Flopilot
 * use case, ensuring proper isolation and resource management.
 */</file><file path="gateways/noggin/src/flopilot/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import { InMemoryBlobStoreBackend } from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
/**
 * Infrastructure interface defining the external resources needed by the platform.
 *
 * The platform can be deployed in different environments:
 * - Production: Resources managed by CDK/Terraform
 * - Docker/CI: Resources managed by Docker Compose
 * - Local/Testing: Resources represented by in-memory implementations
 *
 * This abstraction allows for environment-specific implementations
 * while maintaining a consistent interface for the application.
 */
export interface Infra {
	logger: Logger;
	blobs: BlobStoreBackend;
}
⋮----
/**
 * Creates an in-memory implementation of the infrastructure.
 *
 * This is not meant for production use! The in-memory implementation
 * is useful for:
 * - Unit testing: Fast, isolated test environment
 * - Local development: Quick setup without external dependencies
 *
 * Note that all data is lost when the process exits.
 */
export function getInMemoryInfra(): Infra
⋮----
/**
 * Application layer interface to the resource backends.
 *
 * This interface provides type-safe access to:
 * - Blob storage: For storing note payloads and metadata
 *
 * The interface ensures that all platform operations are properly
 * typed and validated against their schemas.
 */
export interface Stores {
	readonly blobs: BlobStore;
}
⋮----
/**
 * Core platform implementation for the Flopilot application.
 *
 * The platform provides:
 * 1. Factory methods for creating platform instances
 * 2. Type-safe access to storage and flow services
 * 3. Environment-specific resource management
 */
export class Platform
⋮----
/**
	 * Creates an in-memory platform instance for testing.
	 *
	 * This method allows for partial infrastructure overrides,
	 * making it easy to mock specific components while using
	 * real implementations for others.
	 */
public static inMemory(infra: Partial&lt;Infra&gt; =
⋮----
/**
	 * Creates a platform instance from infrastructure configuration.
	 *
	 * This method:
	 * 1. Sets up the message queue for flow scheduling
	 * 2. Initializes blob storage for note data
	 * 3. Configures proper serialization and validation
	 */
public static fromInfra(infra: Infra): Platform
⋮----
constructor(public readonly stores: Stores)
⋮----
/**
	 * Type-safe access to the blob storage service.
	 * Used for storing and retrieving note data.
	 */
get blobs(): BlobStore</file><file path="gateways/noggin/src/health/main.ts">import { createHealthApp } from &quot;./app.ts&quot;;</file><file path="gateways/noggin/src/hello-world/test-e2e/health.spec.ts">import test, { expect } from &quot;@playwright/test&quot;;</file><file path="gateways/noggin/src/hello-world/test-e2e/latest.spec.ts">import test, { expect } from &quot;@playwright/test&quot;;</file><file path="gateways/noggin/src/hello-world/test-integration/hello.test.ts">import { expect, test } from &quot;vitest&quot;;
import { getLatestGreetee, setLatestGreetee } from &quot;../hello.ts&quot;;</file><file path="gateways/noggin/src/hello-world/hello.test.ts">import { expect, test } from &quot;vitest&quot;;
import { getGreeting } from &quot;./hello.ts&quot;;</file><file path="gateways/noggin/src/notes/schemas/api.ts">import { clinicalSchema, noteMessageSchema } from &quot;./models.ts&quot;;
⋮----
/**
 * API-specific schemas for routing and request/response handling
 */</file><file path="gateways/noggin/src/notes/schemas/models.ts">import { z } from &quot;@anterior/lib-platform/zod&quot;;
⋮----
/**
 * Core data models used across the application
 */</file><file path="gateways/noggin/src/notes/schemas/types.ts">// TODO: as we revisit PDF processing, include proper schemas
// for the (a) PDF extracts, (b) the entire LLM response, and (c) any
// schemas we expect the LLM to generate
⋮----
import type { z } from &quot;@anterior/lib-platform/zod&quot;;
import { createNoteRequestSchema, createNoteResponseSchema, getNoteResponseSchema } from &quot;./api.ts&quot;;
import { clinicalSchema, documentSchema, noteMessageSchema } from &quot;./models.ts&quot;;
⋮----
export type ProcessingStatus = &quot;processing&quot; | &quot;ready&quot; | &quot;error&quot;;
⋮----
export type Clinical = z.infer&lt;typeof clinicalSchema&gt;;
export type Document = z.infer&lt;typeof documentSchema&gt;;
export type NoteMessage = z.infer&lt;typeof noteMessageSchema&gt;;
export type CreateNoteInput = z.infer&lt;typeof createNoteRequestSchema&gt;;
export type CreateNoteOutput = z.infer&lt;typeof createNoteResponseSchema&gt;;
export type NoteOutput = z.infer&lt;typeof getNoteResponseSchema&gt;;</file><file path="gateways/noggin/src/pdfs/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;</file><file path="gateways/noggin/src/stems/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;
⋮----
/**
 * Platform configuration for the stems application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for note payloads and metadata
 * - Flows: LLM-based note generation pipeline
 *
 * Each service is configured with specific settings for the stems
 * use case, ensuring proper isolation and resource management.
 */</file><file path="gateways/noggin/src/config.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import { getConfig } from &quot;@anterior/lib-platform/config&quot;;</file><file path="gateways/noggin/src/migrate.ts">function migrate()</file><file path="gateways/noodle/package.json">{
	&quot;name&quot;: &quot;@anterior/noodle&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;type&quot;: &quot;module&quot;,
	&quot;scripts&quot;: {
		&quot;dev&quot;: &quot;bun run --hot src/index.ts&quot;,
		&quot;start&quot;: &quot;bun run src/index.ts&quot;,
		&quot;format&quot;: &quot;prettier --plugin prettier-plugin-organize-imports --ignore-path ../../.gitignore --write .&quot;,
		&quot;build&quot;: &quot;tsc &amp;&amp; chmod +x dist/index.js dist/migrate.js&quot;,
		&quot;migrate&quot;: &quot;echo &apos;Nothing to migrate...&apos;&quot;,
		&quot;test:integration&quot;: &quot;vitest run&quot;,
		&quot;test&quot;: &quot;echo no unit tests&quot;
	},
	&quot;bin&quot;: {
		&quot;noodle&quot;: &quot;dist/index.js&quot;,
		&quot;noodle-migrate&quot;: &quot;dist/migrate.js&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/models&quot;: &quot;0.0.0&quot;,
		&quot;@anterior/openapi&quot;: &quot;0.0.0&quot;,
		&quot;@anterior/proto&quot;: &quot;0.0.0&quot;,
		&quot;@aws-sdk/client-s3&quot;: &quot;^3.637.0&quot;,
		&quot;@connectrpc/connect-node&quot;: &quot;^1.4.0&quot;,
		&quot;@faker-js/faker&quot;: &quot;^8.4.1&quot;,
		&quot;@hono/node-server&quot;: &quot;^1.14.0&quot;,
		&quot;@hono/prometheus&quot;: &quot;^1.0.1&quot;,
		&quot;@hono/trpc-server&quot;: &quot;^0.3.2&quot;,
		&quot;@hono/zod-validator&quot;: &quot;^0.2.2&quot;,
		&quot;@t3-oss/env-core&quot;: &quot;^0.11.0&quot;,
		&quot;@trpc/server&quot;: &quot;11.0.2&quot;,
		&quot;case-anything&quot;: &quot;^3.1.0&quot;,
		&quot;date-fns&quot;: &quot;^3.6.0&quot;,
		&quot;hono&quot;: &quot;^4.5.5&quot;,
		&quot;hono-pino&quot;: &quot;^0.1.1&quot;,
		&quot;hot-shots&quot;: &quot;^10.1.0&quot;,
		&quot;is-what&quot;: &quot;^5.0.2&quot;,
		&quot;nice-grpc&quot;: &quot;^2.1.9&quot;,
		&quot;pino&quot;: &quot;^9.3.2&quot;,
		&quot;pino-pretty&quot;: &quot;^11.2.2&quot;,
		&quot;prom-client&quot;: &quot;^15.1.3&quot;,
		&quot;superjson&quot;: &quot;^2.2.1&quot;,
		&quot;zod&quot;: &quot;^3.24.2&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@types/eslint&quot;: &quot;^9.6.0&quot;,
		&quot;@types/eslint__js&quot;: &quot;^8.42.3&quot;,
		&quot;@types/eslint-config-prettier&quot;: &quot;^6.11.3&quot;,
		&quot;eslint&quot;: &quot;^9.9.0&quot;,
		&quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;,
		&quot;typescript&quot;: &quot;^5.5.4&quot;,
		&quot;vite-tsconfig-paths&quot;: &quot;^5.0.1&quot;,
		&quot;vitest&quot;: &quot;^2.0.5&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;@trpc/server&quot;: &quot;11.0.2&quot;
	}
}</file><file path="gateways/noodle/tsconfig.json">{
	&quot;extends&quot;: &quot;../../tsconfig.json&quot;, // Root level tsconfig.json
	&quot;include&quot;: [&quot;src/**/*&quot;],
	&quot;compilerOptions&quot;: {
		&quot;noEmit&quot;: false,
		&quot;rewriteRelativeImportExtensions&quot;: true,
		&quot;outDir&quot;: &quot;dist&quot;
	}
}</file><file path="infra/cdktf/tsconfig.json">{
	&quot;compilerOptions&quot;: {
		&quot;alwaysStrict&quot;: true,
		&quot;declaration&quot;: true,
		&quot;experimentalDecorators&quot;: true,
		&quot;inlineSourceMap&quot;: true,
		&quot;inlineSources&quot;: true,
		&quot;lib&quot;: [&quot;es2018&quot;],
		&quot;module&quot;: &quot;CommonJS&quot;,
		&quot;noEmitOnError&quot;: true,
		&quot;noFallthroughCasesInSwitch&quot;: true,
		&quot;noImplicitAny&quot;: true,
		&quot;noImplicitReturns&quot;: true,
		&quot;noImplicitThis&quot;: true,
		&quot;noUnusedLocals&quot;: true,
		&quot;noUnusedParameters&quot;: true,
		&quot;outDir&quot;: &quot;./dist&quot;,
		&quot;resolveJsonModule&quot;: true,
		&quot;strict&quot;: true,
		&quot;strictNullChecks&quot;: true,
		&quot;strictPropertyInitialization&quot;: true,
		&quot;stripInternal&quot;: true,
		&quot;target&quot;: &quot;ES2018&quot;,
		&quot;incremental&quot;: true,
		&quot;skipLibCheck&quot;: true
	},
	&quot;include&quot;: [&quot;**/*.ts&quot;],
	&quot;exclude&quot;: [&quot;node_modules&quot;, &quot;cdktf.out&quot;, &quot;dist&quot;]
}</file><file path="lib/ts/lib-infra/tsconfig.json">{
	&quot;extends&quot;: &quot;../../../tsconfig.json&quot;,
	&quot;include&quot;: [&quot;src/**/*&quot;],
	&quot;compilerOptions&quot;: {
		&quot;strictNullChecks&quot;: true,
		&quot;allowUnusedLabels&quot;: false,
		&quot;allowUnreachableCode&quot;: false,
		&quot;experimentalDecorators&quot;: true,
		&quot;emitDecoratorMetadata&quot;: true,
		&quot;noEmit&quot;: false,
		&quot;rewriteRelativeImportExtensions&quot;: true,
		&quot;outDir&quot;: &quot;./dist&quot;,

		&quot;rootDir&quot;: &quot;./src&quot;,
		&quot;declarationDir&quot;: &quot;./dist&quot;,
		&quot;tsBuildInfoFile&quot;: &quot;./dist/tsconfig.tsbuildinfo&quot;,
		&quot;declaration&quot;: true,
		&quot;composite&quot;: true,
		&quot;sourceMap&quot;: true,
		&quot;declarationMap&quot;: true
	}
}</file><file path="lib/ts/lib-platform/src/async.ts">export async function sleep(seconds: number)
⋮----
export async function poll&lt;T&gt;(args: {
	intervalMs: number;
	timeoutMs: number;
fn: ()
⋮----
// pass
⋮----
const clear = () =&gt;</file><file path="lib/ts/lib-platform/src/auth.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
import { AuthorizationError, authorize } from &quot;./auth.ts&quot;;
import type { RequestVars } from &quot;./types.ts&quot;;
⋮----
const ALLOW = ()
const DENY = ()</file><file path="lib/ts/lib-platform/src/auth.ts">import { PublicError } from &quot;./errors.ts&quot;;
⋮----
export class AuthorizationError extends PublicError
⋮----
constructor()
⋮----
export interface Permission&lt;TVars&gt; {
	(ctx: TVars): boolean;
}
⋮----
// TODO should we validate the context here?
export function authorize&lt;TVars&gt;(context: TVars, permissions?: Permission&lt;TVars&gt;[])</file><file path="lib/ts/lib-platform/src/body.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
import { extractBody, extractBodyFormData } from &quot;./body.ts&quot;;
import { ConflictingArrayKeyError, IncorrectScalarKeyError, ParseError } from &quot;./errors.ts&quot;;</file><file path="lib/ts/lib-platform/src/config.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
import { getConfig, getFlags } from &quot;./config.ts&quot;;</file><file path="lib/ts/lib-platform/src/cors.ts"></file><file path="lib/ts/lib-platform/src/in-memory.test.ts">import { describe } from &quot;vitest&quot;;
import { asAssocStoreBackend } from &quot;./assoc.contract.ts&quot;;
import { asBlobStoreBackend } from &quot;./blob.contract.ts&quot;;
import { asEventStoreBackend } from &quot;./events.contract.ts&quot;;
import {
	InMemoryAssocStoreBackend,
	InMemoryBlobStoreBackend,
	InMemoryEventStoreBackend,
	InMemoryKVStoreBackend,
} from &quot;./in-memory.ts&quot;;
import { asKVStoreBackend } from &quot;./kv.contract.ts&quot;;</file><file path="lib/ts/lib-platform/src/invariant.test.ts">import { describe, expect, it } from &quot;vitest&quot;;
import invariant from &quot;./invariant.ts&quot;;</file><file path="lib/ts/lib-platform/src/kv.contract.ts">import { beforeAll, describe, expect, test } from &quot;./test.ts&quot;;
⋮----
import { generateRandomId } from &quot;./ids.ts&quot;;
import type { KVStoreBackend } from &quot;./kv.ts&quot;;
⋮----
export function asKVStoreBackend(kv: KVStoreBackend, beforeHandler?: () =&gt; Promise&lt;void&gt;)</file><file path="lib/ts/lib-platform/src/kv.test.ts">import { beforeEach, describe, expect, test } from &quot;vitest&quot;;
import { z } from &quot;zod&quot;;
import { KeyMissingError, ParseError, SerializerError, Timeout } from &quot;./errors.ts&quot;;
import { generateRandomId } from &quot;./ids.ts&quot;;
import { InMemoryKVStoreBackend, InMemoryLogger } from &quot;./in-memory.ts&quot;;
import { asKVStoreBackend } from &quot;./kv.contract.ts&quot;;
import { KVStore } from &quot;./kv.ts&quot;;
⋮----
import { neverSchema, type Schema, toSchema } from &quot;./schema.ts&quot;;
import { neverSerializer, typedIdentitySerializer } from &quot;./serializer.ts&quot;;
⋮----
interface KVType {
	readonly value: string;
}</file><file path="lib/ts/lib-platform/src/log.ts">import pino from &quot;pino&quot;;
⋮----
/**
 * The logger is not an actual service, but a standardised way to print to stdout.
 * The service containers ingest these logs and forward them to the appropriate log management system.
 *
 * Please add loggers everywhere, including children on class instances to add additional context
 */
⋮----
export type Logger = typeof logger;
⋮----
export function Logger&lt;T extends Record&lt;string, any&gt;&gt;(ctx: T): pino.Logger
⋮----
export type LogLevel = &quot;trace&quot; | &quot;debug&quot; | &quot;info&quot; | &quot;warn&quot; | &quot;error&quot; | &quot;fatal&quot;;</file><file path="lib/ts/lib-platform/src/object.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
⋮----
import {
	camelCase,
	fromEach,
	only,
	recursiveCamelCase,
	recursiveSnakeCase,
	snakeCase,
} from &quot;./object.ts&quot;;</file><file path="lib/ts/lib-platform/src/schema.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
import { z } from &quot;zod&quot;;
import { ParseError } from &quot;./errors.ts&quot;;
import { toCreator, toParser, toUnionSchema, type UnionSchemaDefinition } from &quot;./schema.ts&quot;;
⋮----
interface A {
	readonly type: &quot;a&quot;;
	readonly foo: number;
}
⋮----
interface B {
	readonly type: &quot;b&quot;;
	readonly bar: number;
}
⋮----
interface C {
	readonly type: &quot;c&quot;;
	readonly zoop: number;
}
⋮----
type TestUnion = A | B | C;
⋮----
// @ts-expect-error
⋮----
// @ts-expect-error</file><file path="lib/ts/lib-platform/src/secrets.ts">/**
 * Current implementation uses env vars, but this should be replaced with a proper secret manager using files.
 */
export class Secret
⋮----
constructor(private readonly _value: string)
⋮----
getValue()
toString()
⋮----
export function getSecrets&lt;K extends string&gt;(keys: K[]):
⋮----
// TODO proper errors or use zod or something off the shelf</file><file path="lib/ts/lib-platform/src/test.ts">import { DeliberatelyUnimplementedError } from &quot;./errors.ts&quot;;
⋮----
export function test(label: string, fn: vitest.TestFunction)</file><file path="lib/ts/lib-platform/src/types.ts">// This path type is most likely a placeholder
export type Path = &quot;/&quot; | `/${string}`;
⋮----
/**
 * Describes the context variables which are required/guaranteed by the platform.
 *
 * Used for several purposes, like:
 * - Logging
 * - Storing events
 * - Starting workflows
 */
export interface RequestVars {
	traceId: string;
	idempotencyKey: string;
}
⋮----
/**
 * A single way to describe simple objects that can be json serialized
 */
export type POJO = Record&lt;string, unknown&gt;; // TODO decide on how we want to type this
⋮----
// Parsers turn unknown into typed data, and throw if the input is invalid
export type Parser&lt;T&gt; =
	// Matches Zod objects
	{ parse(input: unknown): T };
⋮----
// Matches Zod objects

⋮----
// By GPT:
/**
 * This helper type takes a union and returns a tuple that contains each type exactly once.
 */
type UnionToIntersection&lt;U&gt; = (U extends any ? (x: U) =&gt; void : never) extends (x: infer R) =&gt; void
	? R
	: never;
type LastInUnion&lt;U&gt; =
	UnionToIntersection&lt;U extends any ? (x: U) =&gt; void : never&gt; extends (x: infer L) =&gt; void
		? L
		: never;
export type TupleOfUnion&lt;U, T extends any[] = []&gt; = [U] extends [never]
	? T
	: TupleOfUnion&lt;Exclude&lt;U, LastInUnion&lt;U&gt;&gt;, [LastInUnion&lt;U&gt;, ...T]&gt;;
⋮----
// Inline validation of the type
type MyUnion = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;;
type MyTuple = TupleOfUnion&lt;MyUnion&gt;;
⋮----
// @ts-expect-error - missing &apos;c&apos;
⋮----
// @ts-expect-error - out of order
⋮----
export type Pagination&lt;T&gt; = {
	items: T[];
	count: number;
	cursor?: string;
};
⋮----
// &apos;forward&apos; indicates chronological order, moving from past to future
// SQL equivalent: ORDER BY timestamp ASC
export type SortDirection = &quot;forward&quot; | &quot;backward&quot;;</file><file path="lib/ts/lib-platform/src/utils.ts">export function delay(milliseconds: number)</file><file path="lib/ts/lib-platform/src/worker.ts">import { Logger } from &quot;./log.ts&quot;;
import { delay } from &quot;./utils.ts&quot;;
⋮----
/**
 * A worker is a long-running process that performs some kind of work in Noggin
 * that is NOT part of the request/response lifecycle. Such as, pushing items to
 * a queue, processing background jobs, handling asynchronous task, or
 * performing computations (eg. creating Projections).
 *
 * Defaults to running forever with 5000 msBetweenPolls.
 *
 */
export class Worker
⋮----
constructor(logger: Logger)
⋮----
/**
	 * This method is intended to be overridden in a subclass.
	 * It is called when the worker object is instantiated.
	 * It should be used to do any initialization before the worker starts running.
	 */
public async init(): Promise&lt;void&gt;
⋮----
/**
	 * This method is intended to be overridden in a subclass.
	 * It is called when the worker is shutting down.
	 * It should be used to do any clean up before the process exits.
	 */
public async exit(): Promise&lt;void&gt;
⋮----
/**
	 * This method is intended to be overridden in a subclass.
	 * It contains the main logic of the worker.
	 */
public async run(): Promise&lt;void&gt;
⋮----
/**
	 * This method sets up signal handlers for SIGINT and SIGTERM so that the worker
	 * can shutdown gracefully.
	 */
private setupSignalHandlers()
⋮----
/**
	 * This method starts the worker.
	 * If runOnce is true, the worker will run once, then die (useful for one off tasks).
	 */
public async start(runOnce: boolean = false): Promise&lt;void&gt;
⋮----
// breaks while loop after the first run
// ensuring the worker runs once
⋮----
protected NotImplementedError(methodName: string): never</file><file path="lib/ts/lib-platform/src/zod.ts"></file><file path="lib/ts/lib-platform/tsconfig.json">{
	&quot;extends&quot;: &quot;../../../tsconfig.json&quot;,
	&quot;include&quot;: [&quot;src/**/*&quot;],
	&quot;compilerOptions&quot;: {
		&quot;strictNullChecks&quot;: true,
		&quot;allowUnusedLabels&quot;: false,
		&quot;allowUnreachableCode&quot;: false,
		&quot;experimentalDecorators&quot;: true,
		&quot;emitDecoratorMetadata&quot;: true,
		&quot;noEmit&quot;: false,
		&quot;rewriteRelativeImportExtensions&quot;: true,
		&quot;outDir&quot;: &quot;dist&quot;,
		&quot;rootDir&quot;: &quot;./src&quot;,
		&quot;declarationDir&quot;: &quot;./dist&quot;,
		&quot;tsBuildInfoFile&quot;: &quot;./dist/tsconfig.tsbuildinfo&quot;,
		&quot;declaration&quot;: true,
		&quot;composite&quot;: true,
		&quot;sourceMap&quot;: true,
		&quot;declarationMap&quot;: true
	}
}</file><file path="surfaces/cortex/package.json">{
	&quot;name&quot;: &quot;@anterior/cortex&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;type&quot;: &quot;module&quot;,
	&quot;scripts&quot;: {
		&quot;dev&quot;: &quot;next dev&quot;,
		&quot;build&quot;: &quot;next build&quot;,
		&quot;lint&quot;: &quot;next lint&quot;,
		&quot;format&quot;: &quot;prettier --plugin prettier-plugin-organize-imports --plugin prettier-plugin-tailwindcss --ignore-path ../../.gitignore --write .&quot;,
		&quot;test:e2e&quot;: &quot;playwright test&quot;,
		&quot;test&quot;: &quot;vitest run&quot;,
		&quot;test:unit:watch&quot;: &quot;vitest watch&quot;,
		&quot;clean&quot;: &quot;rm -rf node_modules &amp;&amp; rm package-lock.json &amp;&amp; npm install&quot;
	},
	&quot;bin&quot;: {
		&quot;cortex&quot;: &quot;start.sh&quot;,
		&quot;cortex-migrate&quot;: &quot;migrate.sh&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/openapi&quot;: &quot;0.0.0&quot;,
		&quot;@anterior/neuron&quot;: &quot;0.0.0&quot;,
		&quot;@anterior/noodle&quot;: &quot;0.0.0&quot;,
		&quot;@codemirror/lang-json&quot;: &quot;^6.0.1&quot;,
		&quot;@headlessui/react&quot;: &quot;^2.0.4&quot;,
		&quot;@heroicons/react&quot;: &quot;^2.0.18&quot;,
		&quot;@hookform/resolvers&quot;: &quot;^3.3.4&quot;,
		&quot;@radix-ui/react-accordion&quot;: &quot;^1.2.0&quot;,
		&quot;@radix-ui/react-avatar&quot;: &quot;^1.1.0&quot;,
		&quot;@radix-ui/react-checkbox&quot;: &quot;^1.1.1&quot;,
		&quot;@radix-ui/react-collapsible&quot;: &quot;^1.1.3&quot;,
		&quot;@radix-ui/react-dropdown-menu&quot;: &quot;^2.1.1&quot;,
		&quot;@radix-ui/react-icons&quot;: &quot;^1.3.0&quot;,
		&quot;@radix-ui/react-label&quot;: &quot;^2.1.0&quot;,
		&quot;@radix-ui/react-popover&quot;: &quot;^1.1.1&quot;,
		&quot;@radix-ui/react-radio-group&quot;: &quot;^1.2.0&quot;,
		&quot;@radix-ui/react-select&quot;: &quot;^2.1.1&quot;,
		&quot;@radix-ui/react-tabs&quot;: &quot;^1.1.0&quot;,
		&quot;@radix-ui/react-tooltip&quot;: &quot;^1.1.2&quot;,
		&quot;@react-email/components&quot;: &quot;^0.0.19&quot;,
		&quot;@react-email/render&quot;: &quot;^0.0.15&quot;,
		&quot;@rive-app/react-canvas-lite&quot;: &quot;^4.14.5&quot;,
		&quot;@sentry/nextjs&quot;: &quot;^7.107.0&quot;,
		&quot;@t3-oss/env-nextjs&quot;: &quot;^0.9.2&quot;,
		&quot;@tailwindcss/container-queries&quot;: &quot;^0.1.1&quot;,
		&quot;@tanstack/react-query&quot;: &quot;^5.44.4&quot;,
		&quot;@trpc/client&quot;: &quot;^11.0.0-rc.477&quot;,
		&quot;@trpc/react-query&quot;: &quot;*&quot;,
		&quot;@trpc/server&quot;: &quot;*&quot;,
		&quot;@types/howler&quot;: &quot;^2.2.11&quot;,
		&quot;@uiw/react-codemirror&quot;: &quot;^4.23.6&quot;,
		&quot;@wojtekmaj/react-hooks&quot;: &quot;^1.18.1&quot;,
		&quot;ai&quot;: &quot;^2.2.37&quot;,
		&quot;axios&quot;: &quot;^1.7.4&quot;,
		&quot;canvas&quot;: &quot;^2.11.2&quot;,
		&quot;case-anything&quot;: &quot;^3.1.0&quot;,
		&quot;class-variance-authority&quot;: &quot;^0.7.0&quot;,
		&quot;classnames&quot;: &quot;^2.3.2&quot;,
		&quot;cmdk&quot;: &quot;^1.0.0&quot;,
		&quot;codemirror&quot;: &quot;^6.0.1&quot;,
		&quot;cookies-next&quot;: &quot;^4.2.1&quot;,
		&quot;fastest-levenshtein&quot;: &quot;^1.0.16&quot;,
		&quot;framer-motion&quot;: &quot;^10.18.0&quot;,
		&quot;immer&quot;: &quot;^10.1.1&quot;,
		&quot;is-what&quot;: &quot;^5.0.2&quot;,
		&quot;jiti&quot;: &quot;^1.21.0&quot;,
		&quot;jwt-decode&quot;: &quot;^4.0.0&quot;,
		&quot;langfuse&quot;: &quot;^3.3.1&quot;,
		&quot;lottie-react&quot;: &quot;^2.4.0&quot;,
		&quot;mammoth&quot;: &quot;^1.5.1&quot;,
		&quot;next&quot;: &quot;^14.2.2&quot;,
		&quot;next-runtime-env&quot;: &quot;^3.2.2&quot;,
		&quot;node-gyp&quot;: &quot;^10.2.0&quot;,
		&quot;nuqs&quot;: &quot;^1.16.1&quot;,
		&quot;openai&quot;: &quot;^4.28.0&quot;,
		&quot;posthog-js&quot;: &quot;^1.139.1&quot;,
		&quot;react&quot;: &quot;=18.3.1&quot;,
		&quot;react-aria&quot;: &quot;^3.34.3&quot;,
		&quot;react-aria-components&quot;: &quot;^1.3.3&quot;,
		&quot;react-day-picker&quot;: &quot;^8.10.1&quot;,
		&quot;react-dom&quot;: &quot;=18.3.1&quot;,
		&quot;react-dropzone&quot;: &quot;^14.2.3&quot;,
		&quot;react-email&quot;: &quot;^2.0.0&quot;,
		&quot;react-hook-form&quot;: &quot;^7.50.1&quot;,
		&quot;react-hot-toast&quot;: &quot;^2.4.1&quot;,
		&quot;react-icons&quot;: &quot;^4.10.1&quot;,
		&quot;react-markdown&quot;: &quot;^9.0.1&quot;,
		&quot;react-pdf&quot;: &quot;^7.7.0&quot;,
		&quot;react-pdf-highlighter&quot;: &quot;^6.1.0&quot;,
		&quot;react-resize-detector&quot;: &quot;^10.0.1&quot;,
		&quot;react-textarea-autosize&quot;: &quot;^8.5.3&quot;,
		&quot;react-use-measure&quot;: &quot;^2.1.1&quot;,
		&quot;recharts&quot;: &quot;^2.12.7&quot;,
		&quot;remark-breaks&quot;: &quot;^4.0.0&quot;,
		&quot;server-only&quot;: &quot;^0.0.1&quot;,
		&quot;sharp&quot;: &quot;^0.33.2&quot;,
		&quot;sonner&quot;: &quot;^1.5.0&quot;,
		&quot;superjson&quot;: &quot;^2.2.1&quot;,
		&quot;tailwind-merge&quot;: &quot;^2.5.2&quot;,
		&quot;tailwind-variants&quot;: &quot;^0.2.1&quot;,
		&quot;tailwindcss&quot;: &quot;^3.4.10&quot;,
		&quot;tailwindcss-animate&quot;: &quot;^1.0.7&quot;,
		&quot;tiny-relative-date&quot;: &quot;^1.3.0&quot;,
		&quot;use-sound&quot;: &quot;^4.0.1&quot;,
		&quot;usehooks-ts&quot;: &quot;^2.9.1&quot;,
		&quot;uuid&quot;: &quot;^10.0.0&quot;,
		&quot;zod&quot;: &quot;^3.24.2&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@hookform/devtools&quot;: &quot;^4.3.1&quot;,
		&quot;@tailwindcss/typography&quot;: &quot;^0.5.14&quot;,
		&quot;@tanstack/eslint-plugin-query&quot;: &quot;^5.52.0&quot;,
		&quot;@tanstack/react-query-devtools&quot;: &quot;^5.55.4&quot;,
		&quot;@testing-library/dom&quot;: &quot;^10.4.0&quot;,
		&quot;@testing-library/react&quot;: &quot;^16.0.0&quot;,
		&quot;@types/jsonwebtoken&quot;: &quot;^9.0.2&quot;,
		&quot;@types/node&quot;: &quot;^22.3.0&quot;,
		&quot;@types/react&quot;: &quot;=18.3.1&quot;,
		&quot;@types/react-dom&quot;: &quot;=18.3.1&quot;,
		&quot;@types/uuid&quot;: &quot;^10.0.0&quot;,
		&quot;@typescript-eslint/eslint-plugin&quot;: &quot;^7.13.1&quot;,
		&quot;autoprefixer&quot;: &quot;10.4.14&quot;,
		&quot;eslint&quot;: &quot;^8.57.0&quot;,
		&quot;eslint-config-next&quot;: &quot;14.2.4&quot;,
		&quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,
		&quot;happy-dom&quot;: &quot;^14.12.3&quot;,
		&quot;postcss&quot;: &quot;^8.4.41&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;,
		&quot;prettier-plugin-tailwindcss&quot;: &quot;^0.6.6&quot;,
		&quot;typescript&quot;: &quot;^5.5.4&quot;,
		&quot;vite-tsconfig-paths&quot;: &quot;^5.0.1&quot;,
		&quot;vitest&quot;: &quot;^2.0.5&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;@trpc/server&quot;: &quot;11.0.2&quot;
	}
}</file><file path="surfaces/cortex/tsconfig.json">{
	&quot;extends&quot;: &quot;../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		&quot;incremental&quot;: true,
		// Turning off for now
		&quot;noUncheckedIndexedAccess&quot;: false,
		&quot;verbatimModuleSyntax&quot;: false,
		&quot;exactOptionalPropertyTypes&quot;: false,
		&quot;noImplicitReturns&quot;: false,

		// The code is for frontend and runs in the DOM
		&quot;lib&quot;: [&quot;ES2023&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
		&quot;jsx&quot;: &quot;preserve&quot;,

		// Misc
		&quot;paths&quot;: {
			&quot;@/*&quot;: [&quot;./src/*&quot;],
			&quot;@/public/*&quot;: [&quot;./public/*&quot;],
			&quot;use-sound&quot;: [&quot;./src/generated-types/&quot;],
			&quot;@/iq-demo/*&quot;: [&quot;./src/app/demos/iq-demo/*&quot;]
		},
		&quot;plugins&quot;: [
			{
				&quot;name&quot;: &quot;next&quot;
			}
		],
		&quot;typeRoots&quot;: [&quot;./src/types/**&quot;]
	},
	&quot;include&quot;: [
		&quot;./next-env.d.ts&quot;,
		&quot;src/**/*.ts&quot;,
		&quot;src/**/*.tsx&quot;,
		&quot;.next/types/**/*.ts&quot;,
		&quot;sentry.client.config.ts&quot;,
		&quot;sentry.edge.config.ts&quot;,
		&quot;sentry.server.config.ts&quot;
	],
	&quot;exclude&quot;: [&quot;node_modules&quot;]
}</file><file path="surfaces/neuron/src/docs/package.json">{
	&quot;name&quot;: &quot;docs&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;type&quot;: &quot;module&quot;,
	&quot;scripts&quot;: {
		&quot;typecheck&quot;: &quot;tsc --noEmit&quot;,
		&quot;dev&quot;: &quot;vite --port=3001&quot;,
		&quot;build&quot;: &quot;vite build&quot;,
		&quot;serve&quot;: &quot;vite preview&quot;,
		&quot;start&quot;: &quot;vite&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@tanstack/router-plugin&quot;: &quot;^1.58.12&quot;,
		&quot;@types/react&quot;: &quot;^18.3.3&quot;,
		&quot;@types/react-dom&quot;: &quot;^18.3.0&quot;,
		&quot;@vitejs/plugin-react&quot;: &quot;^4.3.1&quot;,
		&quot;autoprefixer&quot;: &quot;^10.4.20&quot;,
		&quot;postcss&quot;: &quot;^8.4.47&quot;,
		&quot;tailwindcss&quot;: &quot;^3.4.13&quot;,
		&quot;vite&quot;: &quot;^5.4.4&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@tanstack/react-router&quot;: &quot;^1.58.15&quot;,
		&quot;@tanstack/router-devtools&quot;: &quot;^1.58.15&quot;,
		&quot;react&quot;: &quot;^18.3.1&quot;,
		&quot;react-dom&quot;: &quot;^18.3.1&quot;
	}
}</file><file path="surfaces/neuron/src/docs/tsconfig.json">{
	&quot;extends&quot;: &quot;../../../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		&quot;lib&quot;: [&quot;ES2023&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
		&quot;jsx&quot;: &quot;preserve&quot;
	}
}</file><file path="surfaces/neuron/package.json">{
	&quot;name&quot;: &quot;@anterior/neuron&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;main&quot;: &quot;dist/index.js&quot;,
	&quot;module&quot;: &quot;dist/index.js&quot;,
	&quot;types&quot;: &quot;dist/index.d.ts&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;exports&quot;: {
		&quot;.&quot;: {
			&quot;types&quot;: &quot;./dist/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/index.js&quot;,
			&quot;require&quot;: &quot;./dist/index.js&quot;
		},
		&quot;./react&quot;: {
			&quot;types&quot;: &quot;./dist/react/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/react/index.js&quot;,
			&quot;require&quot;: &quot;./dist/react/index.js&quot;
		},
		&quot;./icons&quot;: {
			&quot;types&quot;: &quot;./dist/icons/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/icons/index.js&quot;,
			&quot;require&quot;: &quot;./dist/icons/index.js&quot;
		},
		&quot;./*.css&quot;: {
			&quot;import&quot;: &quot;./dist/*.css&quot;,
			&quot;require&quot;: &quot;./dist/*.css&quot;
		},
		&quot;./tailwind.config.js&quot;: {
			&quot;import&quot;: &quot;./dist/tailwind.config.js&quot;,
			&quot;require&quot;: &quot;./dist/tailwind.config.js&quot;
		},
		&quot;./prettier.config.js&quot;: {
			&quot;import&quot;: &quot;./dist/prettier.config.js&quot;,
			&quot;require&quot;: &quot;./dist/prettier.config.js&quot;
		}
	},
	&quot;scripts&quot;: {
		&quot;build&quot;: &quot;tsup&quot;,
		&quot;build:watch&quot;: &quot;tsup --watch&quot;,
		&quot;lint&quot;: &quot;tsc&quot;,
		&quot;test&quot;: &quot;echo no tests&quot;
	},
	&quot;files&quot;: [
		&quot;dist&quot;
	],
	&quot;dependencies&quot;: {
		&quot;@radix-ui/react-context-menu&quot;: &quot;^2.2.1&quot;,
		&quot;@radix-ui/react-dialog&quot;: &quot;^1.1.1&quot;,
		&quot;class-variance-authority&quot;: &quot;^0.7.0&quot;,
		&quot;clsx&quot;: &quot;^2.1.1&quot;,
		&quot;tailwind-merge&quot;: &quot;^2.5.2&quot;,
		&quot;tailwind-variants&quot;: &quot;^0.2.1&quot;,
		&quot;tailwindcss&quot;: &quot;^3.4.10&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;autoprefixer&quot;: &quot;^10.4.20&quot;,
		&quot;postcss&quot;: &quot;^8.4.41&quot;,
		&quot;eslint&quot;: &quot;^9.9.0&quot;,
		&quot;@types/eslint&quot;: &quot;^9.6.0&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,
		&quot;typescript-eslint&quot;: &quot;^8.1.0&quot;,
		&quot;globals&quot;: &quot;^15.9.0&quot;,
		&quot;tsup&quot;: &quot;^8.2.4&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;react&quot;: &quot;^18 || ^19&quot;,
		&quot;react-dom&quot;: &quot;^18 || ^19&quot;,
		&quot;@types/react&quot;: &quot;^18 || ^19&quot;,
		&quot;@types/react-dom&quot;: &quot;^18 || ^19&quot;,
		&quot;typescript&quot;: &quot;^5&quot;,
		&quot;@radix-ui/react-accordion&quot;: &quot;^1&quot;,
		&quot;@radix-ui/react-icons&quot;: &quot;^1&quot;,
		&quot;@radix-ui/react-select&quot;: &quot;^2&quot;,
		&quot;@radix-ui/react-tooltip&quot;: &quot;^1&quot;
	}
}</file><file path="surfaces/neuron/tsconfig.json">{
	&quot;extends&quot;: &quot;../../tsconfig.json&quot;,
	&quot;compilerOptions&quot;: {
		&quot;jsx&quot;: &quot;react-jsx&quot;,
		&quot;paths&quot;: {
			&quot;@/*&quot;: [&quot;./src/*&quot;]
		},
		// Building for a library in a monorepo
		&quot;rootDir&quot;: &quot;./src&quot;,
		&quot;lib&quot;: [&quot;ES2023&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
		&quot;declarationDir&quot;: &quot;./dist&quot;,
		&quot;tsBuildInfoFile&quot;: &quot;./dist/tsconfig.tsbuildinfo&quot;,
		&quot;outDir&quot;: &quot;./dist&quot;,
		&quot;declaration&quot;: true,
		&quot;composite&quot;: true,
		&quot;sourceMap&quot;: true,
		&quot;declarationMap&quot;: true
	},
	&quot;include&quot;: [&quot;src/**/*&quot;],
	&quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;, &quot;src/docs/**/*&quot;]
}</file><file path="tests/e2e/package.json">{
	&quot;name&quot;: &quot;e2e&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;module&quot;: &quot;index.ts&quot;,
	&quot;scripts&quot;: {
		&quot;test&quot;: &quot;playwright test --forbid-only&quot;,
		&quot;test:local&quot;: &quot;playwright test --reporter html&quot;,
		&quot;test:local:debug&quot;: &quot;playwright test --debug --reporter html&quot;,
		&quot;create-test-enterprise&quot;: &quot;bun src/api/common/create-test-enterprise.ts&quot;,
		&quot;generate:api&quot;: &quot;npx orval --config ./orval.config.ts&quot;,
		&quot;generate&quot;: &quot;npx orval --config ./orval.config.ts&quot;,
		&quot;postinstall&quot;: &quot;npx playwright install &amp;&amp; npx playwright install-deps&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@faker-js/faker&quot;: &quot;^8.4.1&quot;,
		&quot;axios&quot;: &quot;^1.7.2&quot;,
		&quot;date-fns&quot;: &quot;^3.6.0&quot;,
		&quot;delay&quot;: &quot;^6.0.0&quot;,
		&quot;e2e&quot;: &quot;.&quot;,
		&quot;nanoid&quot;: &quot;^5.0.7&quot;,
		&quot;orval&quot;: &quot;^7.0.1&quot;,
		&quot;pino&quot;: &quot;^9.3.2&quot;,
		&quot;pino-pretty&quot;: &quot;^11.2.2&quot;,
		&quot;winston&quot;: &quot;^3.15.0&quot;,
		&quot;winston-daily-rotate-file&quot;: &quot;^5.0.0&quot;,
		&quot;zod&quot;: &quot;^3.24.2&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@playwright/test&quot;: &quot;latest&quot;,
		&quot;playwright-ctrf-json-reporter&quot;: &quot;^0.0.18&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;typescript&quot;: &quot;^5.5.4&quot;
	}
}</file><file path="tests/e2e/tsconfig.json">{
	&quot;compilerOptions&quot;: {
		// Enable latest features
		&quot;lib&quot;: [&quot;ESNext&quot;],
		&quot;target&quot;: &quot;ESNext&quot;,
		&quot;module&quot;: &quot;ESNext&quot;,
		&quot;moduleDetection&quot;: &quot;force&quot;,
		&quot;jsx&quot;: &quot;react-jsx&quot;,
		&quot;allowJs&quot;: true,

		// Bundler mode
		&quot;moduleResolution&quot;: &quot;bundler&quot;,
		&quot;allowImportingTsExtensions&quot;: true,
		&quot;verbatimModuleSyntax&quot;: true,
		&quot;noEmit&quot;: true,

		// Best practices
		&quot;strict&quot;: true,
		&quot;skipLibCheck&quot;: true,
		&quot;noFallthroughCasesInSwitch&quot;: true,

		// Some stricter flags (disabled by default)
		&quot;noUnusedLocals&quot;: true,
		&quot;noUnusedParameters&quot;: true,
		&quot;noPropertyAccessFromIndexSignature&quot;: true,

		// path aliases
		&quot;paths&quot;: {
			&quot;config&quot;: [&quot;./src/config&quot;],
			&quot;@api-client/*&quot;: [&quot;./src/api-client/*&quot;]
		}
	}
}</file><file path="tsconfig.json">{
	&quot;compilerOptions&quot;: {
		/* Base Options */
		&quot;esModuleInterop&quot;: true,
		&quot;skipLibCheck&quot;: true,
		&quot;target&quot;: &quot;esnext&quot;,
		&quot;allowJs&quot;: true,
		&quot;resolveJsonModule&quot;: true,
		&quot;moduleDetection&quot;: &quot;force&quot;,
		&quot;isolatedModules&quot;: true,
		&quot;verbatimModuleSyntax&quot;: true,
		&quot;forceConsistentCasingInFileNames&quot;: true,

		/* Strictness */
		&quot;strict&quot;: true,
		&quot;noUncheckedIndexedAccess&quot;: true,
		&quot;noImplicitOverride&quot;: true,
		&quot;noImplicitReturns&quot;: true,
		&quot;noFallthroughCasesInSwitch&quot;: true,
		&quot;exactOptionalPropertyTypes&quot;: true,
		&quot;noPropertyAccessFromIndexSignature&quot;: true,

		/* If NOT transpiling with TypeScript: */
		&quot;module&quot;: &quot;preserve&quot;,
		&quot;noEmit&quot;: true,
		&quot;allowImportingTsExtensions&quot;: true,

		/* If your code doesn&apos;t run in the DOM: */
		&quot;lib&quot;: [&quot;esnext&quot;]
	}
}</file><file path="codegen/anterior-schemas/static/ts/package.json">{
	&quot;name&quot;: &quot;@anterior/gen-schemas&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;main&quot;: &quot;dist/index.js&quot;,
	&quot;module&quot;: &quot;dist/index.js&quot;,
	&quot;types&quot;: &quot;dist/index.d.ts&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;exports&quot;: {
		&quot;./package.json&quot;: &quot;./package.json&quot;,
		&quot;.&quot;: {
			&quot;types&quot;: &quot;./dist/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/index.js&quot;,
			&quot;require&quot;: &quot;./dist/index.js&quot;
		},
		&quot;./*&quot;: {
			&quot;types&quot;: &quot;./dist/*.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/*.js&quot;,
			&quot;require&quot;: &quot;./dist/*.js&quot;
		}
	},
	&quot;files&quot;: [
		&quot;dist&quot;
	],
	&quot;scripts&quot;: {
		&quot;build&quot;: &quot;tsc&quot;,
		&quot;build:watch&quot;: &quot;tsup --watch&quot;,
		&quot;lint&quot;: &quot;tsc&quot;,
		&quot;test&quot;: &quot;echo no tests&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/lib-platform&quot;: &quot;0.0.0&quot;,
		&quot;tsup&quot;: &quot;^8.2.4&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;esbuild&quot;: &quot;0.24.0&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;typescript&quot;: &quot;^5&quot;,
		&quot;zod&quot;: &quot;^3&quot;
	}
}</file><file path="codegen/anterior-schemas/static/ts/tsconfig.json">{
	&quot;extends&quot;: &quot;../../../tsconfig.json&quot;,
	&quot;include&quot;: [&quot;src/**/*&quot;],
	&quot;compilerOptions&quot;: {
		&quot;strictNullChecks&quot;: true,
		&quot;allowUnusedLabels&quot;: false,
		&quot;allowUnreachableCode&quot;: false,
		&quot;experimentalDecorators&quot;: true,
		&quot;emitDecoratorMetadata&quot;: true,
		&quot;noEmit&quot;: false,
		&quot;rewriteRelativeImportExtensions&quot;: true,
		&quot;outDir&quot;: &quot;dist&quot;,
		&quot;rootDir&quot;: &quot;./src&quot;,
		&quot;declarationDir&quot;: &quot;./dist&quot;,
		&quot;tsBuildInfoFile&quot;: &quot;./dist/tsconfig.tsbuildinfo&quot;,
		&quot;declaration&quot;: true,
		&quot;composite&quot;: true,
		&quot;sourceMap&quot;: true,
		&quot;declarationMap&quot;: true
	}
}</file><file path="codegen/anterior-schemas/package.json">{
  &quot;name&quot;: &quot;anterior-schemas&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
	&quot;types&quot;: &quot;src/index.ts&quot;,
  &quot;bin&quot;: {
    &quot;ant-gen&quot;: &quot;dist/cli.js&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;tsc &amp;&amp; chmod +x dist/cli.js &amp;&amp; cp -r ./static dist/static&quot;,
    &quot;test&quot;: &quot;./run-tests&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;dependencies&quot;: {
    &quot;typescript&quot;: &quot;^5.8.2&quot;,
    &quot;zod&quot;: &quot;^3.24.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@types/node&quot;: &quot;^22.14.0&quot;
  }
}</file><file path="codegen/anterior-schemas/tsconfig.json">{
	&quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;ESNext&quot;,
        &quot;esModuleInterop&quot;: true,

        &quot;noEmit&quot;: false,
        &quot;rewriteRelativeImportExtensions&quot;: true,
        &quot;noEmitOnError&quot;: false,

        &quot;rootDir&quot;: &quot;./src&quot;,
        &quot;outDir&quot;: &quot;./dist&quot;,

	    &quot;baseUrl&quot;: &quot;src/&quot;,
        &quot;module&quot;: &quot;NodeNext&quot;,
        &quot;moduleResolution&quot;: &quot;nodenext&quot;,
        &quot;skipLibCheck&quot;: true,
        &quot;forceConsistentCasingInFileNames&quot;: true,

        &quot;alwaysStrict&quot;: true,
        &quot;strict&quot;: true,
        &quot;strictNullChecks&quot;: true,
        &quot;allowUnusedLabels&quot;: false,
        &quot;allowUnreachableCode&quot;: false,
        &quot;noUncheckedIndexedAccess&quot;: true,
        &quot;noImplicitOverride&quot;: true,
        &quot;noImplicitReturns&quot;: true,
        &quot;noFallthroughCasesInSwitch&quot;: true,
        &quot;exactOptionalPropertyTypes&quot;: true,
        &quot;noPropertyAccessFromIndexSignature&quot;: true
	},
    &quot;include&quot;: [&quot;src/**/*.ts&quot;],
    &quot;exclude&quot;: [&quot;node_modules&quot;]
}</file><file path="gateways/noggin/src/@anterior/models/events/stems/attach_clinicals_to_stem_v1_1.ts">import { z } from &quot;zod&quot;
⋮----
export type AttachClinicalsToStemV11 = z.infer&lt;typeof attachClinicalsToStemV11&gt;</file><file path="gateways/noggin/src/@anterior/models/events/stems/attach_criteria_to_stem_v1_1.ts">import { z } from &quot;zod&quot;
⋮----
export type AttachCriteriaToStemV11 = z.infer&lt;typeof attachCriteriaToStemV11&gt;</file><file path="gateways/noggin/src/@anterior/models/events/stems/attach_services_to_stem_v1_1.ts">import { z } from &quot;zod&quot;
⋮----
export type AttachServicesToStemV11 = z.infer&lt;typeof attachServicesToStemV11&gt;</file><file path="gateways/noggin/src/@anterior/models/events/stems/create_determination_v1_1.ts">import { z } from &quot;zod&quot;
⋮----
export type CreateDeterminationV11 = z.infer&lt;typeof createDeterminationV11&gt;</file><file path="gateways/noggin/src/@anterior/models/events/stems/create_stem_v1_1.ts">import { z } from &quot;zod&quot;
⋮----
export type CreateStemV11 = z.infer&lt;typeof createStemV11&gt;</file><file path="gateways/noggin/src/@anterior/models/events/stems/stem_log_v1_1.ts">import { z } from &quot;zod&quot;
⋮----
export type StemLogV11 = z.infer&lt;typeof stemLogV11&gt;</file><file path="gateways/noggin/src/@anterior/models/events/stems/stem_meta_v1_1.ts">import { z } from &quot;zod&quot;
⋮----
export type StemMetaV11 = z.infer&lt;typeof stemMetaV11&gt;</file><file path="gateways/noggin/src/@anterior/models/s3/clinical_extraction.ts">import { z } from &quot;zod&quot;
⋮----
export type ClinicalExtraction = z.infer&lt;typeof clinicalExtraction&gt;</file><file path="gateways/noggin/src/@anterior/models/s3/criteria_document.ts">import { z } from &quot;zod&quot;
⋮----
export type CriteriaDocument = z.infer&lt;typeof criteriaDocument&gt;</file><file path="gateways/noggin/src/@anterior/models/s3/criteria_extraction.ts">import { z } from &quot;zod&quot;
⋮----
export type CriteriaExtraction = z.infer&lt;typeof criteriaExtraction&gt;</file><file path="gateways/noggin/src/@anterior/models/s3/determination.ts">import { z } from &quot;zod&quot;
⋮----
export type Determination = z.infer&lt;typeof determination&gt;</file><file path="gateways/noggin/src/@anterior/models/s3/healthhelp.ts">import { z } from &quot;zod&quot;
⋮----
export type Healthhelp = z.infer&lt;typeof healthhelp&gt;</file><file path="gateways/noggin/src/@anterior/models/shared/backend_config.ts">import { z } from &quot;zod&quot;
⋮----
export type BackendConfig = z.infer&lt;typeof backendConfig&gt;</file><file path="gateways/noggin/src/@anterior/models/shared/frontend_config.ts">import { z } from &quot;zod&quot;
⋮----
export type FrontendConfig = z.infer&lt;typeof frontendConfig&gt;</file><file path="gateways/noggin/src/@anterior/models/shared/pdf_section_v01_20250514.ts">import { z } from &quot;zod&quot;
⋮----
export type PdfSectionV0120250514 = z.infer&lt;typeof pdfSectionV0120250514&gt;</file><file path="gateways/noggin/src/@anterior/models/shared/text_section_v01_20250514.ts">import { z } from &quot;zod&quot;
⋮----
export type TextSectionV0120250514 = z.infer&lt;typeof textSectionV0120250514&gt;</file><file path="gateways/noggin/src/@anterior/models/shared/webhook_api_v1x0.ts">import { z } from &quot;zod&quot;
⋮----
export type WebhookApiV1x0 = z.infer&lt;typeof webhookApiV1x0&gt;</file><file path="gateways/noggin/src/agents/app.ts">import {
	App,
	createStaticApp,
	type AppOptions,
	type EndpointSignature,
} from &quot;@anterior/lib-platform/app&quot;;
import { type Logger } from &quot;@anterior/lib-platform/log&quot;;
import { agentsBlob } from &quot;./infra.ts&quot;;
import type { Platform } from &quot;./platform.ts&quot;;
⋮----
export interface AgentsAppContext {
	logger: Logger;
	platform: Platform;
}
⋮----
export interface AgentsAppService {
	GET: {
		&quot;/&quot;: EndpointSignature&lt;object, object&gt;;
	};
}
⋮----
export type AgentsApp = App&lt;AgentsAppService, AgentsAppContext&gt;;
⋮----
export function createAgentsApp(baseCtx: AgentsAppContext, options: AppOptions): AgentsApp
⋮----
// Serve static files from s3, including assets.
// See createStaticApp for more details, in lib/ts/lib-platform/app.ts</file><file path="gateways/noggin/src/agents/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import config from &quot;@anterior/lib-infra/config&quot;;
import { S3Bucket } from &quot;@anterior/lib-infra/s3&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;
⋮----
// 🚨 DANGER! do not change this path, or risk overwriting
// production S3 data in other paths. We need to overhaul
// our bucket policy to restrict bucket path access to
// certain roles to prevent accidental deletion.
//
// NB: this is only used to pull the frontend app from s3
// and serve it to the user from noggin
⋮----
/**
 * Platform configuration for the Agents application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for note payloads and metadata
 * - Flows: LLM-based note generation pipeline
 *
 * Each service is configured with specific settings for the Agents
 * use case, ensuring proper isolation and resource management.
 */</file><file path="gateways/noggin/src/ahip/app.ts">import {
	App,
	createStaticApp,
	type AppOptions,
	type EndpointSignature,
} from &quot;@anterior/lib-platform/app&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import { ahipFeBlobs } from &quot;./infra.ts&quot;;
import type { Platform } from &quot;./platform.ts&quot;;
⋮----
export interface AhipAppContext {
	logger: Logger;
	platform: Platform;
}
⋮----
export interface AhipAppService {
	GET: {
		&quot;/&quot;: EndpointSignature&lt;{}, object&gt;;
	};
}
⋮----
export type AhipApp = App&lt;AhipAppService, AhipAppContext&gt;;
⋮----
export function createAhipApp(baseCtx: AhipAppContext, options: AppOptions): AhipApp
⋮----
// serves static files from s3, including assets
// see createStaticApp for more details, in lib/ts/lib-platform/app.ts
⋮----
// 🚨 Using `hono` outside `lib-platform` is a smell!</file><file path="gateways/noggin/src/ahip/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import config from &quot;@anterior/lib-infra/config&quot;;
import { S3Bucket } from &quot;@anterior/lib-infra/s3&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;
⋮----
// 🚨 DANGER! do not change this path, or risk overwriting
// production S3 data in other paths. We need to overhaul
// our bucket policy to restrict bucket path access to
// certain roles to prevent accidental deletion.
//
// NB: this is only used to pull the frontend app from s3
// and serve it to the user from noggin
⋮----
/**
 * Platform configuration for the Flopilot application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for note payloads and metadata
 * - Flows: LLM-based note generation pipeline
 *
 * Each service is configured with specific settings for the Flopilot
 * use case, ensuring proper isolation and resource management.
 */</file><file path="gateways/noggin/src/ahip/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import { InMemoryBlobStoreBackend } from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
/**
 * Infrastructure interface defining the external resources needed by the platform.
 *
 * The platform can be deployed in different environments:
 * - Production: Resources managed by CDK/Terraform
 * - Docker/CI: Resources managed by Docker Compose
 * - Local/Testing: Resources represented by in-memory implementations
 *
 * This abstraction allows for environment-specific implementations
 * while maintaining a consistent interface for the application.
 */
export interface Infra {
	logger: Logger;
	blobs: BlobStoreBackend;
}
⋮----
/**
 * Creates an in-memory implementation of the infrastructure.
 *
 * This is not meant for production use! The in-memory implementation
 * is useful for:
 * - Unit testing: Fast, isolated test environment
 * - Local development: Quick setup without external dependencies
 *
 * Note that all data is lost when the process exits.
 */
export function getInMemoryInfra(): Infra
⋮----
/**
 * Application layer interface to the resource backends.
 *
 * This interface provides type-safe access to:
 * - Blob storage: For storing note payloads and metadata
 *
 * The interface ensures that all platform operations are properly
 * typed and validated against their schemas.
 */
export interface Stores {
	readonly blobs: BlobStore;
}
⋮----
/**
 * Core platform implementation for the Flopilot application.
 *
 * The platform provides:
 * 1. Factory methods for creating platform instances
 * 2. Type-safe access to storage and flow services
 * 3. Environment-specific resource management
 */
export class Platform
⋮----
/**
	 * Creates an in-memory platform instance for testing.
	 *
	 * This method allows for partial infrastructure overrides,
	 * making it easy to mock specific components while using
	 * real implementations for others.
	 */
public static inMemory(infra: Partial&lt;Infra&gt; =
⋮----
/**
	 * Creates a platform instance from infrastructure configuration.
	 *
	 * This method:
	 * 1. Sets up the message queue for flow scheduling
	 * 2. Initializes blob storage for note data
	 * 3. Configures proper serialization and validation
	 */
public static fromInfra(infra: Infra): Platform
⋮----
constructor(public readonly stores: Stores)
⋮----
/**
	 * Type-safe access to the blob storage service.
	 * Used for storing and retrieving note data.
	 */
get blobs(): BlobStore</file><file path="gateways/noggin/src/auth/app.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import { S3Bucket } from &quot;@anterior/lib-infra/s3&quot;;
import {
	App,
	type AppOptions,
	type EndpointSignature,
	createStaticApp,
} from &quot;@anterior/lib-platform/app&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { KeyMissingError } from &quot;@anterior/lib-platform/errors&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
import type { ExecutionContext } from &quot;hono&quot;;
⋮----
// this doesn&apos;t match what the API sets
// for the access token expiry...it&apos;s much shorter
// revisit, and use the same source of truth
const ACCESS_TOKEN_MAX_AGE = 900; // 15 minutes
⋮----
// refresh is not yet functional...
// but we need it so that users aren&apos;t
// logged out
const REFRESH_TOKEN_MAX_AGE = 43200; // 30 days
⋮----
// we should shore this up...was testing various cookie options for
// authenticating the frontend app hosted by noggin/src/flonotes
⋮----
export class Auth
⋮----
constructor(private apiBaseUrl: string)
async createOtp(body:
async verifyOtp(
⋮----
// NB: not yet implemented below as createOtp and verifyOtp are
async refreshToken(refreshToken: string): Promise&lt;AuthResponse&gt;
⋮----
export interface AuthAppContext {
	logger: Logger;
	auth: Auth;
}
⋮----
export interface AuthResponse {
	access_token: string;
	refresh_token: string;
	token_type: &quot;bearer&quot;;
}
⋮----
export interface AuthAppService {
	GET: {
		&quot;/login.html&quot;: EndpointSignature&lt;null, string&gt;;
		&quot;/otp-verify.html&quot;: EndpointSignature&lt;null, string&gt;;
		&quot;/&quot;: EndpointSignature&lt;null, void&gt;;
		// NB: this we could ideally do away with @ajit
		&quot;/status&quot;: EndpointSignature&lt;null, { authenticated: boolean; user?: { uid: string } }&gt;;
	};
	POST: {
		&quot;/login&quot;: EndpointSignature&lt;{ email: string; password: string }, null&gt;;
		&quot;/otp/verify&quot;: EndpointSignature&lt;{ email: string; otp: string }, AuthResponse&gt;;
		&quot;/login.html&quot;: EndpointSignature&lt;{ email: string; password: string }, string&gt;;
		&quot;/otp-verify.html&quot;: EndpointSignature&lt;{ email: string; otp: string }, string&gt;;
		&quot;/refresh&quot;: EndpointSignature&lt;null, AuthResponse&gt;;
	};
}
⋮----
// NB: this we could ideally do away with @ajit
⋮----
export type AuthApp = App&lt;AuthAppService, AuthAppContext&gt;;
⋮----
export function createAuthApp(baseCtx: AuthAppContext, options: AppOptions): AuthApp
⋮----
const setAuthCookies = (
		response: Response,
		tokens: { access_token: string; refresh_token: string },
) =&gt;
⋮----
// default to redirecting to the FloNotes frontend app proxied from s3 by noggin/src/flonotes
const getFormValue = (formData: FormData, key: string)
⋮----
async handler(ctx)
⋮----
prefix: &quot;&quot;, // no prefix
⋮----
// serve static files from s3 by default</file><file path="gateways/noggin/src/auth/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Auth, createAuthApp } from &quot;./app.ts&quot;;
⋮----
// TODO: enable CSRF ASAP, when client is ready
// the frontend apps will need this implemented</file><file path="gateways/noggin/src/chat/main.ts">import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import Anthropic from &quot;@anthropic-ai/sdk&quot;;
import config from &quot;../config.ts&quot;;
import { createChatApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;</file><file path="gateways/noggin/src/chat/parser.test.ts">import { expect, test } from &quot;vitest&quot;;
import { calculateContentOffsets } from &quot;./parser.ts&quot;;</file><file path="gateways/noggin/src/chat/parser.ts">export function calculateContentOffsets(text: string):
⋮----
// Use regex to match extract tags
⋮----
// list of all regex matches
⋮----
// strip the text of all xml tags</file><file path="gateways/noggin/src/flobot/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import { Slack } from &quot;@anterior/lib-infra/slack&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createFlobotApp } from &quot;./app.ts&quot;;
⋮----
// Flobot app exposes the slack-edge server, which handles its own
// authentication. This app does not use Anterior&apos;s auth.</file><file path="gateways/noggin/src/flonotes/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createFlonotesApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;</file><file path="gateways/noggin/src/flopilot/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createFlopilotApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;</file><file path="gateways/noggin/src/health/app.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import { App, type EndpointSignature } from &quot;@anterior/lib-platform/app&quot;;
import { logger, type Logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
interface HealthAppService {
	GET: {
		&quot;/&quot;: EndpointSignature&lt;{}, string&gt;;
	};
}
export function createHealthApp()</file><file path="gateways/noggin/src/hello-world/test-e2e/greet.spec.ts">import test, { expect } from &quot;@playwright/test&quot;;</file><file path="gateways/noggin/src/hello-world/app.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import { FSDirectory } from &quot;@anterior/lib-infra/fs&quot;;
import { App, createStaticApp, type EndpointSignature } from &quot;@anterior/lib-platform/app&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { logger, type Logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
import { dirname, join } from &quot;path&quot;;
import { fileURLToPath } from &quot;url&quot;;
import { getGreeting, getLatestGreetee, setLatestGreetee } from &quot;./hello.ts&quot;;
⋮----
interface AppEnv {
	readonly ANT_LISTEN_PORT: string;
	readonly ANT_ALLOWED_ORIGINS: string;
}
⋮----
/**
 * TODO this is _not_ how things should work. Config throws for missing env vars, and we should not
 * be throwing at import time. For now, to get directory apps working, we do this until we figure
 * out how to ensure type safety for the dynamic imports
 */
⋮----
async handler()
⋮----
async handler(
⋮----
// TODO this doesn&apos;t currently work, will look into it later when preparing the hello world for a
// show and tell (if that ever happens) - jkz 2025-04</file><file path="gateways/noggin/src/hello-world/hello.ts">import infra from &quot;@anterior/lib-infra&quot;;
import { KVStore } from &quot;@anterior/lib-platform/kv&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { toSchema } from &quot;@anterior/lib-platform/schema&quot;;
import { typedIdentitySerializer } from &quot;@anterior/lib-platform/serializer&quot;;
⋮----
// TODO This is 100% not where this should live;
// It is a contrived way to set up an integration test requirement
⋮----
1000, // get timeout ms
1000, // set timeout ms
⋮----
export function getGreeting(greetee: string): string
⋮----
export async function getLatestGreetee(): Promise&lt;string&gt;
⋮----
export async function setLatestGreetee(greetee: string): Promise&lt;void&gt;</file><file path="gateways/noggin/src/notes/handlers/notes.ts">import { HTTPException, type BaseContext } from &quot;@anterior/lib-platform/app&quot;;
import { Blob } from &quot;@anterior/lib-platform/blob&quot;;
import { KeyMissingError } from &quot;@anterior/lib-platform/errors&quot;;
import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import { NoSuchKey } from &quot;@aws-sdk/client-s3&quot;;
import { parseAuthInfo } from &quot;../../auth/jwt.ts&quot;;
import { buildS3NotePath, stemStorageBlobs } from &quot;../infra.ts&quot;;
import type { Platform } from &quot;../platform.ts&quot;;
import { flonotesFlowName, flonotesFlowResultSchema } from &quot;../schemas/flows.ts&quot;;
import type {
	CreateNoteInput,
	CreateNoteOutput,
	NoteOutput,
	ProcessingStatus,
} from &quot;../schemas/types.ts&quot;;
⋮----
export function handleStorageError(error: unknown, logger: Logger, context: string): never
⋮----
interface NoteContext extends BaseContext {
	platform: Platform;
	logger: Logger;
}
⋮----
/**
 * Handle POST /notes endpoint
 * Creates a new note by submitting user message to the LLM service
 */
export async function createNote(
	ctx: NoteContext,
	body: CreateNoteInput,
): Promise&lt;CreateNoteOutput&gt;
⋮----
// Ensure flowName matches exactly what the schema expects
// the `as const` prevents accidental changes to the workflow name
⋮----
/**
 * Handle GET /notes-status/:stemUid/:noteUid endpoint
 * Checks the processing status of a note
 */
export async function getNoteStatus(
	ctx: NoteContext,
	params: { stemUid: string; noteUid: string },
): Promise&lt;
⋮----
// if the file isn&apos;t found, the note is still processing
// nb: we aren&apos;t doing anything on the workflow level to mark
// the jobs status as &quot;error&quot;
⋮----
/**
 * Handle GET /notes/:stemUid/:noteUid endpoint
 * Retrieves a note by its ID after processing is complete
 */
export async function getNote(
	ctx: NoteContext,
	params: { stemUid: string; noteUid: string },
): Promise&lt;NoteOutput&gt;</file><file path="gateways/noggin/src/notes/schemas/flows.ts">import { processFlonotesLlmEgress } from &quot;../../@anterior/models/workflows/flonotes/process_flonotes_llm/process_flonotes_llm_egress.ts&quot;;
import { processFlonotesLlmIngress } from &quot;../../@anterior/models/workflows/flonotes/process_flonotes_llm/process_flonotes_llm_ingress.ts&quot;;
⋮----
/**
 * Schema for validating workflow parameters when scheduling the process-flonotes-llm/dev flow
 */
⋮----
export type FlonotesFlowParams = z.infer&lt;typeof flonotesFlowParamsSchema&gt;;
⋮----
/**
 * Schema for validating workflow outputs from the process-flonotes-llm/dev flow
 */
⋮----
export type FlonotesFlowResult = z.infer&lt;typeof flonotesFlowResultSchema&gt;;</file><file path="gateways/noggin/src/notes/app.ts">import { App, type AppOptions, type EndpointSignature } from &quot;@anterior/lib-platform/app&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import type { Platform } from &quot;./platform.ts&quot;;
import type { CreateNoteInput, CreateNoteOutput } from &quot;./schemas/types.ts&quot;;
⋮----
import {
	createNoteRequestSchema,
	createNoteResponseSchema,
	getNoteResponseSchema,
	getNoteStatusResponseSchema,
	stemNoteUidSchema,
} from &quot;./schemas/api.ts&quot;;
⋮----
import { createNote, getNote, getNoteStatus } from &quot;./handlers/notes.ts&quot;;
⋮----
export interface LLMAppContext {
	logger: Logger;
	platform: Platform;
}
⋮----
export interface LLMAppService {
	GET: {
		&quot;/notes/:stemUid/:noteUid&quot;: EndpointSignature&lt;{ stemUid: string; noteUid: string }, Response&gt;;
		&quot;/notes-status/:stemUid/:noteUid&quot;: EndpointSignature&lt;
			{ stemUid: string; noteUid: string },
			Response
		&gt;;
	};
	POST: {
		&quot;/notes&quot;: EndpointSignature&lt;CreateNoteInput, CreateNoteOutput&gt;;
	};
}
⋮----
export type LLMApp = App&lt;LLMAppService, LLMAppContext&gt;;
⋮----
export function createNotesApp(ctx: LLMAppContext, options: AppOptions): LLMApp
⋮----
async handler(ctx)</file><file path="gateways/noggin/src/notes/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import config from &quot;@anterior/lib-infra/config&quot;;
import { S3Bucket } from &quot;@anterior/lib-infra/s3&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;
⋮----
// we can generalize this for llm outputs beyond notes
export function buildS3NotePath(
	enterpriseUid: string,
	stemUid: string,
	noteUid: string,
):
⋮----
/**
 * Platform configuration for the client-agnostic, generic LLM application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for note payloads and metadata
 * - Flows: Workflows for various LLM-based tasks (e.g. process-flonotes-llm/dev)
 */</file><file path="gateways/noggin/src/notes/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createNotesApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;</file><file path="gateways/noggin/src/notes/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import { type FlowEnvelope, FlowScheduler, toFlowSchema } from &quot;@anterior/lib-platform/flows&quot;;
import {
	InMemoryBlobStoreBackend,
	InMemoryMessageQueueBackend,
} from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
import { type MessageQueueBackend, MessageQueueImpl } from &quot;@anterior/lib-platform/queue&quot;;
import { jsonSerializer } from &quot;@anterior/lib-platform/serializer&quot;;
⋮----
// import all types of workflows here
import { type FlonotesFlowParams, flonotesFlowParamsSchema } from &quot;./schemas/flows.ts&quot;;
⋮----
/**
 * Infrastructure interface defining the external resources needed by the platform.
 *
 * The platform can be deployed in different environments:
 * - Production: Resources managed by CDK/Terraform
 * - Docker/CI: Resources managed by Docker Compose
 * - Local/Testing: Resources represented by in-memory implementations
 *
 * This abstraction allows for environment-specific implementations
 * while maintaining a consistent interface for the application.
 */
export interface Infra {
	logger: Logger;
	flowsQueue: MessageQueueBackend&lt;string&gt;;
	blobs: BlobStoreBackend;
}
⋮----
/**
 * Creates an in-memory implementation of the infrastructure.
 *
 * This is not meant for production use! The in-memory implementation
 * is useful for:
 * - Unit testing: Fast, isolated test environment
 * - Local development: Quick setup without external dependencies
 *
 * Note that all data is lost when the process exits.
 */
export function getInMemoryInfra(): Infra
⋮----
/**
 * Application layer interface to the resource backends.
 *
 * This interface provides type-safe access to:
 * - Blob storage: For storing note payloads and metadata
 * - Flow scheduling: For managing LLM-based note generation
 *
 * The interface ensures that all platform operations are properly
 * typed and validated against their schemas.
 */
export interface Stores {
	readonly blobs: BlobStore;
	readonly flows: FlowScheduler&lt;FlonotesFlowParams&gt;;
}
⋮----
/**
 * Core platform implementation for the Flonotes application.
 *
 * The platform provides:
 * 1. Factory methods for creating platform instances
 * 2. Type-safe access to storage and flow services
 * 3. Environment-specific resource management
 */
export class Platform
⋮----
/**
	 * Creates an in-memory platform instance for testing.
	 *
	 * This method allows for partial infrastructure overrides,
	 * making it easy to mock specific components while using
	 * real implementations for others.
	 */
public static inMemory(infra: Partial&lt;Infra&gt; =
⋮----
/**
	 * Creates a platform instance from infrastructure configuration.
	 *
	 * This method:
	 * 1. Sets up the message queue for flow scheduling
	 * 2. Initializes blob storage for note data
	 * 3. Configures proper serialization and validation
	 */
public static fromInfra(infra: Infra): Platform
⋮----
constructor(public readonly stores: Stores)
⋮----
/**
	 * Type-safe access to the flow scheduling service.
	 * Used for managing LLM-based note generation tasks.
	 */
get flows(): FlowScheduler&lt;FlonotesFlowParams&gt;
⋮----
/**
	 * Type-safe access to the blob storage service.
	 * Used for storing and retrieving note data.
	 */
get blobs(): BlobStore</file><file path="gateways/noggin/src/pdfs/models/flows.ts">import { processPdfStandaloneEgress } from &quot;../../@anterior/models/workflows/pdfs/process_pdf_standalone/process_pdf_standalone_egress.ts&quot;;
import { processPdfStandaloneIngress } from &quot;../../@anterior/models/workflows/pdfs/process_pdf_standalone/process_pdf_standalone_ingress.ts&quot;;
⋮----
/**
 * Schema for validating workflow parameters when scheduling the process-pdf-standalone/dev flow
 */
⋮----
export type PdfFlowParams = z.infer&lt;typeof pdfFlowParamsSchema&gt;;
⋮----
/**
 * Schema for validating workflow outputs from the process-pdf-standalone/dev flow
 */
⋮----
export type PdfFlowResult = z.infer&lt;typeof pdfFlowResultSchema&gt;;</file><file path="gateways/noggin/src/pdfs/models/schemas.ts">import type { SchemaLike } from &quot;@anterior/lib-platform/schema&quot;;
import { z } from &quot;@anterior/lib-platform/zod&quot;;
⋮----
export const createIdValidator = (prefix: string, errorMessage?: string)
⋮----
export type StemPdfProcessingStatus = &quot;processing&quot; | &quot;ready&quot; | &quot;error&quot;;
⋮----
export type StemPdfUid = { stemUid: string; pdfUid: string };
⋮----
export type PdfFile = Blob;
⋮----
export type ProcessStemPdf = { stemUid?: string | undefined; files: PdfFile[] };
⋮----
export type StemPdfUidResponse = { stemUid: string; pdfUids: string[] };
⋮----
export type StemPdfStatusResponse = {
	status: StemPdfProcessingStatus;
	message?: string | undefined;
};</file><file path="gateways/noggin/src/pdfs/app.ts">import {
	App,
	getHonoContext,
	HTTPException,
	type AppOptions,
	type EndpointSignature,
} from &quot;@anterior/lib-platform/app&quot;;
import { KeyMissingError } from &quot;@anterior/lib-platform/errors&quot;;
import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import { NoSuchKey } from &quot;@aws-sdk/client-s3&quot;;
import { parseAuthInfo } from &quot;../auth/jwt.ts&quot;;
import type { Platform } from &quot;./platform.ts&quot;;
⋮----
import {
	processStemPdfSchema,
	stemPdfStatusResponseSchema,
	stemPdfUidResponseSchema,
	stemPdfUidSchema,
	type ProcessStemPdf,
	type StemPdfStatusResponse,
	type StemPdfUid,
	type StemPdfUidResponse,
} from &quot;./models/schemas.ts&quot;;
⋮----
import { processPdfStandaloneFlowName, type PdfFlowResult } from &quot;./models/flows.ts&quot;;
⋮----
export type PdfUidParams = StemPdfUid;
export type PdfUploadBody = ProcessStemPdf;
⋮----
export interface PdfAppContext {
	logger: Logger;
	platform: Platform;
}
export type PdfApp = App&lt;PdfAppService, PdfAppContext&gt;;
⋮----
export interface PdfAppService {
	POST: {
		&quot;/process-pdfs&quot;: EndpointSignature&lt;PdfUploadBody, StemPdfUidResponse&gt;;
	};
	GET: {
		&quot;/pdf-status/:stemUid/:pdfUid&quot;: EndpointSignature&lt;PdfUidParams, StemPdfStatusResponse&gt;;
		&quot;/pdf-extracts/:stemUid/:pdfUid&quot;: EndpointSignature&lt;PdfUidParams, PdfFlowResult&gt;;
	};
}
⋮----
interface BuildS3PdfPathArgs {
	enterpriseUid: string;
	stemUid: string;
	pdfUid: string;
	filename: string;
}
⋮----
function buildS3PdfPath(
⋮----
/**
 * Handles S3-related errors with appropriate HTTP responses
 * Maps common S3 errors to user-friendly messages
 */
function handleS3Error(error: unknown): never
⋮----
export function createPdfApp(ctx: PdfAppContext, options: AppOptions): PdfApp
⋮----
async handler(ctx)
⋮----
/**
			 * Use provided stemUid or generate a new one if missing
			 *
			 * A stem is used to combine multiple PDFs into a single
			 * element for processing and inference.
			 */</file><file path="gateways/noggin/src/pdfs/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createPdfApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;
⋮----
// TODO: enable CSRF ASAP, when client is ready
// the frontend apps will need this implemented</file><file path="gateways/noggin/src/pdfs/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import { type FlowEnvelope, FlowScheduler, toFlowSchema } from &quot;@anterior/lib-platform/flows&quot;;
import {
	InMemoryBlobStoreBackend,
	InMemoryMessageQueueBackend,
} from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
import { type MessageQueueBackend, MessageQueueImpl } from &quot;@anterior/lib-platform/queue&quot;;
import { jsonSerializer } from &quot;@anterior/lib-platform/serializer&quot;;
import { type PdfFlowParams, pdfFlowParamsSchema } from &quot;./models/flows.ts&quot;;
⋮----
/**
 * The backends for external resources that the platform needs to interact with.
 * In prod, these are managed by cdkrf/terraform
 * In docker/CI, these are managed by docker compose services
 * In local dev and unit tests, these can be represented by in-memory implementations
 */
export interface Infra {
	logger: Logger;
	flowsQueue: MessageQueueBackend&lt;string&gt;;
	blobs: BlobStoreBackend;
}
⋮----
/**
 * This is not meant for production use!
 *
 * The in-memory infra is useful for unit testing and local development,
 * but all data is lost when the process exits.
 */
export function getInMemoryInfra(): Infra
⋮----
/**
 * The application layer interface to the resource backends.
 */
export interface Stores {
	readonly blobs: BlobStore;
	readonly flows: FlowScheduler&lt;PdfFlowParams&gt;;
}
⋮----
// NB: this derives from src/mnr/service/platform.ts
// taking only what it needs
export class Platform
⋮----
/**
	 * This returns a fledged in-memory implementation of the platform.
	 * Useful for testing.
	 */
public static inMemory(infra: Partial&lt;Infra&gt; =
public static fromInfra(infra: Infra): Platform
⋮----
constructor(public readonly stores: Stores)
⋮----
get flows(): FlowScheduler&lt;PdfFlowParams&gt;
⋮----
get blobs(): BlobStore</file><file path="gateways/noggin/src/stems/events/emit-stem-event.ts">import { EventStreamWriter } from &quot;@anterior/lib-platform/events&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import type { StemMetaV11 } from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { platform } from &quot;../infra.ts&quot;;
import type { StemEventPayloads } from &quot;../schemas/events.ts&quot;;
⋮----
/**
 * Wrapper around `EventStreamWriter` to emit stem events.
 */
export async function emitStemEvent(meta: StemMetaV11, payload: StemEventPayloads)</file><file path="gateways/noggin/src/stems/events/to-event-schema.ts">import { getZod, type SchemaLike } from &quot;@anterior/lib-platform/schema&quot;;
import { z } from &quot;zod&quot;;
import { stemMetaV11 } from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import type { Event, EventPayload } from &quot;../schemas/events.ts&quot;;
⋮----
export function toEventSchema&lt;TPayload extends EventPayload&gt;(
	payload: SchemaLike&lt;TPayload&gt;,
): SchemaLike&lt;Event&lt;TPayload&gt;&gt;</file><file path="gateways/noggin/src/stems/handlers/create-stem.ts">import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import {
	type CreateStemV11,
	createStemV11,
} from &quot;../../@anterior/models/events/stems/create_stem_v1_1.ts&quot;;
import {
	type StemMetaV11,
	stemMetaV11,
} from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { emitStemEvent } from &quot;../events/emit-stem-event.ts&quot;;
⋮----
export const createStem = async (workspaceUid: string, enterpriseUid: string, userUid: string) =&gt;</file><file path="gateways/noggin/src/stems/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createStemsApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;
⋮----
// TODO: enable CSRF ASAP, when client is ready
// the frontend apps will need this implemented</file><file path="gateways/noggin/src/stems/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import type { EventStoreBackend } from &quot;@anterior/lib-platform/events&quot;;
import { EventStore } from &quot;@anterior/lib-platform/events&quot;;
import {
	InMemoryBlobStoreBackend,
	InMemoryEventStoreBackend,
} from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
import { toSchema } from &quot;@anterior/lib-platform/schema&quot;;
import { type StemEvents, stemEventSchema, stemEventSerializer } from &quot;./schemas/events.ts&quot;;
⋮----
/**
 * Infrastructure interface defining the external resources needed by the platform.
 *
 * The platform can be deployed in different environments:
 * - Production: Resources managed by CDK/Terraform
 * - Docker/CI: Resources managed by Docker Compose
 * - Local/Testing: Resources represented by in-memory implementations
 *
 * This abstraction allows for environment-specific implementations
 * while maintaining a consistent interface for the application.
 */
export interface Infra {
	logger: Logger;
	blobs: BlobStoreBackend;
	events: EventStoreBackend;
}
⋮----
/**
 * Creates an in-memory implementation of the infrastructure.
 *
 * This is not meant for production use! The in-memory implementation
 * is useful for:
 * - Unit testing: Fast, isolated test environment
 * - Local development: Quick setup without external dependencies
 *
 * Note that all data is lost when the process exits.
 */
export function getInMemoryInfra(): Infra
⋮----
/**
 * Application layer interface to the resource backends.
 *
 * This interface provides type-safe access to:
 * - Blob storage: For storing note payloads and metadata
 *
 * The interface ensures that all platform operations are properly
 * typed and validated against their schemas.
 */
export interface Stores {
	readonly blobs: BlobStore;
	readonly events: EventStore&lt;StemEvents&gt;;
}
⋮----
/**
 * Core platform implementation for the stems application.
 *
 * The platform provides:
 * 1. Factory methods for creating platform instances
 * 2. Type-safe access to storage and flow services
 * 3. Environment-specific resource management
 */
export class Platform
⋮----
/**
	 * Creates an in-memory platform instance for testing.
	 *
	 * This method allows for partial infrastructure overrides,
	 * making it easy to mock specific components while using
	 * real implementations for others.
	 */
public static inMemory(infra: Partial&lt;Infra&gt; =
⋮----
/**
	 * Creates a platform instance from infrastructure configuration.
	 *
	 * This method:
	 * 1. Sets up the message queue for flow scheduling
	 * 2. Initializes blob storage for note data
	 * 3. Configures proper serialization and validation
	 */
public static fromInfra(infra: Infra): Platform
⋮----
// wrap this into a read/write stream
⋮----
constructor(public readonly stores: Stores)
⋮----
/**
	 * Type-safe access to the blob storage service.
	 * Used for storing and retrieving note data.
	 */
get blobs(): BlobStore</file><file path="gateways/noggin/src/tasks/handlers/mnr.ts">import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import type { AttachServicesToStemV11 } from &quot;../../@anterior/models/events/stems/attach_services_to_stem_v1_1.ts&quot;;
import {
	type StemMetaV11,
	stemMetaV11,
} from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { emitStemEvent } from &quot;../../stems/events/emit-stem-event.ts&quot;;
import { platform } from &quot;../infra.ts&quot;;
⋮----
interface RunMnrParams {
	enterpriseUid: string;
	userUid: string;
	workspaceUid: string;
	artQueries: {
		member?: string | undefined;
		criteria: string;
		clinicals: string[];
	};
	serviceRequest: AttachServicesToStemV11[&quot;services&quot;][number];
	stemId: string;
}
⋮----
export const runMnr = async ({
	enterpriseUid,
	userUid,
	workspaceUid,
	artQueries,
	serviceRequest,
	stemId,
}: RunMnrParams) =&gt;</file><file path="gateways/noggin/src/tasks/handlers/populate-note-template.ts">import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import {
	type StemMetaV11,
	stemMetaV11,
} from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { emitStemEvent } from &quot;../../stems/events/emit-stem-event.ts&quot;;
import { platform } from &quot;../infra.ts&quot;;
⋮----
type PopulateNoteTemplateParams = {
	enterpriseUid: string;
	userUid: string;
	workspaceUid: string;
	stemId: string;
};
⋮----
// NB: we intend to deprecate all &quot;uid&quot; in favor of &quot;id&quot;
export const populateNoteTemplate = async ({
	enterpriseUid,
	userUid,
	workspaceUid,
	stemId,
}: PopulateNoteTemplateParams) =&gt;
⋮----
case_uid: stemId, // deprecate case_uid?
⋮----
workstream_id: &quot;populate_note_template&quot;, // deprecate?
product_id: &quot;populate_note_template&quot;, // deprecate?</file><file path="gateways/noggin/src/tasks/infra.ts">import infra_ from &quot;@anterior/lib-infra&quot;;
import config from &quot;@anterior/lib-infra/config&quot;;
import { S3Bucket } from &quot;@anterior/lib-infra/s3&quot;;
import { BlobStore } from &quot;@anterior/lib-platform/blob&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { Platform } from &quot;./platform.ts&quot;;
⋮----
// 🚨 DANGER! do not change this path, or risk overwriting
// production S3 data in other paths. We need to overhaul
// our bucket policy to restrict bucket path access to
// certain roles to prevent accidental deletion.
//
// NB: this is only used to pull the frontend app from s3
// and serve it to the user from noggin
⋮----
/**
 * Platform configuration for the Tasks application.
 *
 * The platform provides access to core services:
 * - Storage: S3-based storage for note payloads and metadata
 * - Flows: LLM-based note generation pipeline
 *
 * Each service is configured with specific settings for the Tasks
 * use case, ensuring proper isolation and resource management.
 */</file><file path="gateways/noggin/src/tasks/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createTasksApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;</file><file path="gateways/noggin/package.json">{
	&quot;name&quot;: &quot;@anterior/noggin&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;bin&quot;: {
		&quot;noggin&quot;: &quot;dist/index.js&quot;,
		&quot;noggin-migrate&quot;: &quot;dist/migrate.js&quot;
	},
	&quot;scripts&quot;: {
		&quot;workers:projections&quot;: &quot;tsx src/mnr/workers/projections/app.ts&quot;,
		&quot;workers:dynamo-streams-consumer&quot;: &quot;tsx src/mnr/workers/dynamo-streams-consumer/app.ts&quot;,
		&quot;build&quot;: &quot;tsc &amp;&amp; copyfiles -u 1 src/**/static/* dist &amp;&amp; chmod +x dist/index.js dist/migrate.js&quot;,
		&quot;watch&quot;: &quot;echo &apos;this compiles and moves the static files ONCE and then watches&apos; &amp;&amp; tsc &amp;&amp; copyfiles -u 1 src/**/static/* dist &amp;&amp; chmod +x dist/index.js dist/migrate.js &amp;&amp; tsc -w&quot;,
		&quot;start&quot;: &quot;tsx src/index.ts&quot;,
		&quot;test&quot;: &quot;echo noggin unit tests are broken because they need envvars but they shouldnt please help fix&quot;,
		&quot;test:unit-with-envvars-please-fixme&quot;: &quot;vitest --run src/{**/,}*.test.ts --exclude=**/test-{integration,e2e}/**&quot;,
		&quot;test:integration&quot;: &quot;vitest --run src/**/test-integration/{**/,}*.test.ts&quot;,
		&quot;test:e2e&quot;: &quot;playwright test src/*/test-e2e/*.spec.ts&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/lib-infra&quot;: &quot;0.0.0&quot;,
		&quot;@anterior/lib-platform&quot;: &quot;0.0.0&quot;,
		&quot;@anthropic-ai/sdk&quot;: &quot;^0.39.0&quot;,
		&quot;@aws-sdk/client-s3&quot;: &quot;^3.782.0&quot;,
		&quot;@hono/node-server&quot;: &quot;^1.14.0&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@playwright/test&quot;: &quot;^1.50.1&quot;,
		&quot;@types/eslint&quot;: &quot;^9.6.0&quot;,
		&quot;@types/eslint__js&quot;: &quot;^8.42.3&quot;,
		&quot;@types/eslint-config-prettier&quot;: &quot;^6.11.3&quot;,
		&quot;@types/node&quot;: &quot;^22.13.11&quot;,
		&quot;copyfiles&quot;: &quot;^2.4.1&quot;,
		&quot;eslint&quot;: &quot;^9.9.0&quot;,
		&quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,
		&quot;pino-pretty&quot;: &quot;^11.3.0&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;,
		&quot;vitest&quot;: &quot;^3.1.1&quot;,
		&quot;zod&quot;: &quot;^3.24.2&quot;
	},
	&quot;trustedDependencies&quot;: [
		&quot;esbuild&quot;,
		&quot;msw&quot;,
		&quot;protobufjs&quot;,
		&quot;sqlite3&quot;
	]
}</file><file path="gateways/noggin/tsconfig.json">{
	// Root level tsconfig.json
	&quot;extends&quot;: &quot;../../tsconfig.json&quot;,
	&quot;include&quot;: [&quot;src/**/*&quot;],
	&quot;exclude&quot;: [
		// the file is so large that it causes the compiler to crash
		&quot;src/@anterior/models/data/fhir/r5/r5.ts&quot;
	],
	&quot;compilerOptions&quot;: {
		&quot;strictNullChecks&quot;: true,
		&quot;allowUnusedLabels&quot;: false,
		&quot;allowUnreachableCode&quot;: false,
		&quot;experimentalDecorators&quot;: true,
		&quot;emitDecoratorMetadata&quot;: true,
		&quot;noEmit&quot;: false,
		&quot;rewriteRelativeImportExtensions&quot;: true,
		&quot;outDir&quot;: &quot;dist&quot;
	}
}</file><file path="infra/cdktf/package.json">{
	&quot;name&quot;: &quot;ant-cdktf&quot;,
	&quot;version&quot;: &quot;1.0.0&quot;,
	&quot;main&quot;: &quot;app-platform.js&quot;,
	&quot;types&quot;: &quot;app-platform.ts&quot;,
	&quot;license&quot;: &quot;MPL-2.0&quot;,
	&quot;private&quot;: true,
	&quot;bin&quot;: {
		&quot;ant-cdktf&quot;: &quot;ant-cdktf&quot;,
		&quot;app-common&quot;: &quot;dist/app-common.js&quot;,
		&quot;app-empty&quot;: &quot;dist/app-empty.js&quot;,
		&quot;app-platform&quot;: &quot;dist/app-platform.js&quot;,
		&quot;app-secrets&quot;: &quot;dist/app-secrets.js&quot;
	},
	&quot;scripts&quot;: {
		&quot;get&quot;: &quot;cdktf get&quot;,
		&quot;build&quot;: &quot;tsc&quot;,
		&quot;synth&quot;: &quot;cdktf synth&quot;,
		&quot;compile&quot;: &quot;tsc --pretty&quot;,
		&quot;watch&quot;: &quot;tsc -w&quot;,
		&quot;test&quot;: &quot;jest&quot;,
		&quot;test:watch&quot;: &quot;jest --watch&quot;,
		&quot;upgrade&quot;: &quot;npm i cdktf@latest cdktf-cli@latest&quot;,
		&quot;upgrade:next&quot;: &quot;npm i cdktf@next cdktf-cli@next&quot;
	},
	&quot;engines&quot;: {
		&quot;node&quot;: &quot;&gt;=18.0&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@cdktf/provider-aws&quot;: &quot;19.61.0&quot;,
		&quot;cdktf&quot;: &quot;^0.20.8&quot;,
		&quot;cdktf-cli&quot;: &quot;^0.20.11&quot;,
		&quot;constructs&quot;: &quot;^10.3.0&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@types/jest&quot;: &quot;^29.5.12&quot;,
		&quot;@types/node&quot;: &quot;^22.1.0&quot;,
		&quot;jest&quot;: &quot;^29.7.0&quot;,
		&quot;ts-jest&quot;: &quot;^29.2.4&quot;,
		&quot;ts-node&quot;: &quot;^10.9.2&quot;,
		&quot;typescript&quot;: &quot;^5.5.4&quot;
	}
}</file><file path="lib/ts/lib-platform/src/app.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
import {
	App,
	createStaticApp,
	type EndpointSignature,
	type Procedure,
	type ServiceImplementation,
} from &quot;./app.ts&quot;;
import { BlobStore, toBlob } from &quot;./blob.ts&quot;;
import { InMemoryBlobStoreBackend, InMemoryLogger } from &quot;./in-memory.ts&quot;;
import type { Parser } from &quot;./types.ts&quot;;
import { z } from &quot;./zod.ts&quot;;
⋮----
interface PostHelloRequest {
		foo: number;
	}
interface TestService {
		GET: {
			&quot;/hello/:greetee&quot;: EndpointSignature&lt;null, { bar: string }&gt;;
		};
		POST: {
			&quot;/hello/:greetee&quot;: EndpointSignature&lt;PostHelloRequest, { bar: string }&gt;;
		};
		query: {
			getGreetings: Procedure&lt;null, { greetings: string[] }&gt;;
		};
	}
⋮----
type TestServiceWithExtraContext = {
			GET: {
				&quot;/test-use&quot;: EndpointSignature&lt;null, { foo: number; bar: string }&gt;;
			};
		};</file><file path="lib/ts/lib-platform/src/assoc.test.ts">import { describe } from &quot;vitest&quot;;
import { asAssocStoreBackend } from &quot;./assoc.contract.ts&quot;;
import { InMemoryAssocStoreBackend } from &quot;./in-memory.ts&quot;;</file><file path="lib/ts/lib-platform/src/blob.contract.ts">import { describe, expect, test } from &quot;./test.ts&quot;;
⋮----
import { Blob, type BlobStoreBackend, type ReadonlyBlobStoreBackend, toBlob } from &quot;./blob.ts&quot;;
import { generateRandomId } from &quot;./ids.ts&quot;;
⋮----
/**
 * To test readonly stores, we expect one specific key to be present:
 *
 * the-readonly-blobstore/test-key
 *
 * Which should be a blob with the text:
 *
 * This value exists just to satisfy the readonly blob contract.
 *
 * (Contrary to the read-write blobstore, we can&apos;t properly write random blobs here to read.)
 */
export function asReadonlyBlobStoreBackend(blobs: ReadonlyBlobStoreBackend)
⋮----
export function asBlobStoreBackend(blobs: BlobStoreBackend)
⋮----
// TODO add tests for mimetypes
⋮----
// TODO check if the url works.</file><file path="lib/ts/lib-platform/src/blob.test.ts">import { afterEach, describe, expect, test } from &quot;vitest&quot;;
import { asBlobStoreBackend, asReadonlyBlobStoreBackend } from &quot;./blob.contract.ts&quot;;
import {
	Blob,
	blobFromArrayBuffer,
	blobFromBase64,
	blobFromBuffer,
	blobFromPlainText,
	BlobStore,
	toBlob,
	toBlobResponse,
} from &quot;./blob.ts&quot;;
import { KeyMissingError, ParseError, Timeout } from &quot;./errors.ts&quot;;
import { generateRandomId } from &quot;./ids.ts&quot;;
import { InMemoryBlobStoreBackend, InMemoryLogger } from &quot;./in-memory.ts&quot;;</file><file path="lib/ts/lib-platform/src/body.ts">import { ConflictingArrayKeyError, IncorrectScalarKeyError, ParseError } from &quot;./errors.ts&quot;;
import type { POJO } from &quot;./types.ts&quot;;
⋮----
/**
 * Only support application/x-www-form-urlencoded and application/json for now
 * TODO support other content types, like text/plain, etc.
 */
export async function extractBody(req: Request): Promise&lt;POJO | null&gt;
⋮----
/**
 * Only supports one value per key for now
 */
export async function extractBodyFormData(req: Request): Promise&lt;POJO&gt;
⋮----
export async function extractBodyJSON(req: Request): Promise&lt;POJO&gt;
⋮----
// should we raise if content-length 0?
⋮----
/**
 * formDataFromEach – handles .forEach-able inputs with array folding
 * - First value -&gt; Scalar. Subsequent -&gt; Error: IncorrectScalarKey
 * - Handles array values if key ends with &quot;[]&quot; suffix (e.g., &quot;foo[]&quot;)
 * - Array keys are stored without the &quot;[]&quot; suffix in the result
 * - Throws on conflicting keys (foo + foo[])
 *
 * NB: The return type is kind of incorrect, because it&apos;s only U[] if the
 *     key is an array key. It is very tricky for this function to know
 *     whether the key is an array key or not, and needs hyper-typing.
 *
 * Examples:
 * |----------------------|------------------------------------|
 * | Input                | Output                             |
 * |----------------------|------------------------------------|
 * | foo=a                | { foo: &quot;a&quot; }                       |
 * | foo=a, foo=b         | Error: IncorrectScalarKeyError     |
 * | foo[]=a              | { foo: [&quot;a&quot;] }               	   	 |
 * | foo[]=a, foo[]=b     | { foo: [&quot;a&quot;,&quot;b&quot;] }                 |
 * | foo=a, foo[]=b       | Error: ConflictingArrayKey         |
 * | foo[]=a, foo=b       | Error: ConflictingArrayKey         |
 * |----------------------|------------------------------------|
 */
export function formDataFromEach&lt;K extends string, T, U = T&gt;(
	o: { forEach: (f: (v: T, k: K) =&gt; void) =&gt; void },
	t: (v: T, k: K) =&gt; U = (x) =&gt; x as unknown as U,
): Record&lt;K, U | U[]&gt;
⋮----
// Detect conflicting keys
⋮----
// Track key occurrence and check emptiness
⋮----
// canonical key = &quot;foo&quot; even if &quot;foo[]&quot;
⋮----
// Build result
⋮----
// 2nd or more time seeing the key
⋮----
// Scalar key was found to be an array key later
⋮----
// Array key was found to be a scalar key later
⋮----
// Scalar key attempted to be treated like an array key
⋮----
// First time seeing the key</file><file path="lib/ts/lib-platform/src/config.ts">export function getConfig&lt;K extends string&gt;(vars:
⋮----
// TODO proper errors or use zod or something off the shelf
⋮----
/**
 * All flags are false by default, and can be set to true by setting the env var to &quot;true&quot;
 * Any other value will crash the program
 */
export function getFlags&lt;K extends string&gt;(flags: K[]):</file><file path="lib/ts/lib-platform/src/cors.test.ts">import { expect, test } from &quot;vitest&quot;;
import { allowOrigins } from &quot;./cors.ts&quot;;</file><file path="lib/ts/lib-platform/src/errors.ts">import { Logger } from &quot;./log.ts&quot;;
⋮----
export class DeliberatelyUnimplementedError extends Error
⋮----
constructor()
⋮----
/**
 * Public exceptions are visible to users, their messages relayed in responses.
 */
// TODO actually use this as intended or scrap it
export class PublicError extends Error
⋮----
export class ErrorWrapper extends Error
⋮----
constructor(cause: unknown)
⋮----
// TODO Some kind of message?
⋮----
// Might be getting ahead of myself here, but if we use them often in many places this could be
// nice.
static invoke&lt;T&gt;(callback: () =&gt; T): T
⋮----
static async await&lt;T&gt;(promise: Promise&lt;T&gt;): Promise&lt;T&gt;
⋮----
// TODO Some of these are user errors (400s) others are server errors (500s). We want to make that
// explicit
export class KeyMissingError extends Error
export class KeyAlreadyExistsError extends Error
⋮----
type AsyncMethod&lt;T extends any[], R, This&gt; = (this: This, ...args: T) =&gt; Promise&lt;R&gt;;
⋮----
/**
 * A timeout error is thrown when a promise takes longer than a certain amount of time to resolve.
 */
export class Timeout extends Error
⋮----
constructor(
		public readonly ms: number,
		message: string,
)
wrap&lt;T&gt;(promise: Promise&lt;T&gt;): Promise&lt;T&gt;
⋮----
export function timeout&lt;
	Prop extends string,
	A extends any[],
	T,
	C extends { [K in `${Prop}TimeoutMs`]: number } &amp; { logger: Logger },
	M extends AsyncMethod&lt;A, T, C&gt;,
&gt;(target: C, prop: Prop, descriptor: TypedPropertyDescriptor&lt;M&gt;)
⋮----
// This check failed in the vcr test running with vitest, but not with bun:test.
// I don&apos;t know why and this will come to bite us at some point @jkz 2025-02
⋮----
/**
 * Thrown as a result of failed parsing. This would indicate some sort of malformed data provided by
 * the user and result in a 400 response
 *
 * NOTE These could theoretically be thrown for mismatched versions of data which wouldn&apos;t be the
 * user&apos;s fault. It is up to the parsing context to cause a 500.
 */
export class ParseError extends ErrorWrapper
⋮----
/**
 * Thrown when a key intended for a scalar is found to be an array key during parsing.
 */
export class IncorrectScalarKeyError extends ParseError
⋮----
constructor(key: string)
⋮----
/**
 * Thrown when a key is both a scalar and an array key during parsing.
 */
export class ConflictingArrayKeyError extends ParseError
⋮----
/**
 * Thrown when a key is empty during parsing.
 */
export class EmptyKeyValueError extends ParseError
⋮----
/**
 * Thrown as a result of failed (de)serialization. This would indicate some sort of malformed data
 * in our systems that past parsing, and wouldn&apos;t be the user&apos;s fault. Should generally produce a
 * 500 response.
 */
export class SerializerError extends ErrorWrapper
⋮----
/**
 * Thrown as a result of a failed permission check. Should generally produce a 403 response.
 */
export class Unauthorized extends ErrorWrapper</file><file path="lib/ts/lib-platform/src/flows.ts">import { z } from &quot;zod&quot;;
import { ParseError } from &quot;./errors.ts&quot;;
import { Logger } from &quot;./log.ts&quot;;
import type { MessageQueue } from &quot;./queue.ts&quot;;
import { getZod, type Schema, type SchemaLike, toSchema } from &quot;./schema.ts&quot;;
⋮----
export interface FlowParams {
	readonly flowName: string;
}
⋮----
export interface FlowEnvelope&lt;P extends FlowParams&gt; {
	// This TS code is currently only compatible with prefect. Brrr support to follow. - 2025/05.
	//
	// 💩 This is a smell because `lib-platform` should be dependency-injected
	// Specifically, only `lib-infra` should know the names and specifics of which workflow engines exist.
	// `lib-platform` should take in a generic `WorkflowEngine` string, and expect that the caller will
	// ensure an implementation of `WorkflowEngine` exists for that string.
	readonly workflow_engine: &quot;prefect&quot;;
	readonly workflow_name: string;
	readonly deduplication_id: string;
	readonly flow_run_name?: string;
	readonly parameters: {
		readonly flow_input: P;
	};
}
⋮----
// This TS code is currently only compatible with prefect. Brrr support to follow. - 2025/05.
//
// 💩 This is a smell because `lib-platform` should be dependency-injected
// Specifically, only `lib-infra` should know the names and specifics of which workflow engines exist.
// `lib-platform` should take in a generic `WorkflowEngine` string, and expect that the caller will
// ensure an implementation of `WorkflowEngine` exists for that string.
⋮----
// TODO we are in the process of moving the workflow name into the flow params,
// so they are tightly coupled. That will also help with setting up the discriminated union
export function toFlowSchema&lt;P extends FlowParams&gt;(
	schemaLike: SchemaLike&lt;P&gt;,
): Schema&lt;FlowEnvelope&lt;P&gt;&gt;
⋮----
export class FlowScheduler&lt;P extends FlowParams&gt;
⋮----
constructor(
		private readonly logger: Logger,
		private readonly queue: MessageQueue&lt;FlowEnvelope&lt;P&gt;&gt;,
		private readonly paramsSchema: SchemaLike&lt;P&gt;,
)
⋮----
async schedule&lt;TParams extends P&gt;(parameters: TParams): Promise&lt;void&gt;
⋮----
// ...parameters,</file><file path="lib/ts/lib-platform/src/ids.test.ts">import { expect, test } from &quot;vitest&quot;;
import { generateDeterministicId, generateRandomId } from &quot;./ids.ts&quot;;</file><file path="lib/ts/lib-platform/src/ids.ts">import { createHash, randomBytes } from &quot;node:crypto&quot;;
import { z } from &quot;./zod.ts&quot;;
⋮----
// TODO include prefix in type
export type Id&lt;T extends string = string&gt; = `${T}_${string}`;
⋮----
export const idSchema = &lt;T extends string&gt;(prefix: T)
⋮----
function toId&lt;T extends string&gt;(hex: string, typeIdentifier: T, prefix = &quot;&quot;): Id&lt;T&gt;
⋮----
export function generateDeterministicId&lt;T extends string&gt;(
	typeIdentifier: T,
	hashKey: string,
	prefix?: string,
): Id&lt;T&gt;
⋮----
export function generateRandomId&lt;T extends string&gt;(typeIdentifier: T, prefix?: string): Id&lt;T&gt;</file><file path="lib/ts/lib-platform/src/invariant.ts">// Adapted from https://github.com/alexreardon/tiny-invariant/blob/b5587cf4ba45e257bce49053c3345b6614324252/src/tiny-invariant.ts
⋮----
import { logger as baseLogger, type Logger } from &quot;./log.ts&quot;;
⋮----
/**
 * `invariant` is used to [assert](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions) that the `condition` is [truthy](https://github.com/getify/You-Dont-Know-JS/blob/bdbe570600d4e1107d0b131787903ca1c9ec8140/up%20%26%20going/ch2.md#truthy--falsy).
 *
 * 💥 `invariant` will `throw` an `Error` if the `condition` is [falsey](https://github.com/getify/You-Dont-Know-JS/blob/bdbe570600d4e1107d0b131787903ca1c9ec8140/up%20%26%20going/ch2.md#truthy--falsy)
 *
 * @example
 *
 * ```ts
 * const value: Person | null = { name: &apos;Alex&apos; };
 * invariant(value, &apos;Expected value to be a person&apos;);
 * // type of `value`` has been narrowed to `Person`
 * ```
 */
export default function invariant(
	condition: unknown,
	/**
	 * Can provide a string, or a function that returns a string for cases where
	 * the message takes a fair amount of effort to compute
	 */
	message: string | (() =&gt; string),
	/**
	 * Can provide a record of attributes to be logged alongside the error message
	 */
	attributes?: Record&lt;string, unknown&gt; | (() =&gt; Record&lt;string, unknown&gt;),
	/**
	 * A logger to use for logging the error message
	 */
	logger?: Logger,
): asserts condition
⋮----
/**
	 * Can provide a string, or a function that returns a string for cases where
	 * the message takes a fair amount of effort to compute
	 */
⋮----
/**
	 * Can provide a record of attributes to be logged alongside the error message
	 */
⋮----
/**
	 * A logger to use for logging the error message
	 */
⋮----
// Condition not passed</file><file path="lib/ts/lib-platform/src/json.test.ts">import { describe, expect, it } from &quot;vitest&quot;;
import json, { type ParseReviver } from &quot;./json.ts&quot;;
⋮----
// Note that `fuzzyPath` is not provided,
// so converting &quot;2&quot; to 2n won&apos;t work
⋮----
// Testing that we can apply several revival transformations
⋮----
// This is the same as above, but checking order of revivers don&apos;t matter
⋮----
// This is the same as above, but checking order of revivers does matter
// since it doesn&apos;t make sense to access a Set by index
⋮----
const prependKeyReviver = (prepend: string) =&gt;
⋮----
// Don&apos;t prepend the key if it&apos;s a fuzzy path
⋮----
// Making a new variable so that multiple empty keys don&apos;t add unnecessary dots
⋮----
// We may need to add dot-separation</file><file path="lib/ts/lib-platform/src/json.ts">import invariant from &quot;./invariant.ts&quot;;
⋮----
function isPlainObject(obj: unknown): obj is Record&lt;string, unknown&gt;
⋮----
function serializeRepeated&lt;T&gt;(
	open: string,
	close: string,
	iter: Iterable&lt;T&gt;,
	serializeOne: (elem: T) =&gt; string,
): string
⋮----
function serializeIterable(i: Iterable&lt;unknown&gt;): string
⋮----
/**
 * Serialize a map-like object.
 *
 * Will throw an error if any key is not a string (which it must be according to
 * the JSON spec).
 */
function serializeMapping(entries: Iterable&lt;[string, unknown]&gt;): string
⋮----
/**
 * Serialize arbitrary object to JSON on the given write stream.
 *
 * Basically a reimplementation of JSON.stringify. Why? Mostly to support some
 * custom datatypes which you absolutely cannot do with JSON.stringify, no
 * matter how hard you try: bigint, Map, and Set.
 */
function serialize(o: unknown): string
⋮----
// This is the real reason we&apos;re reimplementing JSON.stringify.
// Making it is a string so that when parsing, we maintain the same precision
⋮----
// This is another reason we&apos;re doing this.
⋮----
// If it isn&apos;t an object by now then I don&apos;t know what it is and it&apos;s fine by
// me if it crashes and burns.
⋮----
type ParseReviverOptions = {
	key: string;
	type: &quot;undefined&quot; | &quot;BigInt&quot; | &quot;Map&quot; | &quot;Set&quot;;
	fuzzyPath?: boolean;
};
type ParseReviver = Array&lt;ParseReviverOptions&gt;;
⋮----
type Parent = Record&lt;string, unknown&gt; | unknown[] | Set&lt;unknown&gt; | Map&lt;unknown, unknown&gt;;
/**
 * Get the value at the given path in the given object.
 * Cannot give an empty path to this function.
 */
function getValueByPath(
	value: unknown,
	path: string,
):
⋮----
// Check that we are still going to be able to access the value
// If not, early return because this path is not applicable
⋮----
// Handle array index access
⋮----
const index = parseInt(part, 10); // Force to base 10
⋮----
// Can&apos;t access array index on non-array
⋮----
// Reached the last part of the `path`, return the value found
⋮----
// Continue to the next part of the path
⋮----
// Continue to the next part of the path
⋮----
// Can&apos;t access object property on non-object
⋮----
// Reached the last part of the `path`, return the value found
⋮----
// Continue to the next part of the path
⋮----
/**
 * The actual transformation to the expected type.
 */
function transformValue(value: unknown, parseType: ParseReviverOptions[&quot;type&quot;])
⋮----
/**
 * Parse arbitrary JSON string to JS objects / primitives.
 *
 * Basically a reimplementation of JSON.parse. Why? Mostly to support some
 * custom datatypes which you absolutely cannot do with JSON.parse, no
 * matter how hard you try: bigint, Map, and Set.
 *
 * The chosen API for reviving is different from the built-in reviver method exposed by JSON.parse.
 * The correspondng `serialize` method does NOT save any metadata about which fields are BigInts, Maps, or Sets.
 * This means that just calling `parse` without any additional metadata cannot restore the original object.
 *
 * So, when calling `parse` when the original object contains BigInts, Maps, or Sets, you need to pass the metadata as well.
 * You may not care where a certain property is located, and in those cases, you can set `fuzzyPath` to true.
 * The order of revivers can matter, especially because you can&apos;t access a Set by index.
 *
 * @example
 * ```ts
 * json.parse(&apos;&quot;{&quot;foo&quot;: { &quot;createdAt&quot;: &quot;1732104382713939039&quot; } }&quot;&apos;, [{ &quot;key&quot;: &quot;createdAt&quot;, &quot;type&quot;: &quot;BigInt&quot;, &quot;fuzzyPath&quot;: true }])
 *
 * json.parse(&apos;&quot;{&quot;foo&quot;: { &quot;createdAt&quot;: &quot;1732104382713939039&quot; } }&quot;&apos;, [{ &quot;key&quot;: &quot;foo.createdAt&quot;, &quot;type&quot;: &quot;BigInt&quot; }])
 *
 * json.parse(&apos;&quot;{&quot;fizz&quot;: &quot;buzz&quot; }&quot;&apos;, [{ &quot;key&quot;: &quot;&quot;, &quot;type&quot;: &quot;Map&quot; }])
 * ```
 */
function parse(s: string, parseReviver: ParseReviver = []): unknown
⋮----
// Handle fuzzy path matching
⋮----
// We&apos;re asked to do exact path matching, for which we need the entire parsed JS object
// JSON.parse callback only gives the entire parsed JS object if the key is &quot;&quot;
⋮----
// If the value to change is the root object, transform it directly
⋮----
// The path doesn&apos;t exist in this value, so skip this parseKey
⋮----
// Update the value in the original object if there is a parent
⋮----
const index = parseInt(pathResult.key, 10); // Force to base 10</file><file path="lib/ts/lib-platform/src/jwt.ts">import { appApiV1RefreshToken200Response } from &quot;@anterior/openapi/client/version1/version1.zod&quot;;
import type { Context as HonoContext, Next } from &quot;hono&quot;;
import { HTTPException } from &quot;hono/http-exception&quot;;
import { jwt, verify } from &quot;hono/jwt&quot;;
import { z } from &quot;zod&quot;;
import { Unauthorized } from &quot;./errors.ts&quot;;
import { logger } from &quot;./log.ts&quot;;
⋮----
/**********************************************************************************************
 * Auth Config
 * - if any noggin app implements auth, it must provide this configuration
 *********************************************************************************************/
export interface AuthConfig {
	jwtSecret: string;
	tokenRefreshEndpoint: string;
	redirectUrl: string;
	apiKeyHeader: &quot;x-api-key&quot;;

	//todo: @asim / @jesse
	//remove this once we have a more reliable solution for resolving
	//api keys to machine users

	apiBaseUrl__smellsBad: string;
}
⋮----
//todo: @asim / @jesse
//remove this once we have a more reliable solution for resolving
//api keys to machine users
⋮----
/**********************************************************************************************
 * When using API keys, we decode &apos;machine&apos; information from a given API key
 * some interfaces and schemas to represent a &apos;machine&apos; user.
 *
 * We&apos;re hitting a &quot;temporary&quot; API /auth/machines/requesting to decipher this info from
 * an api key.
 *********************************************************************************************/
⋮----
// machine
export interface MachineConfig {
	apiKey: string;
	createdAt: string;
	enterpriseUid: string;
	lastLoginAt: string;
	machineUid: string;
	name: string;
	role: string;
	updatedAt: string;
	userUid: string;
	workspaceUid: string;
}
⋮----
// schema to validate a machine
⋮----
// response of the API /auth/machines/requesting
export interface MachineResponse {
	machine: MachineConfig;
}
⋮----
// schema to validate api response
⋮----
/**********************************************************************************************
 * In addition to API keys, one can authenticate using the login form. That drops a JWT as a
 * cookie. Some interfaces to represent JWT payloads
 *********************************************************************************************/
⋮----
// type for JWT payloads
export type JWTPayload = {
	entr: Record&lt;string, string&gt;; // &lt;enterpriseUid, role&gt;
	wksp: Record&lt;string, string&gt;; // &lt;workspaceUid, enterpriseUid&gt;
	sub: string;
};
⋮----
entr: Record&lt;string, string&gt;; // &lt;enterpriseUid, role&gt;
wksp: Record&lt;string, string&gt;; // &lt;workspaceUid, enterpriseUid&gt;
⋮----
// schmea for JWT payloads
⋮----
entr: z.record(z.string()), // maps enterpriseUid to role
wksp: z.record(z.string()), // maps workspaceUid to enterpriseUid
⋮----
/***********************************************************************************************
 * @param apiKey the API key sent in the request
 * @param apiBaseUrl__smellsBad the base url for API /auth/machines/requesting endpoint
 * @returns Machine
 ***********************************************************************************************/
const readMachineInfoForApiKey = async (apiKey: string, apiBaseUrl__smellsBad: string) =&gt;
⋮----
//todo: @asim / @saul, currently, we&apos;re opting to proxy calls to the user
//service (grpc) via an endpoint on the public API /auth/machines/requesting
//this will be revised, once we move the entire user service into typescript
⋮----
/***********************************************************************************************
 * @param jwtPayload the JWT to parse
 * @param req the raw Request object
 * @returns {enterpriseUid, userUid, role, workspaceUid}
 ***********************************************************************************************/
const parseEnterpriseUserFromJwt = (jwtPayload: JWTPayload, req: Request) =&gt;
⋮----
// Get enterprise and user uids from the token.
⋮----
// Most tokens will have a single enterprise.
⋮----
// If token contains multiple enterprises.
// First check for the X-Anterior-Enterprise-Id header.
⋮----
// Use the first enterprise in the map (random).
⋮----
// Get workspaceUid from claims or header if present.
⋮----
// Token has a single workspace.
⋮----
// Token claims contain multiple workspaces. Look for
// the X-Anterior-Workspace-Id header.
⋮----
/***********************************************************************************************
 * @param machine the MachineConfig to parse
 * @returns {enterpriseUid, userUid, role, workspaceUid}
 ***********************************************************************************************/
const parseEnterpriseUserFromMachine = (machine: MachineConfig) =&gt;
⋮----
/***********************************************************************************************
 * note on the logic here:
 *
 * `API KEY check`
 * - take the request context, check for an API key
 * - if found, great, use the API key to resolve a &apos;machine&apos;
 * -parse the machine config to get ent, wks, usr and role -&gt; c.set(&apos;auth&apos;)
 *
 * `JWT Check`
 * - if the api key was not present, look for &quot;access_token&quot; (JWT)
 * - validate that JWT using our jwtSecret
 * - if that is valid, parse out the ent, wks, usr and role info from the jwt -&gt; c.set(&apos;auth&apos;)
 *
 * In either case, if the user&apos;s auth is valid, a property `auth` will be set on the context
 * before proceeding forward `next()`
 *
 * This middleware will reject requests that don&apos;t have either an API key or JWT
 *
 * @param cfg AuthConfig for this app
 * @returns a hono middleware that can authenticate a request using either API keys or JWTs
 ***********************************************************************************************/
export function authMiddleware(cfg: AuthConfig)
⋮----
// try to check if auth can be handled using an API key first
⋮----
// great, auth completed via API key, short circuit the rest
⋮----
// API key based auth unsuccessful
// let&apos;s try to auth via JWT
⋮----
// validate the jwt (cryptographically) -- this will throw an error
// if the jwt is not valid
⋮----
// great, the jwt is valid, let&apos;s read that JWT payload, parse it
// and attach it as &quot;auth&quot; on the context
⋮----
// jwt validation failed and we got a 401, let&apos;s attempt to
// refresh our token</file><file path="lib/ts/lib-platform/src/kv.ts">import { KeyMissingError, ParseError, SerializerError, timeout } from &quot;./errors.ts&quot;;
import { Logger } from &quot;./log.ts&quot;;
import type { Schema } from &quot;./schema.ts&quot;;
import type { Serializer } from &quot;./serializer.ts&quot;;
import type { POJO } from &quot;./types.ts&quot;;
⋮----
/**
 * A Key Value store provides a simple key-value abstraction.
 * It provides the following guarantees:
 * - Schema validated: Values are validated against
 * - Stores valid json objects
 *
 * And the following defaults. We can figure out what the right numbers should be for these.
 * - Get Timeout: 50ms
 * - Set Timeout: 100ms
 *
 * Features we may want:
 * - Immutable values
 * - Versioned values
 *
 * The KV provides validation and proper error signaling.
 * To make this possible, every KV needs to be instantiated with its own validator.
 * We can do this be several ways:
 * - Writing them by hand and exposing them in libraries
 * - Generating them based on schemas
 * - Using TypeScript&apos;s type system and don&apos;t actually validate behind the scenes
 *
 * Deletes are currently omitted by the interface. We can discuss adding them
 * if a production use case arises.
 */
export interface KVStore&lt;T&gt; {
	readonly schema: Schema&lt;T&gt;;
	readonly serializer: Serializer&lt;T, POJO&gt;;
	/**
	 * Throws:
	 * - KeyMissingError
	 * - Timeout
	 * - BackendError
	 * - ParseError
	 */
	get(key: string): Promise&lt;T&gt;;
	/**
	 * Throws:
	 * - Timeout
	 * - BackendError
	 * - ParseError
	 */
	set(key: string, val: T): Promise&lt;void&gt;;
}
⋮----
/**
	 * Throws:
	 * - KeyMissingError
	 * - Timeout
	 * - BackendError
	 * - ParseError
	 */
get(key: string): Promise&lt;T&gt;;
/**
	 * Throws:
	 * - Timeout
	 * - BackendError
	 * - ParseError
	 */
set(key: string, val: T): Promise&lt;void&gt;;
⋮----
export class KVStore&lt;T&gt;
⋮----
constructor(
⋮----
async get(key: string): Promise&lt;T&gt;
⋮----
async set(key: string, value: T): Promise&lt;void&gt;
⋮----
async delete(key: string): Promise&lt;void&gt;
⋮----
/**
 * The Backend provides the raw infra abstraction for the KV.
 * Setting it up this way separates the internal interface, using KV in our codebase,
 * from the infra implemenations, so we can swap out backends without touching any business code.
 *
 * One difference is that the KVStore backend does no validation, while the KV backend does.
 */
export interface KVStoreBackend {
	get(key: string): Promise&lt;POJO | undefined&gt;;
	set(key: string, val: POJO): Promise&lt;void&gt;;
	delete(key: string): Promise&lt;void&gt;;
}
⋮----
get(key: string): Promise&lt;POJO | undefined&gt;;
set(key: string, val: POJO): Promise&lt;void&gt;;
delete(key: string): Promise&lt;void&gt;;</file><file path="lib/ts/lib-platform/src/object.ts">/**
 * A helper to shrink an object down to only the specified keys.
 * At the moment, this sets missing keys to undefined. Arguably it should throw.
 */
export function only&lt;T, K1 extends keyof T&gt;(obj: T, k1: K1):
export function only&lt;T, K1 extends keyof T, K2 extends keyof T&gt;(
	object: T,
	k1: K1,
	k2: K2,
):
export function only&lt;T, K1 extends keyof T, K2 extends keyof T, K3 extends keyof T&gt;(
	object: T,
	k1: K1,
	k2: K2,
	k3: K3,
):
export function only&lt;
	T,
	K1 extends keyof T,
	K2 extends keyof T,
	K3 extends keyof T,
	K4 extends keyof T,
&gt;(
	object: T,
	k1: K1,
	k2: K2,
	k3: K3,
	k4: K4,
):
export function only&lt;
	T,
	K1 extends keyof T,
	K2 extends keyof T,
	K3 extends keyof T,
	K4 extends keyof T,
	K5 extends keyof T,
&gt;(
	object: T,
	k1: K1,
	k2: K2,
	k3: K3,
	k4: K4,
	k5: K5,
):
export function only&lt;
	T,
	K1 extends keyof T,
	K2 extends keyof T,
	K3 extends keyof T,
	K4 extends keyof T,
	K5 extends keyof T,
	K6 extends keyof T,
&gt;(
	object: T,
	k1: K1,
	k2: K2,
	k3: K3,
	k4: K4,
	k5: K5,
	k6: K6,
):
export function only(obj: any, ...keys: string[]): object
⋮----
export function without&lt;T extends string, O extends Record&lt;string, any&gt;&gt;(
	obj: O,
	...keys: T[]
): Omit&lt;O, T&gt;
⋮----
type SnakeToCamelCase&lt;S extends string&gt; = S extends `${infer T}_${infer U}`
	? `${T}${Capitalize&lt;SnakeToCamelCase&lt;U&gt;&gt;}`
	: S;
⋮----
type CamelCaseKeys&lt;T&gt; =
	T extends Array&lt;any&gt;
		? Array&lt;CamelCaseKeys&lt;T[number]&gt;&gt;
		: T extends object
			? {
					[K in keyof T as SnakeToCamelCase&lt;string &amp; K&gt;]: CamelCaseKeys&lt;T[K]&gt;;
				}
			: T;
⋮----
type CamelToSnakeCase&lt;S extends string&gt; = S extends `${infer T}${infer U}`
	? `${T extends Capitalize&lt;T&gt; ? &quot;_&quot; : &quot;&quot;}${Lowercase&lt;T&gt;}${CamelToSnakeCase&lt;U&gt;}`
	: &quot;&quot;;
⋮----
type SnakeCaseKeys&lt;T&gt; =
	T extends Array&lt;any&gt;
		? Array&lt;SnakeCaseKeys&lt;T[number]&gt;&gt;
		: T extends object
			? {
					[K in keyof T as CamelToSnakeCase&lt;`${string &amp; K}`&gt;]: SnakeCaseKeys&lt;T[K]&gt;;
				}
			: T;
⋮----
// &quot;Test cases&quot;
type foo = SnakeCaseKeys&lt;{ fooBar: string; barBaz: { quxQuux: string } }&gt;;
type bar = CamelCaseKeys&lt;{ foo_bar: string; bar_baz: { qux_quux: string } }&gt;;
⋮----
export function camelCase(str: string): string
⋮----
export function snakeCase(str: string): string
⋮----
export function recursiveCamelCase&lt;T&gt;(data: T): CamelCaseKeys&lt;T&gt;
⋮----
export function recursiveSnakeCase&lt;T&gt;(data: T): SnakeCaseKeys&lt;T&gt;
⋮----
export function mapValues&lt;K extends string, T, U&gt;(o: Record&lt;K, T&gt;, f: (a: T) =&gt; U): Record&lt;K, U&gt;
⋮----
// TS doesn&apos;t understand galaxy brain
⋮----
export function fromEach&lt;K extends number | string | symbol, T, U = T&gt;(o: {
forEach: (f: (v: T, k: K)
export function fromEach&lt;K extends number | string | symbol, T, U&gt;(
	o: { forEach: (f: (v: T, k: K) =&gt; void) =&gt; void },
	t: (v: T, k: K) =&gt; U,
): Record&lt;K, U&gt;;
export function fromEach&lt;K extends number | string | symbol, T, U&gt;(
	o: { forEach: (f: (v: T, k: K) =&gt; void) =&gt; void },
	t: (...args: any[]) =&gt; U = (x) =&gt; x,
): Record&lt;K, U&gt;</file><file path="lib/ts/lib-platform/src/projector.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
import { z } from &quot;zod&quot;;
import { ParseError, SerializerError, Timeout } from &quot;./errors.ts&quot;;
import {
	createTestEventStores,
	type Create,
	type EventPayload,
	type Meta,
	type TestEvent,
	type Update,
} from &quot;./events.test.ts&quot;;
⋮----
import { Projector } from &quot;./projector.ts&quot;;
import { type SchemaLike } from &quot;./schema.ts&quot;;
⋮----
interface State {
	value: string;
	count: number;
	createdBy: string;
}
⋮----
export function unpack(e: TestEvent):
⋮----
// // TODO zod is not the best tool for this. We need to validate, not parse the object here.
// // const schema = toEventSchema&lt;EventPayload, Meta, TestEvent&gt;(payloadSchema, metaSchema);
// const schema = z.object({
// 	...metaSchema.shape,
// 	data: payloadSchema,
// })
⋮----
// TODO I didn&apos;t test all the error cases exhaustively yet. Maybe we should, but I want
// to get some code merged first @jkz 2024-11-07</file><file path="lib/ts/lib-platform/src/projector.ts">import { toSchema, type Schema, type SchemaLike } from &quot;./schema.ts&quot;;
⋮----
export interface IProjector&lt;T, E&gt; {
	project(events: E[]): T;
	updateProjection(state: T, event: E): void;
}
⋮----
project(events: E[]): T;
updateProjection(state: T, event: E): void;
⋮----
/**
 * The projector interface is simple to hide all the gory details of payloads
 * and metadata which the event store does not need to know about
 */
export class Projector&lt;
⋮----
// Metadata is present on every event, typed separate from the payload
⋮----
// Payload is a union type with a discriminator field
⋮----
// Initializers are the special events that can produce a new state.
// When set to null, there is a valid empty state.
⋮----
constructor(
		private readonly kwargs: {
			schema: SchemaLike&lt;TProjection&gt;;
readonly unpack: (event: TEvent) =&gt;
⋮----
// A note on using object/record for this type; For event names that match any properties on the object prototype chain,
// this can cause trouble. A better data structure would be a Map, but that would require a bunch of complexity to get
// the key, value pairs typed correctly
⋮----
// TODO do wew want the event arg to match {payload, meta} here?
⋮----
createProjection(event: TEvent): TProjection
⋮----
// TODO get rid of this any?
⋮----
updateProjection(proj: TProjection, event: TEvent): void
⋮----
// TODO get rid of this any?
⋮----
// NOTE: we could add a mode where this is an error not to have a handler
⋮----
project(events: TEvent[]): TProjection
⋮----
// Either the projection has an empty state defined
⋮----
// Or the first event must be an initializer
⋮----
// TODO perhaps we want a debug mode where we parse every time so we can catch errors
// as soon as they happen</file><file path="lib/ts/lib-platform/src/queue.ts">import { timeout } from &quot;./errors.ts&quot;;
import { Logger } from &quot;./log.ts&quot;;
import type { Schema } from &quot;./schema.ts&quot;;
import type { StoreSerializer } from &quot;./serializer.ts&quot;;
⋮----
// TODO haven&apos;t got too deep on this one, since we&apos;re not sure
// whether we want this abstraction exposed. It might also be one
// abstraction too many.
⋮----
/**
 * A message queue takes messages for asynchronous processing.
 *
 * Guarantees:
 * - At least once delivery
 * - Timeout for long running messages
 * - Dead letter queue for failed messages
 * - Schema validation
 *
 * Only implementing the enqueue end for now.
 */
export interface MessageQueue&lt;T&gt; {
	/**
	 * Throws:
	 * - Timeout (only for enqueueing, not for processing)
	 * - BackendError
	 * - SerializationError
	 * - ValidationError
	 */
	send(message: T): Promise&lt;void&gt;;
}
⋮----
/**
	 * Throws:
	 * - Timeout (only for enqueueing, not for processing)
	 * - BackendError
	 * - SerializationError
	 * - ValidationError
	 */
send(message: T): Promise&lt;void&gt;;
⋮----
export interface MessageQueueBackend&lt;T&gt; {
	send(message: T): Promise&lt;void&gt;;
}
⋮----
export class MessageQueueImpl&lt;TValue, TStore&gt;
⋮----
constructor(
⋮----
async send(message: TValue): Promise&lt;void&gt;</file><file path="lib/ts/lib-platform/src/schema.ts">import { z, type ZodDiscriminatedUnionOption, ZodObject, ZodType, type ZodTypeDef } from &quot;zod&quot;;
import { ParseError } from &quot;./errors.ts&quot;;
import { mapValues } from &quot;./object.ts&quot;;
⋮----
/**
 * All this type nonsense gives us the following:
 *
 * A single schema per discriminable union type with the following methods:
 * - parse: take an unknown object and return a valid object, or throw an error
 * 		e.g. taking external input
 * - create: take a presumed-valid object, and throw if it isn&apos;t, then return a valid object
 * 		e.g. creating events, when you want your IDE to help you
 *
 * Notably, it does not include
 * - validate: take an unknown object and throw if it isn&apos;t valid
 * 		e.g. internal input, when you don&apos;t want to create a new object
 *
 * See https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/ for an explanation of why we don&apos;t validate
 * The validation code is commented out in this file pending discussion
 *
 * We can use these flexibly in various places, for runtime type safety
 *
 * A few things to note:
 * - The zod definition (or the parser) shouldn&apos;t infer or convert types, and take them verbatim. We may enforce this later on, but for now we don&apos;t
 *
 *
 * TODO decide whether we allow inference on the parser
 * TODO decide whether we want to use zod, or something stricter, or with more jsonschema support, for instance
 * TODO consider throwing our own errors
 */
export interface Schema&lt;T&gt; {
	readonly [ZOD]: ZodType&lt;T&gt;;
	readonly parse: Parser&lt;T&gt;;
	readonly create: Creator&lt;T&gt;;
	// validate: Validator&lt;T&gt;
}
⋮----
// validate: Validator&lt;T&gt;
⋮----
export type SchemaLike&lt;T&gt; = SchemaDefinition&lt;T&gt; | Schema&lt;T&gt;;
⋮----
// These types illustrate platform semantics for their namesake terms.
// They should be used liberally throughout the codebase, to make it clear
// what is being done with the data at any given time.
⋮----
/**
 * Return an object of the given type, or throw.
 * Returns a deep copy of the object
 *
 * Throws
 * - ParseError
 */
export type Parser&lt;T&gt; = (obj: unknown) =&gt; T;
⋮----
// /**
//  * Throw if the given unknown object isn&apos;t of the given type
//  * The original object remains untouched
//  */
// export type Validator&lt;T&gt; = (obj: unknown) =&gt; asserts obj is T
export type Validator&lt;T&gt; = never;
⋮----
/**
 * Throw if the given object isn&apos;t of the given type, then return it.
 * The original object remains untouched
 * This is useful for compile time type checking with runtime guarantees
 * (As an optimisation we _could_ remove the checks at runtime)
 */
export type Creator&lt;T&gt; = (obj: T) =&gt; T;
⋮----
/**
 * With this symbol we discourage relying on zod directly outside of the schema definitions,
 * but offer the escape hatch if you really want to use it
 */
⋮----
export function getZod&lt;T&gt;(schema: SchemaLike&lt;T&gt;): ZodType&lt;T&gt;
⋮----
// TODO what to do if this is a lie?
⋮----
/**
 * Specifically one with a descriminator. May do a find replace later for a more expressive name
 */
export type Union&lt;D extends string, U extends { readonly [K in D]: U[D] }&gt; = {
	readonly [K in D]: U[D];
};
⋮----
/**
 * Right now we use zod under the hood, but we don&apos;t rely on it heavily, so we could swap it out.
 * More important are the semantics of the types, and the methods we provide.
 *
 * The triple T should make it so we don&apos;t allow any inference or conversion of types
 */
export type Zod&lt;T&gt; = ZodType&lt;T, ZodTypeDef, T&gt;;
export type SchemaDefinition&lt;T&gt; = Zod&lt;T&gt; | { fromJSON(obj: unknown): T };
⋮----
export type UnionSchemaDefinition&lt;D extends string, U extends Union&lt;D, U&gt;&gt; = {
	readonly [K in U[D]]: SchemaDefinition&lt;Extract&lt;U, { [_ in D]: K }&gt;&gt;;
};
type Foo = UnionSchemaDefinition&lt;&quot;type&quot;, { type: &quot;a&quot;; a: string } | { type: &quot;b&quot;; b: number }&gt;;
⋮----
export type UnionSchema&lt;D extends string, U extends Union&lt;D, U&gt;&gt; =
	// &amp; {[ZOD]?: ZodDiscriminatedUnion&lt;D, [ZodDiscriminatedUnionOption&lt;D&gt;, ...ZodDiscriminatedUnionOption&lt;D&gt;[]]&gt; }
	Schema&lt;U&gt; &amp; { [K in U[D]]: Schema&lt;Extract&lt;U, { [_ in D]: K }&gt;&gt; };
⋮----
// &amp; {[ZOD]?: ZodDiscriminatedUnion&lt;D, [ZodDiscriminatedUnionOption&lt;D&gt;, ...ZodDiscriminatedUnionOption&lt;D&gt;[]]&gt; }
⋮----
export function isZodType(obj: unknown): obj is ZodType&lt;unknown&gt;
⋮----
// TODO better please
⋮----
export function toSchema&lt;T&gt;(definition: SchemaLike&lt;T&gt;): Schema&lt;T&gt;
⋮----
// validate: toValidator(parse)
⋮----
export function toParser&lt;T&gt;(definition: SchemaDefinition&lt;T&gt;): Parser&lt;T&gt;
⋮----
? // Remove extra keys on objects
⋮----
export function toCreator&lt;T&gt;(parser: Parser&lt;T&gt;): Creator&lt;T&gt;
// function toValidator&lt;T&gt;(parser: Parser&lt;T&gt;): Validator&lt;T&gt; {
// 	return (obj: unknown) =&gt; {
// 		parser(obj)
// 	}
// }
⋮----
export function toUnionSchema&lt;D extends string, U extends Union&lt;D, U&gt;&gt;(
	discriminator: D,
	definition: UnionSchemaDefinition&lt;D, U&gt;,
): UnionSchema&lt;D, U&gt;
⋮----
// Cheating a bit, but we have enough type and test coverage to be confident
⋮----
// TODO Work out this type stuff.
// const zod = z.object({}).passthrough() as any;</file><file path="lib/ts/lib-platform/src/secrets.test.ts">import { describe, expect, test, vi } from &quot;vitest&quot;;
import { Secret, getSecrets } from &quot;./secrets.ts&quot;;</file><file path="lib/ts/lib-platform/src/serializer.ts">import { SerializerError } from &quot;./errors.ts&quot;;
import json from &quot;./json.ts&quot;;
import { recursiveCamelCase, recursiveSnakeCase } from &quot;./object.ts&quot;;
import type { POJO } from &quot;./types.ts&quot;;
⋮----
/**
 * The serializer&apos;s only job is to convert between a value&apos;s type and the store&apos;s backend representation.
 * No validation needs be done here. Examples would be JSON serialization or dynamo db objects.
 *
 * Throws SerializerError
 */
export class Serializer&lt;TValue, TStore&gt;
⋮----
constructor(private implementation: TypedStoreSerializer&lt;TValue, TStore&gt;)
⋮----
// Bind the methods to the instance so we can have nice maps
⋮----
toStore(val: TValue): TStore
fromStore(val: TStore): TValue
⋮----
export interface TypedStoreSerializer&lt;TValue, TStore&gt; {
	toStore(val: TValue): TStore;
	fromStore(val: TStore): TValue;
}
⋮----
toStore(val: TValue): TStore;
fromStore(val: TStore): TValue;
⋮----
export interface StoreSerializer&lt;TStore&gt; extends TypedStoreSerializer&lt;unknown, TStore&gt; {}
⋮----
// TODO Eh.. this one is mainly for testing, although it could aslo be used as the default serializer
// It is a bit of a type cheat, so let&apos;s revisit when we have more concrete use cases.
⋮----
export const typedIdentitySerializer = &lt;T&gt;()
⋮----
// 🐫 🐍 🤪
⋮----
export const composeSerializers = &lt;TValue, TStore, TIntermediate&gt;(
	a: Serializer&lt;TValue, TIntermediate&gt;,
	b: Serializer&lt;TIntermediate, TStore&gt;,
): Serializer&lt;TValue, TStore&gt;
⋮----
/**
 * This one is for testing!
 */</file><file path="lib/ts/lib-platform/src/tasks.ts">import { Logger } from &quot;./log.ts&quot;;
import type { MessageQueue } from &quot;./queue.ts&quot;;
import { type Schema } from &quot;./schema.ts&quot;;
import type { POJO } from &quot;./types.ts&quot;;
⋮----
export class TaskScheduler&lt;TRaw&gt;
⋮----
constructor(
⋮----
async schedule&lt;TTask extends TRaw&gt;(task: TTask): Promise&lt;void&gt;
⋮----
// Not too happy about logging the whole task, but we can&apos;t assume any properties - jkz
⋮----
// Not too happy about logging the whole task, but we can&apos;t assume any properties - jkz</file><file path="lib/ts/lib-platform/src/url.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
import { ConflictingArrayKeyError, IncorrectScalarKeyError, ParseError } from &quot;./errors.ts&quot;;
import { createPathParamsExtractor, extractQuery, type ExtractParams } from &quot;./url.ts&quot;;
⋮----
function typeAssert&lt;T extends never&gt;()
type TypeEqualityGuard&lt;A, B&gt; = Exclude&lt;A, B&gt; | Exclude&lt;B, A&gt;;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
⋮----
// @ts-expect-error - zoop is not a valid param
⋮----
// @ts-expect-error - zoop is missing</file><file path="lib/ts/lib-platform/src/url.ts">import { ConflictingArrayKeyError, IncorrectScalarKeyError, ParseError } from &quot;./errors.ts&quot;;
import type { POJO, Path } from &quot;./types.ts&quot;;
⋮----
/**
 * This type turns this path string
 *
 * 	&quot;/foo/:bar/baz/:qux&quot;
 *
 * into this object type
 *
 * 	{ bar: string, qux: string }
 */
export type ExtractParams&lt;T extends string&gt; =
	T extends `${infer _Start}/:${infer Param}/${infer Rest}`
		? { [K in Param | keyof ExtractParams&lt;`/${Rest}`&gt;]: string }
		: T extends `${infer _Start}/:${infer Param}`
			? { [K in Param]: string }
			: // eslint-disable-next-line @typescript-eslint/no-empty-object-type
				{};
⋮----
: // eslint-disable-next-line @typescript-eslint/no-empty-object-type
⋮----
/**
 * This function creates a parser function that can extract parameter values from a path
 */
export function createPathParamsExtractor&lt;T extends Path&gt;(template: T)
⋮----
// Convert the template into a regex pattern that matches the placeholders
⋮----
// `/\/:([^\/]+)/g` regex captures route params in a URL pattern, specifically:
//  segments that start with a colon (:)
//  and continue until the next slash (/)
⋮----
return &quot;/([^/]+)&quot;; // Match anything except &apos;/&apos;
⋮----
// Create a regex with end anchors to match the path; there may be any number of prefix segments
⋮----
// Return a parser function that can match and extract values from a path
⋮----
// Create an object with parameter names as keys and matched values as values
// The first match is the full path, so start at index 1
⋮----
/**
 * When you pass in a Zod schema, make sure to use coerce on number fields
 * TODO: Only uses the last occurence for duplicates for now.
 * ?foo[1]=bar&amp;foo[2]=baz -&gt; { &quot;foo[1]&quot;: &quot;bar&quot;, &quot;foo[2]&quot;: &quot;baz&quot; }
 * ?foo=bar&amp;foo=baz -&gt; { &quot;foo&quot;: &quot;baz&quot; }
 */
export function extractQuery(req: Request): POJO
⋮----
/**
 * urlQueryParamsFromEach – handles .forEach-able inputs with array folding
 * - First value -&gt; Scalar. Subsequent -&gt; Error: IncorrectScalarKey
 * - Handles array values if key ends with &quot;[]&quot; suffix (e.g., &quot;foo[]&quot;)
 * - Array keys are stored without the &quot;[]&quot; suffix in the result
 * - Throws on conflicting keys (foo + foo[])
 *
 * NB: The return type is kind of incorrect, because it&apos;s only U[] if the
 *     key is an array key. It is very tricky for this function to know
 *     whether the key is an array key or not, and needs hyper-typing.
 *
 * Examples:
 * |----------------------|------------------------------------|
 * | Input                | Output                             |
 * |----------------------|------------------------------------|
 * | foo=a                | { foo: &quot;a&quot; }                       |
 * | foo=a, foo=b         | Error: IncorrectScalarKeyError     |
 * | foo[]=a              | { foo: [&quot;a&quot;] }               	   	 |
 * | foo[]=a, foo[]=b     | { foo: [&quot;a&quot;,&quot;b&quot;] }                 |
 * | foo=a, foo[]=b       | Error: ConflictingArrayKey         |
 * | foo[]=a, foo=b       | Error: ConflictingArrayKey         |
 * |----------------------|------------------------------------|
 */
export function urlQueryParamsFromEach&lt;K extends string, T, U = T&gt;(
	o: { forEach: (f: (v: T, k: K) =&gt; void) =&gt; void },
	t: (v: T, k: K) =&gt; U = (x) =&gt; x as unknown as U,
): Record&lt;K, U | U[]&gt;
⋮----
// Detect conflicting keys
⋮----
// Track key occurrence and check emptiness
⋮----
// canonical key = &quot;foo&quot; even if &quot;foo[]&quot;
⋮----
// Build result
⋮----
// 2nd or more time seeing the key
⋮----
// Scalar key was found to be an array key later
⋮----
// Array key was found to be a scalar key later
⋮----
// Scalar key attempted to be treated like an array key
⋮----
// First time seeing the key</file><file path="lib/ts/lib-platform/package.json">{
	&quot;name&quot;: &quot;@anterior/lib-platform&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;type&quot;: &quot;module&quot;,
	&quot;main&quot;: &quot;dist/index.js&quot;,
	&quot;module&quot;: &quot;dist/index.js&quot;,
	&quot;types&quot;: &quot;dist/index.d.ts&quot;,
	&quot;exports&quot;: {
		&quot;./package.json&quot;: &quot;./package.json&quot;,
		&quot;./*&quot;: {
			&quot;types&quot;: &quot;./dist/*.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/*.js&quot;,
			&quot;require&quot;: &quot;./dist/*.js&quot;
		},
		&quot;.&quot;: {
			&quot;types&quot;: &quot;./dist/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/index.js&quot;,
			&quot;require&quot;: &quot;./dist/index.js&quot;
		}
	},
	&quot;files&quot;: [
		&quot;dist&quot;
	],
	&quot;scripts&quot;: {
		&quot;format&quot;: &quot;prettier --plugin prettier-plugin-organize-imports --ignore-path ../../.gitignore --write .&quot;,
		&quot;build&quot;: &quot;tsc&quot;,
		&quot;watch&quot;: &quot;tsc -w&quot;,
		&quot;migrate&quot;: &quot;echo &apos;Nothing to migrate...&apos;&quot;,
		&quot;test:integration&quot;: &quot;echo no integration tests&quot;,
		&quot;test&quot;: &quot;vitest run&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/openapi&quot;: &quot;0.0.0&quot;,
		&quot;@hono/node-server&quot;: &quot;^1.14.0&quot;,
		&quot;@hono/trpc-server&quot;: &quot;^0.3.2&quot;,
		&quot;hono&quot;: &quot;^4.6.3&quot;,
		&quot;hono-pino&quot;: &quot;^0.3.0&quot;,
		&quot;node-fetch&quot;: &quot;^3.3.2&quot;,
		&quot;superjson&quot;: &quot;^2.2.1&quot;,
		&quot;vitest&quot;: &quot;^2.1.3&quot;,
		&quot;zod&quot;: &quot;^3.24.2&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;,
		&quot;eslint&quot;: &quot;^9.9.0&quot;,
		&quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,
		&quot;@types/eslint&quot;: &quot;^9.6.0&quot;,
		&quot;@types/eslint-config-prettier&quot;: &quot;^6.11.3&quot;,
		&quot;@types/eslint__js&quot;: &quot;^8.42.3&quot;,
		&quot;@types/node&quot;: &quot;^22.9.0&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;typescript&quot;: &quot;^5.0.0&quot;
	}
}</file><file path="tools/prettier-dependencies/package.json">{
  &quot;name&quot;: &quot;prettier-dependencies&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;description&quot;: &quot;Synthetic package to manage our dependencies for prettier&quot;,
  &quot;author&quot;: &quot;Anterior &lt;tech@anterior.com&gt;&quot;,
  &quot;license&quot;: &quot;UNLICENSED&quot;,
  &quot;dependencies&quot;: {
    &quot;prettier&quot;: &quot;^3.5.3&quot;,
    &quot;prettier-plugin-organize-imports&quot;: &quot;^4.1.0&quot;,
    &quot;prettier-plugin-tailwindcss&quot;: &quot;^0.6.11&quot;
  }
}</file><file path="package.json">{
	&quot;name&quot;: &quot;platform&quot;,
	&quot;type&quot;: &quot;module&quot;,
	&quot;private&quot;: true,
	&quot;workspaces&quot;: [
		&quot;experimental/clinical_tool/frontend&quot;,
		&quot;gateways/noodle&quot;,
		&quot;gateways/noggin&quot;,
		&quot;lib/ts/lib-infra&quot;,
		&quot;lib/ts/lib-platform&quot;,
		&quot;services/*&quot;,
		&quot;surfaces/*&quot;,
		&quot;gen/ts/*&quot;,
		&quot;experimental/*&quot;
	],
	&quot;scripts&quot;: {
		&quot;build&quot;: &quot;cd surfaces/neuron &amp;&amp; bun run build&quot;
	},
	&quot;trustedDependencies&quot;: [
		&quot;@swc/core&quot;,
		&quot;canvas&quot;,
		&quot;esbuild&quot;,
		&quot;msw&quot;,
		&quot;sharp&quot;
	],
	&quot;dependencies&quot;: {
		&quot;@tanstack/react-query&quot;: &quot;^5.44.4&quot;,
		&quot;@tanstack/react-query-devtools&quot;: &quot;^5.44.4&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@types/node&quot;: &quot;^20&quot;
	},
	&quot;peerDependencies&quot;: {
		&quot;@radix-ui/react-dropdown-menu&quot;: &quot;2.1.2&quot;,
		&quot;@trpc/react-query&quot;: &quot;11.0.2&quot;,
		&quot;@trpc/server&quot;: &quot;11.0.2&quot;
	}
}</file><file path="gateways/noggin/src/agents/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createAgentsApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;</file><file path="gateways/noggin/src/agents/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import type { EventStoreBackend } from &quot;@anterior/lib-platform/events&quot;;
import { EventStore } from &quot;@anterior/lib-platform/events&quot;;
import {
	InMemoryBlobStoreBackend,
	InMemoryEventStoreBackend,
	InMemoryMessageQueueBackend,
} from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
import type { MessageQueue } from &quot;@anterior/lib-platform/queue&quot;;
import { toSchema } from &quot;@anterior/lib-platform/schema&quot;;
import type { POJO } from &quot;@anterior/lib-platform/types&quot;;
import { stemEventSchema, stemEventSerializer, type StemEvents } from &quot;../stems/schemas/events.ts&quot;;
⋮----
/**
 * Infrastructure interface defining the external resources needed by the platform.
 *
 * The platform can be deployed in different environments:
 * - Production: Resources managed by CDK/Terraform
 * - Docker/CI: Resources managed by Docker Compose
 * - Local/Testing: Resources represented by in-memory implementations
 *
 * This abstraction allows for environment-specific implementations
 * while maintaining a consistent interface for the application.
 */
export interface Infra {
	readonly logger: Logger;
	readonly blobs: BlobStoreBackend;
	readonly taskQueue: MessageQueue&lt;POJO&gt;;
	readonly events: EventStoreBackend;
}
⋮----
/**
 * Creates an in-memory implementation of the infrastructure.
 *
 * This is not meant for production use! The in-memory implementation
 * is useful for:
 * - Unit testing: Fast, isolated test environment
 * - Local development: Quick setup without external dependencies
 *
 * Note that all data is lost when the process exits.
 */
export function getInMemoryInfra(): Infra
⋮----
/**
 * Application layer interface to the resource backends.
 *
 * This interface provides type-safe access to:
 * - Blob storage: For storing note payloads and metadata
 *
 * The interface ensures that all platform operations are properly
 * typed and validated against their schemas.
 *
 * Note the duplication below. Maybe a better solution might be a task scheduler
 * that accepts multiple different tasks, instead of repeating one-by-one.
 */
export interface Stores {
	readonly blobs: BlobStore;
	readonly events: EventStore&lt;StemEvents&gt;;
}
⋮----
/**
 * Core platform implementation for the Agents application.
 *
 * The platform provides:
 * 1. Factory methods for creating platform instances
 * 2. Type-safe access to storage and flow services
 * 3. Environment-specific resource management
 */
export class Platform
⋮----
/**
	 * Creates an in-memory platform instance for testing.
	 *
	 * This method allows for partial infrastructure overrides,
	 * making it easy to mock specific components while using
	 * real implementations for others.
	 */
public static inMemory(infra: Partial&lt;Infra&gt; =
⋮----
/**
	 * Creates a platform instance from infrastructure configuration.
	 *
	 * This method:
	 * 1. Sets up the message queue for flow scheduling
	 * 2. Initializes blob storage for note data
	 * 3. Configures proper serialization and validation
	 */
public static fromInfra(infra: Infra): Platform
⋮----
constructor(public readonly stores: Stores)
⋮----
/**
	 * Type-safe access to the blob storage service.
	 * Used for storing and retrieving note data.
	 */
get blobs(): BlobStore</file><file path="gateways/noggin/src/ahip/main.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import secrets from &quot;@anterior/lib-infra/secrets&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createAhipApp } from &quot;./app.ts&quot;;
import { platform } from &quot;./infra.ts&quot;;</file><file path="gateways/noggin/src/chat/models/extracts.ts">import type { SchemaLike } from &quot;@anterior/lib-platform/schema&quot;;
⋮----
import { clinicalExtraction } from &quot;../../@anterior/models/s3/clinical_extraction.ts&quot;;
⋮----
export type Extracts = z.infer&lt;typeof extractsSchema&gt;;
⋮----
export type BoundingBox = {
	top: number;
	right: number;
	bottom: number;
	left: number;
};
⋮----
export type ReductoVertices = Array&lt;[number, number]&gt;;
⋮----
export type ExtractBlock = {
	extractId: string;
	blockId: number | null;
	pageNumber: number | null;
	boundingBox: BoundingBox;
	text: string;
};
⋮----
export type Block = z.infer&lt;typeof blockSchema&gt;;</file><file path="gateways/noggin/src/chat/models/message.ts">import { type SchemaLike } from &quot;@anterior/lib-platform/schema&quot;;
⋮----
// *----------------*
// Types
// *----------------*
⋮----
export type Role = &quot;user&quot; | &quot;assistant&quot; | &quot;system&quot;;
⋮----
export type Section = {
	artifact_id: string;
	section_type: string;
	section_payload?: unknown; // FIXME: `section_payload` is REQUIRED, change when `zod/v4` is released
};
⋮----
section_payload?: unknown; // FIXME: `section_payload` is REQUIRED, change when `zod/v4` is released
⋮----
export type FinishReason =
	| &quot;end_turn&quot;
	| &quot;max_tokens&quot;
	| &quot;stop_sequence&quot;
	| &quot;tool_use&quot;
	| &quot;tool_result&quot;
	| &quot;error&quot;;
⋮----
export type ContentBlock =
	| {
			content_type: &quot;text&quot;;
			text: string;
	  }
	| {
			content_type: &quot;html&quot;;
			html: string;
	  }
	| {
			content_type: &quot;citation&quot;;
			to: Section;
	  }
	| {
			content_type: &quot;image&quot;;
			image_url: string;
			alt_text?: string | undefined; // FIXME: Alt text must be a string if present, change when `zod/v4` is released
	  }
	| {
			content_type: &quot;tool_use&quot;;
			tool_name: string;
			tool_parameters: Record&lt;string, unknown&gt;;
			tool_id?: string | undefined; // FIXME: Tool ID must be a string if present, change when `zod/v4` is released
	  }
	| {
			content_type: &quot;agent_handoff&quot;;
			agent_name: string;
	  };
⋮----
alt_text?: string | undefined; // FIXME: Alt text must be a string if present, change when `zod/v4` is released
⋮----
tool_id?: string | undefined; // FIXME: Tool ID must be a string if present, change when `zod/v4` is released
⋮----
export type MessageMetadata = {
	finish_reason?: FinishReason | undefined; // FIXME: Finish reason must be a string if present, change when `zod/v4` is released
	model_name?: string | undefined; // FIXME: Model name must be a string if present, change when `zod/v4` is released
};
⋮----
finish_reason?: FinishReason | undefined; // FIXME: Finish reason must be a string if present, change when `zod/v4` is released
model_name?: string | undefined; // FIXME: Model name must be a string if present, change when `zod/v4` is released
⋮----
export type ChatMessage = {
	message_id: string;
	timestamp: string;
	role: Role;
	content: ContentBlock[];
	metadata?: MessageMetadata | undefined; // FIXME: Metadata must be an object if present, change when `zod/v4` is released
};
⋮----
metadata?: MessageMetadata | undefined; // FIXME: Metadata must be an object if present, change when `zod/v4` is released
⋮----
export type ChatRequestMessage = {
	role: Role;
	content: ContentBlock[];
};
⋮----
export type ChatRequestBody = {
	stem_id: string;
	messages: ChatMessage[];
	new_message: ChatRequestMessage;
	pdf_ids: string[];
};
⋮----
// *----------------*
// Schemas
// *----------------*</file><file path="gateways/noggin/src/chat/orchestrator/types.ts">import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import type { ChatMessage } from &quot;../models/message.ts&quot;;
import type { Platform } from &quot;../platform.ts&quot;;
⋮----
export interface OrchestratorContext {
	logger: Logger;
	platform: Platform;
}
⋮----
export interface IOrchestrator {
	processChat(
		// For now, it only depends on the message stream shown to the user
		// In the future, it should depend on an &apos;event stream&apos; of all the events that have occurred in the session
		messages: ChatMessage[],
	): Promise&lt;ChatMessage&gt;;
}
⋮----
processChat(
		// For now, it only depends on the message stream shown to the user
		// In the future, it should depend on an &apos;event stream&apos; of all the events that have occurred in the session
		messages: ChatMessage[],
	): Promise&lt;ChatMessage&gt;;
⋮----
// For now, it only depends on the message stream shown to the user
// In the future, it should depend on an &apos;event stream&apos; of all the events that have occurred in the session</file><file path="gateways/noggin/src/flobot/app.ts">import type { Slack } from &quot;@anterior/lib-infra/slack&quot;;
import { App, type AppOptions } from &quot;@anterior/lib-platform/app&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
export interface FlobotAppContext {
	logger: Logger;
	slack: Slack;
}
⋮----
export type FlobotApp = App&lt;object, FlobotAppContext&gt;;
⋮----
export function createFlobotApp(ctx: FlobotAppContext, opt: AppOptions): FlobotApp
⋮----
// Connect slack server to underlying hono server.</file><file path="gateways/noggin/src/stems/handlers/attach-clinicals.ts">import type { AttachClinicalsToStemV11 } from &quot;../../@anterior/models/events/stems/attach_clinicals_to_stem_v1_1.ts&quot;;
import { attachClinicalsToStemV11 } from &quot;../../@anterior/models/events/stems/attach_clinicals_to_stem_v1_1.ts&quot;;
import {
	stemMetaV11,
	type StemMetaV11,
} from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { emitStemEvent } from &quot;../events/emit-stem-event.ts&quot;;
⋮----
export const attachClinicalsToStem = async (
	stemId: string,
	artQueries: string[],
	workspaceUid: string,
	enterpriseUid: string,
	userUid: string,
) =&gt;</file><file path="gateways/noggin/src/stems/handlers/attach-criteria.ts">import {
	attachCriteriaToStemV11,
	type AttachCriteriaToStemV11,
} from &quot;../../@anterior/models/events/stems/attach_criteria_to_stem_v1_1.ts&quot;;
import {
	stemMetaV11,
	type StemMetaV11,
} from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { emitStemEvent } from &quot;../events/emit-stem-event.ts&quot;;
⋮----
export const attachCriteriaToStem = async (
	stemId: string,
	codes: AttachCriteriaToStemV11[&quot;codes&quot;],
	workspaceUid: string,
	enterpriseUid: string,
	userUid: string,
) =&gt;</file><file path="gateways/noggin/src/stems/handlers/attach-services.ts">import type { AttachServicesToStemV11 } from &quot;../../@anterior/models/events/stems/attach_services_to_stem_v1_1.ts&quot;;
import { attachServicesToStemV11 } from &quot;../../@anterior/models/events/stems/attach_services_to_stem_v1_1.ts&quot;;
import {
	stemMetaV11,
	type StemMetaV11,
} from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { emitStemEvent } from &quot;../events/emit-stem-event.ts&quot;;
⋮----
export const attachServicesToStem = async (
	stemId: string,
	services: AttachServicesToStemV11[&quot;services&quot;],
	workspaceUid: string,
	enterpriseUid: string,
	userUid: string,
) =&gt;</file><file path="gateways/noggin/src/stems/handlers/rollup.ts">import { EventStreamReader } from &quot;@anterior/lib-platform/events&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { platform } from &quot;../infra.ts&quot;;
⋮----
export const rollupEventsForStem = async (
	stemId: string,
	filter: string | undefined,
): Promise&lt;
	{
		event_type: string;
		createdAt: Date;
		data: string;
	}[]
&gt; =&gt; {
	const stream = new EventStreamReader(logger, platform.stores.events, stemId);
⋮----
// no filter / &quot;all&quot; -&gt; all events
⋮----
// nanoseconds to milliseconds</file><file path="gateways/noggin/src/stems/utils/common.ts">import type { BaseContext } from &quot;@anterior/lib-platform/app&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { stemMetaV11 } from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { parseAuthInfo } from &quot;../../auth/jwt.ts&quot;;
import { createStem } from &quot;../handlers/create-stem.ts&quot;;
⋮----
// TODO borrowing the schema. This should be defined in the `lib-platform`
⋮----
export async function useOrMintStemId(
	stemId: string | undefined,
	context: BaseContext,
): Promise&lt;`stm_$</file><file path="gateways/noggin/src/stems/app.ts">import { App, type AppOptions, type EndpointSignature } from &quot;@anterior/lib-platform/app&quot;;
import { type Logger } from &quot;@anterior/lib-platform/log&quot;;
import { z } from &quot;zod&quot;;
import type { Platform } from &quot;./platform.ts&quot;;
⋮----
import { attachClinicalsToStemV11 } from &quot;../@anterior/models/events/stems/attach_clinicals_to_stem_v1_1.ts&quot;;
import { attachCriteriaToStemV11 } from &quot;../@anterior/models/events/stems/attach_criteria_to_stem_v1_1.ts&quot;;
import { attachServicesToStemV11 } from &quot;../@anterior/models/events/stems/attach_services_to_stem_v1_1.ts&quot;;
import { stemMetaV11 } from &quot;../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { parseAuthInfo } from &quot;../auth/jwt.ts&quot;;
import { attachClinicalsToStem } from &quot;./handlers/attach-clinicals.ts&quot;;
import { attachCriteriaToStem } from &quot;./handlers/attach-criteria.ts&quot;;
import { attachServicesToStem } from &quot;./handlers/attach-services.ts&quot;;
import { createStem } from &quot;./handlers/create-stem.ts&quot;;
import { rollupEventsForStem } from &quot;./handlers/rollup.ts&quot;;
⋮----
export interface StemsAppContext {
	logger: Logger;
	platform: Platform;
}
⋮----
export interface StemsAppService {
	GET: {
		&quot;/:stemId&quot;: EndpointSignature&lt;
			object,
			{
				event_type: string;
				createdAt: Date;
				data: string;
			}[]
		&gt;;
	};
	POST: {
		&quot;/&quot;: EndpointSignature&lt;object, { stemId: string }&gt;;
		&quot;/:stemId/clinicals&quot;: EndpointSignature&lt;object, { success: boolean }&gt;;
		&quot;/:stemId/criteria&quot;: EndpointSignature&lt;object, { success: boolean }&gt;;
		&quot;/:stemId/services&quot;: EndpointSignature&lt;object, { success: boolean }&gt;;
	};
}
⋮----
export type StemsApp = App&lt;StemsAppService, StemsAppContext&gt;;
⋮----
export function createStemsApp(baseCtx: StemsAppContext, options: AppOptions): StemsApp
⋮----
/*******************************************************************************************
	 * Rollup a stem
	 ********************************************************************************************/
⋮----
/*******************************************************************************************
	 *	Create a new stem
	 ********************************************************************************************/
⋮----
/********************************************************************************************
	 * attach clinicals (art queries) to the specified stem
	 ********************************************************************************************/
⋮----
/*********************************************************************************************
	 * attach codes (criteria) to a given stem
	 ********************************************************************************************/
⋮----
/*********************************************************************************************
	 * attach service requests to a specified stem
	 ********************************************************************************************/</file><file path="gateways/noggin/src/tasks/handlers/project-log-events.ts">import { EventStreamReader } from &quot;@anterior/lib-platform/events&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
import { createStemV11 } from &quot;../../@anterior/models/events/stems/create_stem_v1_1.ts&quot;;
import { platform } from &quot;../infra.ts&quot;;
⋮----
export const projectLogsForStem = async (
	stemId: string,
	workspaceUid: string,
): Promise&lt;
	{
		event_type: string;
		createdAt: Date;
		data: string;
	}[]
&gt; =&gt; {
	const stream = new EventStreamReader(logger, platform.stores.events, stemId);
⋮----
// analyze the first event, must be stem creation for this workspace ID
⋮----
// validate that it matches the create event schema
⋮----
// remove any other events that don&apos;t belong to this workspace ID</file><file path="gateways/noggin/src/tasks/handlers/run-igg.ts">import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import { platform } from &quot;../infra.ts&quot;;
⋮----
// NOTES
// Just like runHealthHelp, this is not intended for long term use.
// It is a stepping stone, in place of a &quot;proper&quot; solution whereby the work
// is run on a pre-existing stem, e.g. runIggOnStemId.
⋮----
export const runIgg = async (
	userUid: string,
	enterpriseUid: string,
	workspaceUid: string,
	criteriaQuery: string,
	stemId: string = generateRandomId(&quot;stm&quot;), // Optional stemId parameter with default value
) =&gt;
⋮----
stemId: string = generateRandomId(&quot;stm&quot;), // Optional stemId parameter with default value</file><file path="gateways/noggin/src/tasks/handlers/validate-clinicals.ts">import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import {
	type StemMetaV11,
	stemMetaV11,
} from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { emitStemEvent } from &quot;../../stems/events/emit-stem-event.ts&quot;;
import { platform } from &quot;../infra.ts&quot;;
⋮----
// perhaps change to a type?
interface ValidateClinicalsParams {
	enterpriseUid: string;
	userUid: string;
	workspaceUid: string;
	artQueries: {
		member: string;
		clinicals: string[];
	};
	stemId: string;
}
⋮----
export const validateClinicals = async ({
	enterpriseUid,
	userUid,
	workspaceUid,
	artQueries,
	stemId,
}: ValidateClinicalsParams) =&gt;</file><file path="lib/ts/lib-infra/package.json">{
	&quot;name&quot;: &quot;@anterior/lib-infra&quot;,
	&quot;version&quot;: &quot;0.0.0&quot;,
	&quot;private&quot;: true,
	&quot;type&quot;: &quot;module&quot;,
	&quot;main&quot;: &quot;dist/index.js&quot;,
	&quot;module&quot;: &quot;dist/index.js&quot;,
	&quot;types&quot;: &quot;dist/index.d.ts&quot;,
	&quot;exports&quot;: {
		&quot;./package.json&quot;: &quot;./package.json&quot;,
		&quot;./*&quot;: {
			&quot;types&quot;: &quot;./dist/*.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/*.js&quot;,
			&quot;require&quot;: &quot;./dist/*.js&quot;
		},
		&quot;.&quot;: {
			&quot;types&quot;: &quot;./dist/index.d.ts&quot;,
			&quot;import&quot;: &quot;./dist/index.js&quot;,
			&quot;require&quot;: &quot;./dist/index.js&quot;
		}
	},
	&quot;files&quot;: [
		&quot;dist&quot;
	],
	&quot;scripts&quot;: {
		&quot;format&quot;: &quot;prettier --plugin prettier-plugin-organize-imports --ignore-path ../../.gitignore --write .&quot;,
		&quot;build&quot;: &quot;tsc&quot;,
		&quot;watch&quot;: &quot;tsc -w&quot;,
		&quot;migrate&quot;: &quot;echo &apos;Nothing to migrate...&apos;&quot;,
		&quot;test:integration&quot;: &quot;vitest run&quot;,
		&quot;test&quot;: &quot;echo no unit tests&quot;
	},
	&quot;dependencies&quot;: {
		&quot;@anterior/lib-platform&quot;: &quot;0.0.0&quot;,
		&quot;@aws-sdk/client-dynamodb&quot;: &quot;^3.651.1&quot;,
		&quot;@aws-sdk/client-dynamodb-streams&quot;: &quot;^3.696.0&quot;,
		&quot;@aws-sdk/client-s3&quot;: &quot;^3.637.0&quot;,
		&quot;@aws-sdk/client-sqs&quot;: &quot;^3.658.1&quot;,
		&quot;@aws-sdk/lib-storage&quot;: &quot;^3.658.1&quot;,
		&quot;@aws-sdk/s3-presigned-post&quot;: &quot;^3.668.0&quot;,
		&quot;@aws-sdk/util-dynamodb&quot;: &quot;^3.658.1&quot;,
		&quot;@types/pg&quot;: &quot;^8.11.10&quot;,
		&quot;airtable&quot;: &quot;^0.12.2&quot;,
		&quot;pg&quot;: &quot;^8.13.1&quot;,
		&quot;slack-edge&quot;: &quot;^1.3.8&quot;,
		&quot;sqlite&quot;: &quot;^5.1.1&quot;,
		&quot;sqlite3&quot;: &quot;^5.1.7&quot;,
		&quot;vitest&quot;: &quot;^3.0.9&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@types/eslint&quot;: &quot;^9.6.0&quot;,
		&quot;@types/eslint__js&quot;: &quot;^8.42.3&quot;,
		&quot;@types/eslint-config-prettier&quot;: &quot;^6.11.3&quot;,
		&quot;eslint&quot;: &quot;^9.9.0&quot;,
		&quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,
		&quot;prettier&quot;: &quot;^3.3.3&quot;,
		&quot;prettier-plugin-organize-imports&quot;: &quot;^4.0.0&quot;
	}
}</file><file path="lib/ts/lib-platform/src/app.ts">import { serve } from &quot;@hono/node-server&quot;;
import { initTRPC } from &quot;@trpc/server&quot;;
import { fetchRequestHandler } from &quot;@trpc/server/adapters/fetch&quot;;
import fs from &quot;fs&quot;;
import { type Env, type ExecutionContext, Hono, type Context as HonoContext } from &quot;hono&quot;;
import { logger as pinoLogger } from &quot;hono-pino&quot;;
import { cors } from &quot;hono/cors&quot;;
import { csrf } from &quot;hono/csrf&quot;;
import { HTTPException } from &quot;hono/http-exception&quot;;
import { requestId } from &quot;hono/request-id&quot;;
import { secureHeaders } from &quot;hono/secure-headers&quot;;
import { timing } from &quot;hono/timing&quot;;
import path from &quot;path&quot;;
import superjson from &quot;superjson&quot;;
import { URL } from &quot;url&quot;;
import { extractBody } from &quot;./body.ts&quot;;
import { type AuthConfig, authMiddleware, type JWTPayload } from &quot;./jwt.ts&quot;;
⋮----
import { allowOrigins } from &quot;./cors.ts&quot;;
⋮----
import { Blob, type BlobStoreReader } from &quot;./blob.ts&quot;;
import { KeyMissingError, ParseError, Unauthorized } from &quot;./errors.ts&quot;;
import { logger, Logger } from &quot;./log.ts&quot;;
import { fromEach } from &quot;./object.ts&quot;;
import { type Schema, type SchemaLike, toSchema } from &quot;./schema.ts&quot;;
import type { Path, POJO } from &quot;./types.ts&quot;;
import { createPathParamsExtractor, type ExtractParams, extractQuery } from &quot;./url.ts&quot;;
import { z } from &quot;./zod.ts&quot;;
⋮----
// To make it less attractive to use the hono specific context. Right now it&apos;s helping us return a stream response somewhere
⋮----
export function getHonoContext(ctx: any): HonoContext
⋮----
export function extractHeaders(req: Request): POJO
⋮----
// Realistically these could be the same type
⋮----
export type EndpointSignature&lt;TRequest, TResponse&gt; = (arg: {
	body: TRequest;
}) =&gt; Promise&lt;TResponse&gt;;
export interface Procedure&lt;TInput, TOutput&gt; {
	input: TInput;
	output: TOutput;
}
⋮----
// TODO support other methods
type Method = &quot;GET&quot; | &quot;POST&quot;;
⋮----
type Operation = &quot;query&quot; | &quot;mutate&quot;;
⋮----
/**
 * This type helps define the shape of a http service map that is easy to read.
 * We can also use it for type type assertions in methods on the app class.
 */
type EndpointMap = {
	[K in Method]?: {
		[route: Path]: EndpointSignature&lt;any, any&gt;;
	};
};
⋮----
/**
 * This type helps define the shape of a trpc service map that is easy to read.
 * We can also use it for type type assertions in methods on the app class.
 */
type ProcedureMap = {
	[K in Operation]?: {
		[procedure: string]: Procedure&lt;any, any&gt;;
	};
};
⋮----
type ServiceMap = EndpointMap &amp; ProcedureMap;
⋮----
export type ServiceImplementation&lt;T extends EndpointMap&gt; = {
	[TMethod in keyof Omit&lt;T, Operation&gt;]: {
		// TODO also type check operations
		[TRoute in keyof T[TMethod]]: T[TMethod][TRoute];
	};
};
⋮----
// TODO also type check operations
⋮----
export interface AppOptions {
	readonly name: string;
	readonly port: number;
	readonly allowedHeaders: string[];
	readonly allowedOrigins: string[];
	readonly useCSRF: boolean;

	/**
	 * When true, the app will not log anything. Useful to keep the test output clean.
	 * Altertatively, you can pass in an in-memory or noop logger.
	 */
	readonly noLogging?: boolean;
	/**
	 * Defaults to the global logger
	 */
	readonly logger?: Logger;
	/**
	 * If this value is set, the app will use JWT middleware
	 */
	readonly authConfig?: AuthConfig;
}
⋮----
/**
	 * When true, the app will not log anything. Useful to keep the test output clean.
	 * Altertatively, you can pass in an in-memory or noop logger.
	 */
⋮----
/**
	 * Defaults to the global logger
	 */
⋮----
/**
	 * If this value is set, the app will use JWT middleware
	 */
⋮----
export type TokenContext = {
	userUid: string;
	enterpriseUid: string;
	role: string;
	workspaceUid: string;
};
⋮----
export type BaseContext = {
	/**
	 * The raw request object, we try to use this as much as possible to minimize indirection
	 */
	req: Request;
	/**
	 * This is a bit of non-generic context that we support out of the box. Only set to a value when relevant
	 */
	jwtPayload?: JWTPayload;
	auth?: TokenContext;
} &amp; {
	/**
	 * This sneaky property is used to pass the hono context around as an escape hatch
	 */
	[key in typeof HONO_CONTEXT]: HonoContext;
};
⋮----
/**
	 * The raw request object, we try to use this as much as possible to minimize indirection
	 */
⋮----
/**
	 * This is a bit of non-generic context that we support out of the box. Only set to a value when relevant
	 */
⋮----
/**
	 * This sneaky property is used to pass the hono context around as an escape hatch
	 */
⋮----
export type RequestContext&lt;
	TAppContext,
	TRoute extends Path,
	TParams = unknown,
	TQuery = unknown,
	THeaders = unknown,
	TBody = unknown,
&gt; = {
	/**
	 * The route is the path template that the request was matched against
	 */
	route: TRoute;
	/**
	 * Parameters found in the url path, e.g. /foo/:bar/baz/:qux
	 */
	params: TParams;
	/**
	 * Query parameters found in the url, e.g. /foo?bar=baz
	 */
	query: TQuery;
	/**
	 * Headers found in the request
	 */
	headers: THeaders;
	/**
	 * The body of the request in an appropriate format, i.e. json and form data as POJO
	 */
	body: TBody;
} &amp; TAppContext &amp;
	BaseContext;
⋮----
/**
	 * The route is the path template that the request was matched against
	 */
⋮----
/**
	 * Parameters found in the url path, e.g. /foo/:bar/baz/:qux
	 */
⋮----
/**
	 * Query parameters found in the url, e.g. /foo?bar=baz
	 */
⋮----
/**
	 * Headers found in the request
	 */
⋮----
/**
	 * The body of the request in an appropriate format, i.e. json and form data as POJO
	 */
⋮----
/**
 * This is what the application author provides when defining an endpoint, it&apos;s a bit more flexible
 * than the Endpoint type, but it&apos;s converted to that type before being used.
 */
export interface EndpointConfig&lt;
	TAppContext,
	TMethod extends Method,
	TRoute extends Path,
	TParams extends ExtractParams&lt;TRoute&gt; | undefined,
	TQuery,
	THeaders,
	TBody,
	TResponse,
	TRequest extends RequestContext&lt;
		TAppContext,
		TRoute,
		TParams,
		TQuery,
		THeaders,
		TBody
	&gt; = RequestContext&lt;TAppContext, TRoute, TParams, TQuery, THeaders, TBody&gt;,
&gt; {
	method: TMethod;
	route: TRoute;
	params?: SchemaLike&lt;TParams&gt;;
	query?: SchemaLike&lt;TQuery&gt;;
	body?: SchemaLike&lt;TBody&gt;;
	headers?: SchemaLike&lt;THeaders&gt;;
	response?: SchemaLike&lt;TResponse&gt;;
	handler: (ctx: TRequest) =&gt; Promise&lt;TResponse&gt;;
}
⋮----
/**
 * Endpoints contain all information for a single API endpoint to parse a request and return a response
 */
export interface Endpoint&lt;
	TAppContext,
	TMethod extends Method,
	TRoute extends Path,
	TParams extends ExtractParams&lt;TRoute&gt;,
	TQuery,
	THeaders,
	TBody,
	TResponse,
	TRequest extends RequestContext&lt;
		TAppContext,
		TRoute,
		TParams,
		TQuery,
		THeaders,
		TBody
	&gt; = RequestContext&lt;TAppContext, TRoute, TParams, TQuery, THeaders, TBody&gt;,
&gt; {
	method: TMethod;
	route: TRoute;
	params: Schema&lt;TParams&gt; | undefined;
	query: Schema&lt;TQuery&gt; | undefined;
	headers: Schema&lt;THeaders&gt; | undefined;
	body: Schema&lt;TBody&gt; | undefined;
	response: Schema&lt;TResponse&gt; | undefined;
	handler(ctx: TRequest): Promise&lt;TResponse&gt;;
}
⋮----
handler(ctx: TRequest): Promise&lt;TResponse&gt;;
⋮----
function createEndpoint&lt;
	TAppContext,
	TMethod extends Method,
	TRoute extends Path,
	TParams extends ExtractParams&lt;TRoute&gt;,
	TQuery,
	THeaders,
	TBody,
	TResponse,
	TRequest extends RequestContext&lt;
		TAppContext,
		TRoute,
		TParams,
		TQuery,
		THeaders,
		TBody
	&gt; = RequestContext&lt;TAppContext, TRoute, TParams, TQuery, THeaders, TBody&gt;,
&gt;(
	config: EndpointConfig&lt;
		TAppContext,
		TMethod,
		TRoute,
		TParams,
		TQuery,
		THeaders,
		TBody,
		TResponse,
		TRequest
	&gt;,
): Endpoint&lt;TAppContext, TMethod, TRoute, TParams, TQuery, THeaders, TBody, TResponse, TRequest&gt;
⋮----
async function parseRequestContext&lt;
	TAppContext,
	TMethod extends Method,
	TRoute extends Path,
	TParams extends ExtractParams&lt;TRoute&gt;,
	TQuery,
	THeaders,
	TBody,
	TResponse,
	TRequest extends RequestContext&lt;
		TAppContext,
		TRoute,
		TParams,
		TQuery,
		THeaders,
		TBody
	&gt; = RequestContext&lt;TAppContext, TRoute, TParams, TQuery, THeaders, TBody&gt;,
&gt;(
	endpoint: Endpoint&lt;
		TAppContext,
		TMethod,
		TRoute,
		TParams,
		TQuery,
		THeaders,
		TBody,
		TResponse,
		TRequest
	&gt;,
	baseCtx: TAppContext &amp; BaseContext,
): Promise&lt;TRequest&gt;
⋮----
// TODO we could set these up to be lazy
// TODO we could precreate this extractor and keep it somewhere.
⋮----
// TODO more typing here?
async function handleEndpoint&lt;TAppContext&gt;(
	endpoint: Endpoint&lt;TAppContext, any, any, any, any, any, any, any, any&gt;,
	baseCtx: TAppContext &amp; BaseContext,
	// For now we use the HonoContext, but ideally this takes just a bare Request object
	// We&apos;re close though, we&apos;re only using hono for the responses.
	c: HonoContext,
): Promise&lt;Response&gt;
⋮----
// For now we use the HonoContext, but ideally this takes just a bare Request object
// We&apos;re close though, we&apos;re only using hono for the responses.
⋮----
// TODO should we even allow not specifying the response?
⋮----
/**
 * An App is a wrapper around a Hono instance that provides a more structured way to define API endpoints
 * It focuses on type safety and schema adherence. It also provides a way to define trpc endpoints.
 */
export class App&lt;TServiceMap extends ServiceMap, TAppContext extends object&gt;
⋮----
// TODO make this optional? Maybe as a &quot;cached propery&quot;?
⋮----
/**
	 * Use this to define trpc procedures into a router
	 */
get procedure()
⋮----
/**
	 * This ({port, fetch}) is the actual entrypoint for the app, as a default export
	 * As a neat convention we can export this as such:
	 *
	 * export default app satisfies ServiceImplementation&lt;MyService&gt;
	 **/
⋮----
constructor(
		public readonly baseCtx: TAppContext,
		public readonly options: AppOptions,

		// for getting auth
		public readonly auth?: (
			req: Request,
		) =&gt; Promise&lt;{ userUid: string; enterpriseUid: string } | Response&gt;,
)
⋮----
// for getting auth
⋮----
// TODO Error handling. There are many ways we could go about this, to name a few:
// - Error middleware
// - Error EndpointConfig by type
// - Errors that are responses
// Caution: We should not leak stack traces and other sensitive information here to users
⋮----
// TODO: pass a safe error message to the user.
⋮----
// we may want to have this implemented in an app-specific context
// for now, it&apos;s the same for pdfs, llms,
⋮----
// Typescript doesn&apos;t like us assigning to the context here
⋮----
useExtraContext&lt;T&gt;(
		middleware: (ctx: TAppContext) =&gt; Promise&lt;T&gt;,
): App&lt;TServiceMap, T &amp; TAppContext&gt;
⋮----
/**
	 * This method does a bunch of type spaghetti to lock down the api endpoints to a spec,
	 * translate our desired interface to hono, and hide hono from the application developer
	 */
endpoint&lt;
		TMethod extends Method,
		TRoute extends keyof TServiceMap[TMethod] &amp; Path,
		TParams extends ExtractParams&lt;TRoute&gt;,
		TQuery,
		THeaders,
		TBody,
		TResponse,
		TContext extends RequestContext&lt;
			TAppContext,
			TRoute,
			TParams,
			TQuery,
			THeaders,
			TBody
		&gt; = RequestContext&lt;TAppContext, TRoute, TParams, TQuery, THeaders, TBody&gt;,
	&gt;(
		config: EndpointConfig&lt;
			TAppContext,
			TMethod,
			TRoute,
			TParams,
			TQuery,
			THeaders,
			TBody,
			TResponse,
			TContext
		&gt;,
): asserts this is this &amp;
⋮----
useTRPCRouter(options: TRPCOptions)
⋮----
// Hacky way to check whether the router is a trpc router
⋮----
// This is a &quot;fork&quot; of @hono/trpc-server
// Started with a copy paste from https://github.com/honojs/middleware/blob/main/packages/trpc-server/src/index.ts
⋮----
// For now we don&apos;t support path params for trpc; paths are just function names and all params
// come through the input schema. So the route and the pathname are the same
⋮----
// Hide the request properties; trpc takes care of them here (the raw request is still available)
⋮----
// Fix for type compatibility issue with body
⋮----
interface RouterOptions {
	logger: Logger;
}
⋮----
/**
 * A router is a simple mounting point for multiple apps. Each app has has a path prefix and
 * is responsible for all its middleware and context (barring hono defaults)
 */
export class Router
⋮----
mount(path: Path, app: App&lt;any, any&gt;)
⋮----
serve(port: number)
⋮----
interface TRPCOptions {
	/**
	 * TODO: actually type this
	 */
	router: any;
	/**
	 * Not sure how to get hold of the actual type here.
	 *
	 * import { OnErrorFunction } from &quot;@trpc/server/src/internals/types&quot;;
	 *
	 * (opts: {
	 *		error: TRPCError;
	 *		type: ProcedureType | &quot;unknown&quot;;
	 *		path: string | undefined;
	 *		req: Request;
	 *		input: unknown;
	 *		ctx: any;
	 *}) =&gt; void
	 */
	onError?: any;
}
⋮----
/**
	 * TODO: actually type this
	 */
⋮----
/**
	 * Not sure how to get hold of the actual type here.
	 *
	 * import { OnErrorFunction } from &quot;@trpc/server/src/internals/types&quot;;
	 *
	 * (opts: {
	 *		error: TRPCError;
	 *		type: ProcedureType | &quot;unknown&quot;;
	 *		path: string | undefined;
	 *		req: Request;
	 *		input: unknown;
	 *		ctx: any;
	 *}) =&gt; void
	 */
⋮----
/**
 * Recursively load all hono apps from app.ts files in a directory and mount them on a rootApp.
 * File access is sync. This is only run once at startup and we want to crash hard if it fails.
 *
 * This failes hard
 */
export async function importAndMountNestedDirectoryApps(
	logger: Logger,
	app: Hono,
	basePath: string,
	baseRoute: string = &quot;&quot;,
)
⋮----
// Depth first search to match more specific routes first
⋮----
export async function createDirectoryApp({
	dirname,
	logger,
}: {
	dirname: string;
	logger: Logger;
}): Promise&lt;Hono&gt;
⋮----
/**
 * Returns a Hono app that serves static files from a blob store
 * The prefix parameter is the path prefix that the app is serving files from
 * which is stripped from the request path before looking up the blob.
 *
 * E.g. if the prefix is &quot;/static/&quot; and the request path is &quot;/static/foo/bar.js&quot;,
 * the blob store will look for the key &quot;foo/bar.js&quot;.
 *
 * The index parameter is the key to use when the request path is just the prefix.
 *
 * Handles both text and binary files with appropriate content types based on file extension.
 */
export function createStaticApp({
	prefix,
	blobs,
	index = &quot;index.html&quot;,
	env,
}: {
	prefix: Path | &quot;&quot;; // Allow empty string as a valid prefix
	blobs: BlobStoreReader;
	index?: string;
	env?: Record&lt;string, string&gt;;
}): Hono
⋮----
prefix: Path | &quot;&quot;; // Allow empty string as a valid prefix
⋮----
// Determine content type based on file extension
⋮----
// Handle binary vs text content appropriately
⋮----
// For binary data, return the raw blob data
⋮----
// For text data, apply environment variable substitution if needed
⋮----
// Apply environment variable substitution if env is provided
⋮----
// just for logging/debugging requests</file><file path="lib/ts/lib-platform/src/assoc.contract.ts">import type { AssocStoreBackend } from &quot;./assoc.ts&quot;;
import { generateRandomId } from &quot;./ids.ts&quot;;
import { beforeAll, describe, expect, test } from &quot;./test.ts&quot;;
import type { Pagination } from &quot;./types.ts&quot;;
⋮----
export function asAssocStoreBackend(
	assocs: AssocStoreBackend,
	beforeHandler?: () =&gt; Promise&lt;void&gt;,
)</file><file path="lib/ts/lib-platform/src/assoc.ts">import { ParseError, SerializerError, timeout } from &quot;./errors.ts&quot;;
import { Logger } from &quot;./log.ts&quot;;
import type { Schema } from &quot;./schema.ts&quot;;
import type { Serializer } from &quot;./serializer.ts&quot;;
import type { Pagination, POJO, SortDirection } from &quot;./types.ts&quot;;
⋮----
// Went with Entity but could also go with &quot;EdgeStore&quot; or &quot;RelationsStore&quot;
⋮----
/**
 * This table is designed with dynamodb in mind to look up related entities to a single group id
 * The group id itself represents a single entity
 */
⋮----
// -- ASSOC STORE ----------------------------------------------------------------
⋮----
export interface ReadAssocStoreBackend {
	readAssocs(name: string, pk: string, direction: SortDirection): AsyncGenerator&lt;POJO&gt;;
	paginateAssocs(
		name: string,
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
	): Promise&lt;Pagination&lt;POJO&gt;&gt;;
}
⋮----
readAssocs(name: string, pk: string, direction: SortDirection): AsyncGenerator&lt;POJO&gt;;
paginateAssocs(
		name: string,
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
	): Promise&lt;Pagination&lt;POJO&gt;&gt;;
⋮----
export interface WriteAssocStoreBackend {
	addAssoc(name: string, pks: string[], sk: string, e: POJO): Promise&lt;void&gt;;
}
⋮----
addAssoc(name: string, pks: string[], sk: string, e: POJO): Promise&lt;void&gt;;
⋮----
/**
 * The actual operations a backend must implement to be considered an event storage.
 * Our first implementation is DynamoDB, but we could easily swap out for another storage backend.
 */
export interface AssocStoreBackend extends ReadAssocStoreBackend, WriteAssocStoreBackend {}
⋮----
export interface AssocStoreWriter&lt;E&gt; {
	saveAssoc(pks: string[], sk: string, e: E): Promise&lt;void&gt;;
}
⋮----
saveAssoc(pks: string[], sk: string, e: E): Promise&lt;void&gt;;
⋮----
export interface AssocStoreReader&lt;E&gt; {
	readAssocs(pk: string, direction: SortDirection): AsyncGenerator&lt;E&gt;;
	paginateAssocs(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
	): Promise&lt;Pagination&lt;E&gt;&gt;;
}
⋮----
readAssocs(pk: string, direction: SortDirection): AsyncGenerator&lt;E&gt;;
paginateAssocs(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
	): Promise&lt;Pagination&lt;E&gt;&gt;;
⋮----
export interface AssocStore&lt;E&gt; extends AssocStoreReader&lt;E&gt;, AssocStoreWriter&lt;E&gt; {
	readonly schema: Schema&lt;E&gt;;
	readonly serializer: Serializer&lt;E, POJO&gt;;
}
⋮----
export class AssocStore&lt;E&gt;
⋮----
constructor(
⋮----
async *readAssocs(pk: string, direction: SortDirection): AsyncGenerator&lt;E&gt;
⋮----
async paginateAssocs(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
): Promise&lt;Pagination&lt;E&gt;&gt;
⋮----
async saveAssoc(pks: string[], sk: string, event: E = {} as E /** TODO */): Promise&lt;void&gt; {</file><file path="lib/ts/lib-platform/src/blob.ts">import { Blob } from &quot;buffer&quot;;
import type { BodyInit } from &quot;node-fetch&quot;;
import { isArrayBuffer } from &quot;util/types&quot;;
import { KeyMissingError, ParseError, SerializerError, timeout } from &quot;./errors.ts&quot;;
import { Logger } from &quot;./log.ts&quot;;
⋮----
/**
 * There is some confusion about the Blob type. There is a browser version
 * and a node version. We are using the node version.
 */
⋮----
/**
 * We don&apos;t have a great type story yet for readonly vs read-write stores.
 * This is a first stab. - jkz 2025-03
 */
export interface BlobStoreReader {
	/**
	 * Retrieve a blob from the storage backend.
	 *
	 * Throws:
	 * - Timeout
	 * - KeyNotFound
	 * - ParseError
	 */
	fetchBlob(key: string): Promise&lt;Blob&gt;;
}
⋮----
/**
	 * Retrieve a blob from the storage backend.
	 *
	 * Throws:
	 * - Timeout
	 * - KeyNotFound
	 * - ParseError
	 */
fetchBlob(key: string): Promise&lt;Blob&gt;;
⋮----
export interface BlobStoreWriter {
	/**
	 * Returns a URL that lets the user upload a blob directly to the storage backend.
	 */
	getSignedUrl(key: string): Promise&lt;SignedPostUrlInfo&gt;;

	/**
	 * Store a blob in the storage backend.
	 *
	 * Throws:
	 * - Timeout
	 * - ParseError
	 * - SerializationError
	 */
	// TODO indicate when to use which
	storeBlob(key: string, plainText: string, type: MIMETypelike): Promise&lt;string&gt;;
	storeBlob(key: string, arrayBuffer: ArrayBuffer, type: MIMETypelike): Promise&lt;string&gt;;
	storeBlob(key: string, buffer: Buffer, type: MIMETypelike): Promise&lt;string&gt;;
	storeBlob(key: string, blob: Blob, type: MIMETypelike): Promise&lt;string&gt;;

	/**
	 * Write a base64 string to the storage backend.
	 */
	writeBase64(key: string, base64: string, type: MIMETypelike): Promise&lt;string&gt;;

	/**
	 * Delete a blob from the storage backend. Does nothing if the blob does not exist.
	 *
	 * Throws:
	 * - Timeout
	 */
	deleteBlob(key: string): Promise&lt;void&gt;;
}
⋮----
/**
	 * Returns a URL that lets the user upload a blob directly to the storage backend.
	 */
getSignedUrl(key: string): Promise&lt;SignedPostUrlInfo&gt;;
⋮----
/**
	 * Store a blob in the storage backend.
	 *
	 * Throws:
	 * - Timeout
	 * - ParseError
	 * - SerializationError
	 */
// TODO indicate when to use which
storeBlob(key: string, plainText: string, type: MIMETypelike): Promise&lt;string&gt;;
storeBlob(key: string, arrayBuffer: ArrayBuffer, type: MIMETypelike): Promise&lt;string&gt;;
storeBlob(key: string, buffer: Buffer, type: MIMETypelike): Promise&lt;string&gt;;
storeBlob(key: string, blob: Blob, type: MIMETypelike): Promise&lt;string&gt;;
⋮----
/**
	 * Write a base64 string to the storage backend.
	 */
writeBase64(key: string, base64: string, type: MIMETypelike): Promise&lt;string&gt;;
⋮----
/**
	 * Delete a blob from the storage backend. Does nothing if the blob does not exist.
	 *
	 * Throws:
	 * - Timeout
	 */
deleteBlob(key: string): Promise&lt;void&gt;;
⋮----
/**
 * Blob store provides the following features:
 * - [x] Large size (let&apos;s say &quot;Megabytes&quot; for starters)
 * - [x] Bytes are streamed (in-and-out)
 * - [x] Content type is available but not enforced
 * - [ ] We support public urls that can fetch the blob
 * - [x] Keys are file-system like paths, with / separators
 *
 * Blob trade-offs
 * - Slow read latency (&gt;200ms)
 * - No schema validation
 *
 * Features we may want:
 * - Versioned values
 * - Content addressable keys
 * - Content type enforcement
 */
export interface BlobStore extends BlobStoreReader, BlobStoreWriter {
	/**
	 * Returns a substore, semantically equivalent to a subdirectory.
	 * The joining logic is a simple &quot;+&quot;. For directory semantics, bring your own separator.
	 */
	getSubStore(segment: string): BlobStore;
}
⋮----
/**
	 * Returns a substore, semantically equivalent to a subdirectory.
	 * The joining logic is a simple &quot;+&quot;. For directory semantics, bring your own separator.
	 */
getSubStore(segment: string): BlobStore;
⋮----
export class BlobStore implements BlobStoreReader
⋮----
constructor(
		logger: Logger,
		private readonly backend: BlobStoreBackend,
		public readonly prefix: string = &quot;&quot;,
		public readonly fetchBlobTimeoutMs: number = 200,
		public readonly storeBlobTimeoutMs: number = 10000,
		public readonly deleteBlobTimeoutMs: number = 200,
		public readonly getSignedUrlTimeoutMs: number = 200,
)
⋮----
static createReadonly(
		logger: Logger,
		backend: ReadonlyBlobStoreBackend,
		prefix?: string,
		fetchBlobTimeoutMs?: number,
): BlobStoreReader
⋮----
// We&apos;re cheating here! We&apos;re casting a readonly backend to a read-write backend.
// But it&apos;s okay, because the returned BlobStore is readonly and should never have any write methods called.
⋮----
getSubStore(addition: string): BlobStore
⋮----
async getSignedUrl(key: string): Promise&lt;SignedPostUrlInfo&gt;
⋮----
// TODO: return explicit errors here to catch more easily
async fetchBlob(key: string): Promise&lt;Blob&gt;
⋮----
async storeBlob(key: string, value: Bloblike, type: MIMETypelike): Promise&lt;string&gt;
⋮----
async writeBase64(key: string, base64: string, type: MIMETypelike): Promise&lt;string&gt;
⋮----
async deleteBlob(key: string): Promise&lt;void&gt;
⋮----
/**
 * String blobs are UTF-8 encoded strings
 * Buffer blobs are raw bytes.
 */
export type Bloblike = string | Blob | ReadableStream | Buffer | ArrayBufferLike | Response;
⋮----
/**
 * This URL lets users upload blobs directly to the storage backend.
 */
export interface SignedPostUrlInfo {
	url: string;
	/**
	 * The fields are the form fields that the user must include in the POST request.
	 */
	fields: { [key: string]: string };
}
⋮----
/**
	 * The fields are the form fields that the user must include in the POST request.
	 */
⋮----
// GPT:
async function blobFromReadableStream(readableStream: ReadableStream, type: MIMEType)
⋮----
// Create an empty array to store the chunks of data
⋮----
// Get a reader from the ReadableStream
⋮----
// Read the stream chunk by chunk
⋮----
// If done is true, we&apos;re finished reading the stream
⋮----
// Push the chunk to the array
⋮----
// Convert the chunks to a Blob
⋮----
export interface ReadonlyBlobStoreBackend {
	fetchBlob(key: string): Promise&lt;Blob | undefined&gt;;
}
⋮----
fetchBlob(key: string): Promise&lt;Blob | undefined&gt;;
⋮----
/**
 * For now, the BlobType is symmetrical between gets and sets.
 */
export interface BlobStoreBackend extends ReadonlyBlobStoreBackend {
	getSignedUrl(key: string): Promise&lt;SignedPostUrlInfo&gt;;
	fetchBlob(key: string): Promise&lt;Blob | undefined&gt;;
	storeBlob(key: string, val: Blob): Promise&lt;string&gt;;
	deleteBlob(key: string): Promise&lt;void&gt;;
}
⋮----
storeBlob(key: string, val: Blob): Promise&lt;string&gt;;
⋮----
export function toReadableStream(value: string): ReadableStream
⋮----
start(controller)
⋮----
// This is rudimentary mimetype handling, we don&apos;t take into account characters sets etc
⋮----
export type MIMEType =
	| &quot;application/pdf&quot;
	| &quot;application/json&quot;
	| &quot;text/plain&quot;
	| &quot;application/octet-stream&quot;
	| &quot;application/xml&quot;;
⋮----
// TODO proper values for these
⋮----
export type MIMETypelike = keyof typeof MIME_TYPES;
⋮----
export function blobFromPlainText(plainText: string, type: MIMEType)
export function blobFromBuffer(buffer: Buffer, type: MIMEType)
⋮----
// TODO Sort out this type violation? Seems to work, despite it
⋮----
export function blobFromArrayBuffer(arrayBuffer: ArrayBuffer, type: MIMEType)
export function blobFromBase64(base64: string, type: MIMEType)
export async function blobFromResponse(response: Response): Promise&lt;Blob&gt;
⋮----
// TODO get rid of the type error here, for the mismatch of Response.Blob and buffer.Blob
⋮----
// TODO improve test coverage for this
export async function toBlob(value: Bloblike, mimeType: MIMETypelike): Promise&lt;Blob&gt;
⋮----
export function toMIMEType(value: string): MIMEType
⋮----
export function validateBlob(val: unknown): asserts val is Blob
⋮----
export function validateBloblike(val: unknown): asserts val is Bloblike
⋮----
/**
 * This is a hack to get around the fact that the Response constructor
 * says it doesn&apos;t like the Node Blob we&apos;re passing, even though it
 * seems to handle it just fine.
 */
function thisBlobIsBodyInitCompatible(blob: Blob | unknown): asserts blob is BodyInit
⋮----
// TODO include a file name?
export function toBlobResponse(blob: Blob): Response</file><file path="lib/ts/lib-platform/src/events.contract.ts">import type { EventStoreBackend } from &quot;./events.ts&quot;;
import { generateRandomId } from &quot;./ids.ts&quot;;
import { beforeAll, describe, expect, test } from &quot;./test.ts&quot;;
import type { Pagination } from &quot;./types.ts&quot;;
⋮----
export function asEventStoreBackend(
	events: EventStoreBackend,
	beforeHandler?: () =&gt; Promise&lt;void&gt;,
)</file><file path="lib/ts/lib-platform/src/flows.test.ts">import { describe, expect, test } from &quot;vitest&quot;;
import { z } from &quot;zod&quot;;
import { ParseError } from &quot;./errors.ts&quot;;
import { toFlowSchema } from &quot;./flows.ts&quot;;
⋮----
workflow_engine: &quot;prefect&quot;, // 💩 This is a smell because `lib-platform` should be dependency-injected</file><file path="lib/ts/lib-platform/src/in-memory.ts">/**
 * These serve as reference implementations for storage interfaces that can be used in development,
 * testing and ephemeral use cases.
 */
import pino from &quot;pino&quot;;
import { Writable } from &quot;stream&quot;;
import type { AssocStoreBackend } from &quot;./assoc.ts&quot;;
import type { BlobStoreBackend, SignedPostUrlInfo } from &quot;./blob.ts&quot;;
import { Blob } from &quot;./blob.ts&quot;;
import type { EventFilter, EventStoreBackend, ReadEventStoreBackend } from &quot;./events.ts&quot;;
import json from &quot;./json.ts&quot;;
import type { KVStoreBackend } from &quot;./kv.ts&quot;;
import { Logger } from &quot;./log.ts&quot;;
import { only } from &quot;./object.ts&quot;;
import type { MessageQueueBackend } from &quot;./queue.ts&quot;;
import type { Pagination, POJO, SortDirection } from &quot;./types.ts&quot;;
⋮----
/**
 * We can introduce arbitrary delays in the storages to simulate network latency.
 */
export const delay = (ms: number)
⋮----
export function InMemoryLogger(): Logger &amp;
⋮----
write(chunk, encoding, callback)
⋮----
// Push each log message into the array
⋮----
interface SimulationOptions {
	delayMs?: number | undefined;
	fail?: Error | undefined;
	corrupted?: boolean | undefined;
}
⋮----
export class InMemoryBackend
⋮----
constructor(options: SimulationOptions =
async simulate()
⋮----
export class InMemoryEventStoreBackend extends InMemoryBackend implements EventStoreBackend
⋮----
public get events()
⋮----
private serialize(event: POJO): string
⋮----
protected deserialize(event: string): POJO
async *readEvents(pk: string, direction: SortDirection): AsyncGenerator&lt;POJO&gt;
⋮----
async addEvent(pk: string, event: POJO): Promise&lt;void&gt;
⋮----
// TODO note that this is not a real pagination implementation, it breaks when inserting while
// paginating
//
// Also, this assumes the events are already in the correct order, without an sk
async paginateEvents(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
		filter?: EventFilter,
): Promise&lt;Pagination&lt;POJO&gt;&gt;
⋮----
export class InMemeryEventStoreIndex
extends InMemoryEventStoreBackend
⋮----
/**
	 * This is a hideous implementation @jkz
	 */
public override get events()
⋮----
// Reindex the entire event backend on the fly
⋮----
constructor(
		private readonly backend: InMemoryEventStoreBackend,
		private readonly getIndex: (e: POJO) =&gt; string,
)
⋮----
export class InMemoryAssocStoreBackend extends InMemoryBackend implements AssocStoreBackend
⋮----
/**
	 * Map&lt;assocName, Map&lt;pk, string[]&gt;&gt;
	 */
⋮----
private serialize(event:
⋮----
private deserialize(event: string):
⋮----
private getAssocs(assocName: string, pk: string, direction: SortDirection): POJO[]
⋮----
async *readAssocs(assocName: string, pk: string, direction: SortDirection): AsyncGenerator&lt;POJO&gt;
async paginateAssocs(
		assocName: string,
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
): Promise&lt;Pagination&lt;POJO&gt;&gt;
async addAssoc(assocName: string, pks: string[], sk: string, e: POJO =
⋮----
export class InMemoryKVStoreBackend extends InMemoryBackend implements KVStoreBackend
⋮----
private deserialize(event: string): POJO
⋮----
async get(key: string): Promise&lt;POJO | undefined&gt;
⋮----
async set(key: string, value: POJO): Promise&lt;void&gt;
⋮----
async delete(key: string): Promise&lt;void&gt;
⋮----
export class InMemoryBlobStoreBackend extends InMemoryBackend implements BlobStoreBackend
⋮----
async getSignedUrl(key: string): Promise&lt;SignedPostUrlInfo&gt;
⋮----
async fetchBlob(key: string): Promise&lt;Blob | undefined&gt;
⋮----
async storeBlob(key: string, blob: Blob): Promise&lt;string&gt;
⋮----
// We probably want the concept of a bucket or folder to support something like this.
⋮----
async deleteBlob(key: string): Promise&lt;void&gt;
⋮----
export class InMemoryMessageQueueBackend&lt;T&gt;
extends InMemoryBackend
⋮----
async send(message: T): Promise&lt;void&gt;
⋮----
// TODO model sqs semantics? (visibility timeout, etc) Not going there because it is not clear
// we want this abstraction here anyway (if you asked Robin)
//
// Right now we use it for testing/demo purposes
receive(): T | undefined</file><file path="gateways/noggin/src/index.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import { Router } from &quot;@anterior/lib-platform/app&quot;;
import { logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
import agentsApp from &quot;./agents/main.ts&quot;;
import ahipApp from &quot;./ahip/main.ts&quot;;
import authApp from &quot;./auth/main.ts&quot;;
import chatApp from &quot;./chat/main.ts&quot;;
import flobotApp from &quot;./flobot/main.ts&quot;;
import flonotesApp from &quot;./flonotes/main.ts&quot;;
import flopilotApp from &quot;./flopilot/main.ts&quot;;
import healthApp from &quot;./health/main.ts&quot;;
import helloWorldApp from &quot;./hello-world/app.ts&quot;;
import notesApp from &quot;./notes/main.ts&quot;;
import pdfApp from &quot;./pdfs/main.ts&quot;;
import stemsApp from &quot;./stems/main.ts&quot;;
import tasksApp from &quot;./tasks/main.ts&quot;;</file><file path="lib/ts/lib-platform/src/events.test.ts">import { beforeEach, describe, expect, test } from &quot;vitest&quot;;
import { z } from &quot;zod&quot;;
import { ParseError, SerializerError, Timeout } from &quot;./errors.ts&quot;;
import { asEventStoreBackend } from &quot;./events.contract.ts&quot;;
import { EventStore, EventStreamReader, EventStreamWriter } from &quot;./events.ts&quot;;
import { generateRandomId } from &quot;./ids.ts&quot;;
import { InMemoryEventStoreBackend, InMemoryLogger } from &quot;./in-memory.ts&quot;;
⋮----
import { getZod, neverSchema, toSchema, toUnionSchema } from &quot;./schema.ts&quot;;
import { neverSerializer, typedIdentitySerializer } from &quot;./serializer.ts&quot;;
⋮----
export interface Create {
	readonly event_type: &quot;create&quot;;
}
export interface Update {
	readonly event_type: &quot;update&quot;;
	readonly value: string;
}
⋮----
type Pk = string;
⋮----
export interface Meta {
	readonly pk: Pk;
	readonly user: string;
	readonly createdAt: bigint;
}
⋮----
export type EventPayload = Create | Update;
export interface TestEvent extends Meta {
	readonly payload: EventPayload;
}
⋮----
// TODO zod is not the best tool for this. We need to validate, not parse the object here.
// const schema = toEventSchema&lt;EventPayload, Meta, TestEvent&gt;(payloadSchema, metaSchema);
⋮----
export function createTestEventStores()
⋮----
function makeStream(
		store: EventStore&lt;TestEvent&gt;,
		projectTimeoutMs?: number,
):
⋮----
// Timing out on a generator has semantic implications.</file><file path="lib/ts/lib-platform/src/events.ts">import { ParseError, SerializerError, Timeout, timeout } from &quot;./errors.ts&quot;;
import { Logger } from &quot;./log.ts&quot;;
import type { IProjector } from &quot;./projector.ts&quot;;
import { type Schema } from &quot;./schema.ts&quot;;
import type { Serializer } from &quot;./serializer.ts&quot;;
import type { Pagination, POJO, SortDirection } from &quot;./types.ts&quot;;
⋮----
// -- EVENT STORE ----------------------------------------------------------------
⋮----
export interface ReadEventStoreBackend {
	/**
	 * Fetch events by primrary key
	 */
	readEvents(pk: string, direction: SortDirection): AsyncGenerator&lt;POJO&gt;;
	/**
	 * Ideally a stateless pagination implementation, since the event store presents append-only semantics.
	 * That means that it _should_ be possible to guarantee this with a cursor
	 */
	paginateEvents(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
		filter?: EventFilter,
	): Promise&lt;Pagination&lt;POJO&gt;&gt;;
}
⋮----
/**
	 * Fetch events by primrary key
	 */
readEvents(pk: string, direction: SortDirection): AsyncGenerator&lt;POJO&gt;;
/**
	 * Ideally a stateless pagination implementation, since the event store presents append-only semantics.
	 * That means that it _should_ be possible to guarantee this with a cursor
	 */
paginateEvents(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
		filter?: EventFilter,
	): Promise&lt;Pagination&lt;POJO&gt;&gt;;
⋮----
export interface WriteEventStoreBackend {
	/**
	 * This promise should resolve when the event has been committed to storage.
	 */
	addEvent(pk: string, e: POJO): Promise&lt;void&gt;;
}
⋮----
/**
	 * This promise should resolve when the event has been committed to storage.
	 */
addEvent(pk: string, e: POJO): Promise&lt;void&gt;;
⋮----
/**
 * The actual operations a backend must implement to be considered an event storage.
 * Our first implementation is DynamoDB, but we could easily swap out for another storage backend.
 */
export interface EventStoreBackend extends ReadEventStoreBackend, WriteEventStoreBackend {}
⋮----
/**
 * Event storage provides the following guarantees:
 * - Primary Key: Streams are grouped by a primary key
 * - Fire and forget: Events are written to storage and then processed asynchronously.
 * - Strict ordering: Events are processed in the order they are written.
 * - Schema validated: Events are validated against a schema before being written and when read
 *
 * And the following limitations:
 * - Event bodies are opaque to the storage layer
 * - Event bodies can be no more than 400KB (This may be lifted in the future)
 *
 * We use mostly readonly interfaces in this file to emphasise the immutability of events.
 */
export interface EventStore&lt;E&gt; {
	readonly schema: Schema&lt;E&gt;;
	readonly serializer: Serializer&lt;E, POJO&gt;;
	/**
	 * Read all events for the primary key in the given direction. (forward by default)
	 *
	 * Throws:
	 * - NoEventsFound
	 * - BackendError
	 * - Timeout (TODO)
	 */
	readEvents(pk: string, direction?: SortDirection): AsyncGenerator&lt;E&gt;;
	/**
	 * Throws:
	 * - NoEventsFound
	 * - BackendError
	 * - Timeout (TODO)
	 * - ValidationError
	 */
	saveEvent(pk: string, e: E): Promise&lt;void&gt;;

	/**
	 * Fetch a sequence of events from the event store. Since the event store is append-only,
	 * this pagination can be stateless
	 *
	 * @param limit The maximum number of events to return per page
	 * @param direction Read events &quot;forward&quot; or &quot;backward&quot; in time
	 * @param cursor An opaque string produced and interpreted by the backend to paginate events.
	 */
	paginateEvents(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
		filter?: EventFilter,
	): Promise&lt;Pagination&lt;E&gt;&gt;;
}
⋮----
/**
	 * Read all events for the primary key in the given direction. (forward by default)
	 *
	 * Throws:
	 * - NoEventsFound
	 * - BackendError
	 * - Timeout (TODO)
	 */
readEvents(pk: string, direction?: SortDirection): AsyncGenerator&lt;E&gt;;
/**
	 * Throws:
	 * - NoEventsFound
	 * - BackendError
	 * - Timeout (TODO)
	 * - ValidationError
	 */
saveEvent(pk: string, e: E): Promise&lt;void&gt;;
⋮----
/**
	 * Fetch a sequence of events from the event store. Since the event store is append-only,
	 * this pagination can be stateless
	 *
	 * @param limit The maximum number of events to return per page
	 * @param direction Read events &quot;forward&quot; or &quot;backward&quot; in time
	 * @param cursor An opaque string produced and interpreted by the backend to paginate events.
	 */
paginateEvents(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
		filter?: EventFilter,
	): Promise&lt;Pagination&lt;E&gt;&gt;;
⋮----
export class EventStore&lt;E&gt;
⋮----
constructor(
⋮----
async *readEvents(pk: string, direction: SortDirection): AsyncGenerator&lt;E&gt;
⋮----
async paginateEvents(
		pk: string,
		limit: number,
		direction: SortDirection,
		cursor?: string,
		filter?: EventFilter,
): Promise&lt;Pagination&lt;E&gt;&gt;
⋮----
async saveEvent(pk: string, event: E): Promise&lt;void&gt;
⋮----
// -- EVENT STREAM ---------------------------------------------------------------
⋮----
/**
 * A reader for events with a specific primary key. When we don&apos;t have all the requisite metadata,
 * we can&apos;t write events, but we could still read them
 */
export interface EventStreamReader&lt;TEvent, TPk extends string&gt; {
	readonly pk: TPk;

	readEvents(): AsyncGenerator&lt;TEvent&gt;;
	project&lt;T&gt;(projectors: IProjector&lt;T, TEvent&gt;): Promise&lt;T&gt;;
	paginateEvents(
		limit: number,
		direction: SortDirection,
		cursor?: string,
	): Promise&lt;Pagination&lt;TEvent&gt;&gt;;
	// TODO support rolling up from existing state
	// project&lt;R&gt;(projectors: Projectors&lt;R, P&gt;, state: R | null): Promise&lt;R&gt;;
}
⋮----
readEvents(): AsyncGenerator&lt;TEvent&gt;;
project&lt;T&gt;(projectors: IProjector&lt;T, TEvent&gt;): Promise&lt;T&gt;;
paginateEvents(
		limit: number,
		direction: SortDirection,
		cursor?: string,
	): Promise&lt;Pagination&lt;TEvent&gt;&gt;;
// TODO support rolling up from existing state
// project&lt;R&gt;(projectors: Projectors&lt;R, P&gt;, state: R | null): Promise&lt;R&gt;;
⋮----
export interface EventStreamWriter&lt;TEvent, TPk extends string, TPayload&gt; {
	readonly instantiateEvent: (payload: TPayload) =&gt; TEvent;

	/**
	 * Store a new event in event storage.
	 */
	save&lt;T extends TPayload&gt;(payload: T): Promise&lt;void&gt;;
}
⋮----
/**
	 * Store a new event in event storage.
	 */
save&lt;T extends TPayload&gt;(payload: T): Promise&lt;void&gt;;
⋮----
export class EventStreamWriter&lt;TEvent, TPk, TPayload&gt;
⋮----
constructor(
		logger: Logger,
		private readonly store: EventStore&lt;TEvent&gt;,
		public readonly pk: TPk,
		public readonly instantiateEvent: (payload: TPayload) =&gt; TEvent,
)
⋮----
/**
	 * Store a new event in event storage.
	 */
async save&lt;T extends TPayload&gt;(payload: T): Promise&lt;void&gt;
⋮----
// Rely on error handling/logging in addEvent. Moved them there as the single point of entry
⋮----
/**
 * An event stream models the collection of events for a single &quot;topic&quot;, indicated by a primary key.
 */
export class EventStreamReader&lt;TEvent, TPk extends string&gt;
⋮----
constructor(
		logger: Logger,
		private readonly store: EventStore&lt;TEvent&gt;,
		public readonly pk: TPk,
		public readonly projectTimeoutMs: number = 5000,
)
⋮----
async *readEvents(direction: SortDirection = &quot;forward&quot;): AsyncGenerator&lt;TEvent&gt;
⋮----
async paginateEvents(
		limit: number,
		direction: SortDirection,
		cursor?: string,
		filter?: EventFilter,
): Promise&lt;Pagination&lt;TEvent&gt;&gt;
⋮----
async project&lt;T&gt;(projector: IProjector&lt;T, TEvent&gt;): Promise&lt;T&gt;
⋮----
// Since rollups are sync at the moment, we read all events first
// I would like to see an event stream large enough before we optimize this
⋮----
/**
 * For now we only support event[key] in [...values] filters
 */
export type EventFilter = { [K: string]: any[] };</file><file path="gateways/noggin/src/stems/schemas/events.ts">import { toUnionSchema } from &quot;@anterior/lib-platform/schema&quot;;
import { typedIdentitySerializer } from &quot;@anterior/lib-platform/serializer&quot;;
import {
	attachClinicalsToStemV11,
	type AttachClinicalsToStemV11,
} from &quot;../../@anterior/models/events/stems/attach_clinicals_to_stem_v1_1.ts&quot;;
import {
	attachCriteriaToStemV11,
	type AttachCriteriaToStemV11,
} from &quot;../../@anterior/models/events/stems/attach_criteria_to_stem_v1_1.ts&quot;;
import {
	attachServicesToStemV11,
	type AttachServicesToStemV11,
} from &quot;../../@anterior/models/events/stems/attach_services_to_stem_v1_1.ts&quot;;
import {
	createDeterminationV11,
	type CreateDeterminationV11,
} from &quot;../../@anterior/models/events/stems/create_determination_v1_1.ts&quot;;
import {
	createStemV11,
	type CreateStemV11,
} from &quot;../../@anterior/models/events/stems/create_stem_v1_1.ts&quot;;
import { stemLogV11, type StemLogV11 } from &quot;../../@anterior/models/events/stems/stem_log_v1_1.ts&quot;;
import { type StemMetaV11 } from &quot;../../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { toEventSchema } from &quot;../events/to-event-schema.ts&quot;;
⋮----
export interface EventPayload {
	event_type: string;
}
⋮----
export interface Event&lt;TPayload extends EventPayload&gt; extends StemMetaV11 {
	created_at: bigint;
	data: TPayload;
}
⋮----
export type StemEventPayloads =
	| CreateStemV11
	| AttachServicesToStemV11
	| AttachClinicalsToStemV11
	| AttachCriteriaToStemV11
	| CreateDeterminationV11
	| StemLogV11;
⋮----
export type StemEvents = Event&lt;StemEventPayloads&gt;;</file><file path="gateways/noggin/src/tasks/utils/artifacts.ts">import config from &quot;@anterior/lib-infra/config&quot;;
import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import { ListObjectsV2Command, PutObjectCommand, S3Client } from &quot;@aws-sdk/client-s3&quot;;
import { dirname } from &quot;node:path&quot;;
import { z } from &quot;zod&quot;;
import type { FhirObject } from &quot;../schemas&quot;;
⋮----
// all ant queries begin with this ant:// prefix
⋮----
// read the platform bucket
⋮----
// TBD: @asim - remove this later
// this is being done in the absence of a true artifacts store
// all ant queries are actually scoped to bucket/artifacts for the time being
⋮----
// use this s3 client
⋮----
export type ArtifactCategory = (typeof categoryMap)[number];
⋮----
// these are all the parts that make up an artifact store query
// e.g. `ant://optum-workspace-id/clinicals/artifact_123/some_artifact_123.raw.pdf`
// workspaceUid = optum-workspace-id
// category = clinicals
// sourceId = artifact_123
// artifactId = some_artifact_123
// queryParams = {&apos;type&apos;: [&apos;pdf&apos;, &apos;raw&apos;] }
⋮----
type ParsedAntQuery = {
	workspaceUid: string | undefined;
	category?: string | undefined;
	sourceId?: string | undefined;
	artifactId?: string | undefined;
	queryParams: Record&lt;string, string[]&gt;;
};
⋮----
/*********************************************************************************************
 * list all keys in the specified bucket
 * @param keyPrefix - the key on the bucket you&apos;d like to access
 * @returns a list of strings that represent all the keys matching this prefix
 *********************************************************************************************/
const lsS3 = async (keyPrefix: string, bucketName: string = bucket): Promise&lt;string[]&gt; =&gt;
⋮----
/**********************************************************************************************
 * list paths on the artifact store
 * @param antQuery the various parts that make up a path in the artifact store
 * @returns a list of ant:// queries representing matching items
 *********************************************************************************************/
const lsArtifactStore = async (antQuery: ParsedAntQuery): Promise&lt;string[]&gt; =&gt;
⋮----
// given all the parts in the antQuery, formulate an actual key on S3
// the filter and join operations ensure any missing or undefined parts are ignored
// this `keyPrefix` will look like: `/artifacts/&lt;workspace_uid&gt;/clinicals`
⋮----
// these are all valid parts of ant query
⋮----
// filetypes will be used to filter the results from s3
⋮----
// ok, let&apos;s `ls` the s3 bucket using the keyPrefix composed earlier
// this will give us all the keys on the s3 bucket that match this keyPrefix
// since the `bucketKeyScope` is an s3-only construct, let&apos;s replace that in the
// final ant path that we formulate
⋮----
// if the parsed ant query does not specify any file types
// and a sourceId level of specificity is required =&gt; return the blobKeys as they are
// but if the source ID is not specified, then get unique paths that represent &apos;directories&apos;
// --&gt; so no files will get included. Since files can only be more specific than source ID
⋮----
// finally, filter the blob keys based on the file types requested
⋮----
/**********************************************************************************************
 * Get the vault queries for a given workspace UID
 * @param workspaceUid wkspace UID
 * @param filter the artifact category to filter by
 * @returns a list of ant:// paths scoped down to the clinicals + determinations
 *********************************************************************************************/
export const getArtifactStoreForWorkspace = async (
	workspaceUid: string,
	filter: ArtifactCategory,
) =&gt;
⋮----
// skippable e.g. ant://optum_wks/clinicals --&gt; that&apos;s the root
// path to the clinicals, we don&apos;t need to return this. We need
// everything else, that&apos;s inside it.
⋮----
// a Vault view of the artifact store, scopes everything down
// to the &apos;clinicals&apos; in a workspace
⋮----
// now lets remove skipThis from it, and get uniques only
⋮----
// anything in &apos;results&apos;? great, lets add it to the response
⋮----
export const getArtifactsFor = async (sourceIdQuery: string, workspaceUid: string, tag: string) =&gt;
⋮----
// convert to s3 keyPrefix
⋮----
export const storeArtifact = async (
	workspaceUid: string,
	category: ArtifactCategory,
	object: FhirObject,
) =&gt;</file><file path="gateways/noggin/src/chat/app.ts">import {
	App,
	type AppOptions,
	type EndpointSignature,
	type RequestContext,
} from &quot;@anterior/lib-platform/app&quot;;
import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import { type Logger } from &quot;@anterior/lib-platform/log&quot;;
⋮----
import type Anthropic from &quot;@anthropic-ai/sdk&quot;;
import { pdfSectionV0120250514 } from &quot;../@anterior/models/shared/pdf_section_v01_20250514.ts&quot;;
import { parseAuthInfo } from &quot;../auth/jwt.ts&quot;;
import {
	extractsSchema,
	type Block,
	type BoundingBox,
	type ExtractBlock,
} from &quot;./models/extracts.ts&quot;;
import {
	chatRequestBodySchema,
	type ChatMessage,
	type ChatRequestBody,
	type ContentBlock,
} from &quot;./models/message.ts&quot;;
import { AnthropicOrchestrator } from &quot;./orchestrator/index.ts&quot;;
import type { Platform } from &quot;./platform.ts&quot;;
⋮----
type ExtractBlocksByPdfId = Record&lt;string, ExtractBlock[]&gt;;
⋮----
export const boundingBoxFromVertices = (block: Block): BoundingBox =&gt;
⋮----
interface BuildS3PdfPathArgs {
	enterpriseUid: string;
	stemId: string;
	pdfId: string;
	filename: string;
}
⋮----
function buildS3PdfPath(
⋮----
export function createLlmMessages({
	userMessage,
	inputExtractsXml,
	previousMessages,
}: {
	userMessage: string;
	inputExtractsXml: string;
	previousMessages: ChatMessage[];
}): ChatMessage[]
⋮----
// To avoid the assistant from giving a preamble
// https://docs.anthropic.com/en/docs/test-and-evaluate/strengthen-guardrails/increase-consistency#example-daily-sales-report
⋮----
export interface ChatAppContext {
	logger: Logger;
	platform: Platform;
	anthropic: Anthropic;
}
⋮----
export interface ChatAppService {
	POST: {
		&quot;/&quot;: EndpointSignature&lt;ChatRequestBody, Response&gt;;
	};
}
⋮----
export type ChatApp = App&lt;ChatAppService, ChatAppContext&gt;;
⋮----
export function createChatApp(baseCtx: ChatAppContext, options: AppOptions): ChatApp
⋮----
async handler(ctx)
⋮----
// NB: We are re-fetching the extracts for each chat message from S3
// This can slow the request a bit, profile before you optimize
⋮----
// Need to add the user message to the response
const responseMessages = [...ctx.body.messages]; // shallow copy
⋮----
/**
 * This is a helper function that fetches the extracts for a list of pdfs from S3.
 * This can later be done via a query to the citations store.
 *
 * @returns Map of pdfId to ExtractBlocks[]
 */
async function getExtractsByPdfId(
	// eslint-disable-next-line @typescript-eslint/no-empty-object-type
	ctx: RequestContext&lt;ChatAppContext, &quot;/&quot;, {}, unknown, unknown, ChatRequestBody&gt;,
): Promise&lt;ExtractBlocksByPdfId&gt;
⋮----
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
⋮----
// Build XML string for all pdf extracts
function buildExtractsXml(pdfExtractBlocksContainer: ExtractBlocksByPdfId): string
⋮----
function getAllTextFromChatMessage(message: ChatMessage): string</file><file path="gateways/noggin/src/chat/orchestrator/anthropic.ts">import { generateRandomId } from &quot;@anterior/lib-platform/ids&quot;;
import type { Logger } from &quot;@anterior/lib-platform/log&quot;;
import type Anthropic from &quot;@anthropic-ai/sdk&quot;;
import type { Messages, ToolUseBlock } from &quot;@anthropic-ai/sdk/resources/messages&quot;;
import type { ChatMessage } from &quot;../models/message.ts&quot;;
import type { Platform } from &quot;../platform.ts&quot;;
import { MnrTool, type MnrToolInput } from &quot;./tools/mnr.ts&quot;;
import type { IOrchestrator, OrchestratorContext } from &quot;./types.ts&quot;;
⋮----
export interface AnthropicOrchestratorContext extends OrchestratorContext {
	anthropic: Anthropic;
}
⋮----
export const SYSTEM_PROMPT = &quot;You are a helpful utilization management nurse.&quot;; // TODO: Improve system prompt
⋮----
export class AnthropicOrchestrator implements IOrchestrator
⋮----
constructor(context: AnthropicOrchestratorContext)
⋮----
private getTools(): Messages.Tool[]
⋮----
// return [this.mnrTool.getToolDefinition()];
⋮----
private async handleToolCalls(toolCall: Messages.ToolUseBlock): Promise&lt;string&gt;
⋮----
async processChat(messages: ChatMessage[]): Promise&lt;ChatMessage&gt;
⋮----
// Assuming there&apos;s always only one tool use block for now
⋮----
function convertToAnthropicMessage(message: ChatMessage): Anthropic.MessageParam</file><file path="gateways/noggin/src/tasks/platform.ts">import { BlobStore, type BlobStoreBackend } from &quot;@anterior/lib-platform/blob&quot;;
import type { EventStoreBackend } from &quot;@anterior/lib-platform/events&quot;;
import { EventStore } from &quot;@anterior/lib-platform/events&quot;;
import {
	InMemoryBlobStoreBackend,
	InMemoryEventStoreBackend,
	InMemoryMessageQueueBackend,
} from &quot;@anterior/lib-platform/in-memory&quot;;
import { Logger, logger } from &quot;@anterior/lib-platform/log&quot;;
import type { MessageQueue } from &quot;@anterior/lib-platform/queue&quot;;
import { toSchema } from &quot;@anterior/lib-platform/schema&quot;;
import { TaskScheduler } from &quot;@anterior/lib-platform/tasks&quot;;
import type { POJO } from &quot;@anterior/lib-platform/types&quot;;
import { stemEventSchema, stemEventSerializer, type StemEvents } from &quot;../stems/schemas/events.ts&quot;;
import {
	igg_workflo,
	mnr_task,
	populate_note_template_task,
	validate_clinicals_task,
	type IGGWorkflo,
	type MNRTask,
	type PopulateNoteTemplateTask,
	type ValidateClinicalsTask,
} from &quot;./schemas.ts&quot;;
⋮----
/**
 * Infrastructure interface defining the external resources needed by the platform.
 *
 * The platform can be deployed in different environments:
 * - Production: Resources managed by CDK/Terraform
 * - Docker/CI: Resources managed by Docker Compose
 * - Local/Testing: Resources represented by in-memory implementations
 *
 * This abstraction allows for environment-specific implementations
 * while maintaining a consistent interface for the application.
 */
export interface Infra {
	readonly logger: Logger;
	readonly blobs: BlobStoreBackend;
	readonly taskQueue: MessageQueue&lt;POJO&gt;;
	readonly events: EventStoreBackend;
}
⋮----
/**
 * Creates an in-memory implementation of the infrastructure.
 *
 * This is not meant for production use! The in-memory implementation
 * is useful for:
 * - Unit testing: Fast, isolated test environment
 * - Local development: Quick setup without external dependencies
 *
 * Note that all data is lost when the process exits.
 */
export function getInMemoryInfra(): Infra
⋮----
/**
 * Application layer interface to the resource backends.
 *
 * This interface provides type-safe access to:
 * - Blob storage: For storing note payloads and metadata
 *
 * The interface ensures that all platform operations are properly
 * typed and validated against their schemas.
 *
 * Note the duplication below. Maybe a better solution might be a task scheduler
 * that accepts multiple different tasks, instead of repeating one-by-one.
 */
export interface Stores {
	readonly blobs: BlobStore;
	readonly events: EventStore&lt;StemEvents&gt;;
}
⋮----
export function getMnrTaskScheduler(infra: Infra): TaskScheduler&lt;MNRTask&gt;
⋮----
export function getIggTaskScheduler(infra: Infra): TaskScheduler&lt;IGGWorkflo&gt;
⋮----
export function getValidateClinicalsTaskScheduler(
	infra: Infra,
): TaskScheduler&lt;ValidateClinicalsTask&gt;
⋮----
export function getPopulateNoteTemplateTaskScheduler(
	infra: Infra,
): TaskScheduler&lt;PopulateNoteTemplateTask&gt;
⋮----
/**
 * Core platform implementation for the Tasks application.
 *
 * The platform provides:
 * 1. Factory methods for creating platform instances
 * 2. Type-safe access to storage and flow services
 * 3. Environment-specific resource management
 */
export class Platform
⋮----
/**
	 * Creates an in-memory platform instance for testing.
	 *
	 * This method allows for partial infrastructure overrides,
	 * making it easy to mock specific components while using
	 * real implementations for others.
	 */
public static inMemory(infra: Partial&lt;Infra&gt; =
⋮----
/**
	 * Creates a platform instance from infrastructure configuration.
	 *
	 * This method:
	 * 1. Sets up the message queue for flow scheduling
	 * 2. Initializes blob storage for note data
	 * 3. Configures proper serialization and validation
	 */
public static fromInfra(infra: Infra): Platform
⋮----
constructor(
⋮----
/**
	 * Type-safe access to the blob storage service.
	 * Used for storing and retrieving note data.
	 */
get blobs(): BlobStore</file><file path="gateways/noggin/src/tasks/schemas.ts">import { getZod, type SchemaLike, toUnionSchema } from &quot;@anterior/lib-platform/schema&quot;;
import { z } from &quot;@anterior/lib-platform/zod&quot;;
import { type PatientR5, patientR5 } from &quot;../@anterior/models/data/fhir/r5/patient_r5.ts&quot;;
import {
	serviceRequestR5,
	type ServiceRequestR5,
} from &quot;../@anterior/models/data/fhir/r5/service_request_r5.ts&quot;;
⋮----
export type FhirObject = PatientR5 | ServiceRequestR5;
⋮----
/** API ENDPOINT SCHEMAS **/
⋮----
export type MNRTask = Readonly&lt;z.infer&lt;typeof mnr_task&gt;&gt;;
⋮----
// IGG
export interface IGGWorkflo {
	readonly config: {
		readonly workflo_meta: {
			readonly name: string;
			readonly idempotency_key: string;
			readonly scheduled_at: string; // ISO8601 datetime string
		};
		readonly source_meta: {
			readonly stem_uid: string;
			readonly user_uid: string;
			readonly enterprise_uid: string;
			readonly workspace_uid: string;
			readonly workstream_id: string;
			readonly product_id: string;
			readonly trace_id: string;
		};
		readonly workspace_config: object;
	};
	readonly criteria_query: string;
}
⋮----
readonly scheduled_at: string; // ISO8601 datetime string
⋮----
export type ValidateClinicalsTask = Readonly&lt;z.infer&lt;typeof validate_clinicals_task&gt;&gt;;
⋮----
// NB: keeping this payload schema as light as possible to avoid
// stuffing deprecatable cruft from legacy tasks
// we can add to it as needed -po 2025-05-22
⋮----
export type PopulateNoteTemplateTask = Readonly&lt;z.infer&lt;typeof populate_note_template_task&gt;&gt;;</file><file path="gateways/noggin/src/tasks/app.ts">import {
	App,
	createStaticApp,
	type AppOptions,
	type EndpointSignature,
} from &quot;@anterior/lib-platform/app&quot;;
import { type Logger } from &quot;@anterior/lib-platform/log&quot;;
import z from &quot;zod&quot;;
import { attachClinicalsToStemV11 } from &quot;../@anterior/models/events/stems/attach_clinicals_to_stem_v1_1.ts&quot;;
import { attachServicesToStemV11 } from &quot;../@anterior/models/events/stems/attach_services_to_stem_v1_1.ts&quot;;
import { stemMetaV11 } from &quot;../@anterior/models/events/stems/stem_meta_v1_1.ts&quot;;
import { parseAuthInfo } from &quot;../auth/jwt.ts&quot;;
import { useOrMintStemId } from &quot;../stems/utils/common.ts&quot;;
import { runMnr } from &quot;./handlers/mnr.ts&quot;;
import { populateNoteTemplate } from &quot;./handlers/populate-note-template.ts&quot;;
import { projectLogsForStem } from &quot;./handlers/project-log-events.ts&quot;;
import { runIgg } from &quot;./handlers/run-igg.ts&quot;;
import { validateClinicals } from &quot;./handlers/validate-clinicals.ts&quot;;
import { tasksBlob } from &quot;./infra.ts&quot;;
import type { Platform } from &quot;./platform.ts&quot;;
import { fhirObject } from &quot;./schemas.ts&quot;;
import {
	artifactCategorySchema,
	getArtifactStoreForWorkspace,
	getArtifactsFor,
	storeArtifact,
} from &quot;./utils/artifacts.ts&quot;;
⋮----
export interface TasksAppContext {
	logger: Logger;
	platform: Platform;
}
⋮----
export interface TasksAppService {
	GET: {
		&quot;/&quot;: EndpointSignature&lt;object, object&gt;;
		&quot;/artifacts/:category&quot;: EndpointSignature&lt;object, object&gt;;
		&quot;/logs/:stemId&quot;: EndpointSignature&lt;object, object&gt;;
	};
	POST: {
		&quot;/artifacts/:category&quot;: EndpointSignature&lt;object, { stemId: string; query: string }&gt;;
		&quot;/mnr/actions/run&quot;: EndpointSignature&lt;object, { stemId: string }&gt;;
		&quot;/validate-clinicals/actions/run&quot;: EndpointSignature&lt;object, { stemId: string }&gt;;
		&quot;/igg/actions/run&quot;: EndpointSignature&lt;object, void&gt;;
		&quot;/populate-note-template/actions/run&quot;: EndpointSignature&lt;object, { stemId: string }&gt;;
	};
}
⋮----
// TODO borrowing the schema from the attach-clinicals event. This should be defined in the `lib-platform`
⋮----
export type TasksApp = App&lt;TasksAppService, TasksAppContext&gt;;
⋮----
export function createTasksApp(baseCtx: TasksAppContext, options: AppOptions): TasksApp
⋮----
// while we&apos;re exposing scheduleable tasks defined in platform/workflows via separate endpoints below,
// what we&apos;re working toward is a single endpoint (e.g. /chats or /consults) that can infer which
// task (or &quot;tool&quot;) to use based on the &quot;stem&quot; (chat context, attachments, latest user prompt)
//
// for now, it&apos;s useful to have separate API-accessible endpoints that can be used to trigger specific
// tasks explicitly. next step will be to prepare the &quot;agent&quot; that can infer from a stem which task (if any)
// is appropriate to use given the enterprise/workspace&apos;s available tasks
⋮----
// TODO: how will we determine which noteTemplate (e.g. outpatient, inpatient, etc.) to use?
// we will somehow need to let the user know which note templates are available in the first place,
// and tell them if something they&apos;re asking for isn&apos;t something we can provide
//
// we *could* pass a noteTemplateId through here, but ideally fetch it from the stem assuming it&apos;s been
// attached by the time the populate_note_template task is being run
//
// need to decide which errors we want to surface synchronously (as part of the http response), and which
// ones we&apos;re okay with raising async (while the task is being run)
⋮----
// Criteria - Parse to IGG - see NOTES in run-igg-raw.ts
⋮----
// Other
⋮----
// Serve static files from s3, including assets.
// See createStaticApp for more details, in lib/ts/lib-platform/app.ts</file></files><instruction># Comprehensive Hono.js TypeScript Codebase Analysis

You are an expert TypeScript developer specializing in Hono.js web applications. Analyze this codebase and provide a comprehensive understanding across all critical dimensions.

## Analysis Framework

### 1. **Architecture &amp; Structure Assessment**

- **API Design**: Evaluate routing patterns, endpoint organization, and RESTful compliance
- **Middleware Stack**: Analyze middleware usage, custom middleware implementations, and execution flow
- **Type Safety**: Review TypeScript usage, type definitions, generic patterns, and type inference
- **Modularity**: Assess code organization, dependency injection patterns, and separation of concerns
- **Hono.js Patterns**: Identify framework-specific best practices and anti-patterns

### 2. **Technical Deep Dive**

- **Performance Analysis**:
  - Identify bottlenecks in route handlers and middleware
  - Evaluate streaming, caching, and response optimization
  - Review database query patterns and connection handling
- **Security Review**:
  - Authentication/authorization implementation
  - Input validation and sanitization
  - CORS configuration and security headers
  - Rate limiting and DDoS protection
- **Error Handling**: Exception patterns, logging strategies, and user-facing error responses

### 3. **Code Quality Metrics**

Rate each area (1-10) with justification:

- **Type Safety**: Strictness, coverage, and effectiveness
- **Maintainability**: Code readability, documentation, and refactoring ease
- **Testability**: Unit/integration test coverage and quality
- **Performance**: Response times, resource utilization, scalability
- **Security**: Vulnerability prevention and best practices adherence

### 4. **Hono.js Specific Analysis**

- **Context Usage**: Proper use of `c.get()`, `c.set()`, and context passing
- **Bindings**: Environment variables, database connections, and service integrations
- **Validators**: Input validation strategies using Hono validators or Zod
- **Middleware Chains**: Custom middleware implementation and third-party integrations
- **Runtime Compatibility**: Cloudflare Workers, Deno, Node.js optimization

## Output Requirements

### Executive Summary (3-4 sentences)

- Overall architecture quality score (1-10)
- Top 2 strengths and top 2 critical issues
- Deployment readiness assessment

### Detailed Findings

For each major component/module:

1. **Purpose &amp; Responsibility**
2. **Implementation Quality** (with specific examples)
3. **Integration Points** and dependencies
4. **Improvement Opportunities** (prioritized by impact)

### Visual Architecture Map

Create a text-based diagram showing:

- Request flow through middleware stack
- Key components and their relationships
- Data flow patterns
- External service integrations

### Actionable Recommendations

Prioritize by impact (High/Medium/Low):

- **Immediate Fixes**: Critical issues requiring urgent attention
- **Performance Optimizations**: Specific bottlenecks and solutions
- **Security Enhancements**: Vulnerability remediation steps
- **Code Quality Improvements**: Refactoring opportunities
- **Testing Gaps**: Missing test coverage areas

### Implementation Roadmap

Provide a phased approach:

- **Phase 1** (1-2 weeks): Critical fixes and security issues
- **Phase 2** (1 month): Performance optimizations and testing
- **Phase 3** (2-3 months): Architecture improvements and technical debt

## Analysis Constraints

- Focus on production-readiness and scalability
- Consider Hono.js ecosystem compatibility
- Evaluate TypeScript best practices alignment
- Assess cloud deployment suitability (especially Cloudflare Workers)
- Include specific code examples for recommendations

## Response Format

Use clear headings, bullet points for lists, and code blocks for examples. Include confidence levels for assessments where uncertainty exists.
</instruction></repomix>
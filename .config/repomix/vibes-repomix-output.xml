This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.ts, **/package.json, **/tsconfig.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  agents/
    src/
      components/
        icons/
          types.ts
      copytext/
        index.ts
      lib/
        constants.ts
        utils.ts
      requests/
        artifacts.ts
        identify-indication.ts
        mnr.ts
        mocks.ts
        select-relevant-criteria.ts
        stem-logs.ts
        util.ts
        validate-clinicals.ts
      routeTree.gen.ts
      types.ts
      vite-env.d.ts
    package.json
    tsconfig.json
    vite.config.ts
  ahip-super/
    src/
      components/
        icons/
          types.ts
      controller/
        agents/
          agents-controller.ts
        models/
          draft-agent.ts
        supervise-agent-controller.ts
        supervise-agents-controller.ts
      hooks/
        use-infinite-scroll.ts
        use-mobile.ts
      lib/
        tag-colors.ts
        utils.ts
      view/
        agents/
          builder/
            steps/
              index.ts
              types.ts
      env.ts
      reportWebVitals.ts
      routeTree.gen.ts
    package.json
    tsconfig.json
    vite.config.ts
  atlas/
    src/
      components/
        icons/
          types.ts
      controller/
        handlers/
          fetch-artifacts.ts
        models/
          pdf-extracts.ts
          pdf-status.ts
          process-pdf.ts
        use-artifacts.ts
        use-pdf-process-controller.ts
      hooks/
        use-infinite-scroll.ts
        use-mobile.ts
      lib/
        tag-colors.ts
        utils.ts
      env.ts
      reportWebVitals.ts
      routeTree.gen.ts
    package.json
    tsconfig.json
    vite.config.ts
  flonotes/
    neuron/
      hooks/
        use-mobile.ts
      icons/
        types.ts
      react/
        index.ts
      utils.ts
    src/
      components/
        shell/
          notes/
            config/
              editor-config.ts
              templates.ts
            hooks/
              use-editor-callbacks.ts
            styles/
              index.ts
            utils/
              editor-utils.ts
              parser.ts
            extension-insert.ts
          pdf/
            hooks/
              use-throttled-scroll.ts
            providers/
              citations/
                types.ts
                use-highlights.ts
      hooks/
        use-pdf-storage.ts
        use-process-pdf.ts
      indexed-db/
        db.ts
      services/
        noggin-api.ts
      types/
        pdf-worker.d.ts
      utils/
        rotate-vertices.ts
      routeTree.gen.ts
    package.json
    tsconfig.json
    vite.config.ts
  flopilot/
    src/
      env.ts
      reportWebVitals.ts
      routeTree.gen.ts
    package.json
    tsconfig.json
    vite.config.ts
  mnr-determination-viewer/
    src/
      env.ts
      reportWebVitals.ts
      routeTree.gen.ts
    package.json
    tsconfig.json
  shell/
    src/
      reportWebVitals.ts
      vite-env.d.ts
    package.json
    tsconfig.json
    vite.config.ts
lib/
  neuron/
    src/
      icons/
        types.ts
      react/
        index.ts
      index.ts
      utils.ts
    package.json
    tsconfig.json
  shared/
    flopilot/
      components/
        icons/
          types.ts
        ui/
          pdf/
            hooks/
              use-throttled-scroll.ts
            providers/
              citations/
                schemas.ts
                use-highlights.ts
      controller/
        indexed-db/
          db.ts
        models/
          llm-message.ts
          note-template.ts
          sections.ts
          user-message.ts
        utils/
          llm-mesasge.ts
        use-chat-controller.ts
        use-create-stem-controller.ts
        use-flopilot-stem-controller.ts
        use-prompt-controller.ts
        use-saved-prompt-controller.ts
        use-upload-artifacts-controller.ts
      hooks/
        use-mobile.ts
        use-save-prompt-state.ts
      lib/
        format-compact-number.ts
        utils.ts
      types/
        initial-message-type.ts
        saved-prompt.ts
      view/
        anterior-prompts/
          saved-prompts-db.ts
          types.ts
        artifact-viewer/
          tiptap/
            editor-config.ts
      env.ts
    package.json
    tsconfig.json
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/atlas/src/components/icons/types.ts">
export interface IconProps extends React.SVGAttributes<SVGElement> {
  children?: never;
  color?: string;
}
</file>

<file path="apps/atlas/src/controller/models/pdf-extracts.ts">
import { z } from "zod";

export const pdfExtractsResponseSchema = z.object({
  result: z.object({
    extracts: z.array(
      z.object({
        text: z.string(),
      }),
    ),
  }),
});

export type PdfExtractsResponse = z.infer<typeof pdfExtractsResponseSchema>;
</file>

<file path="apps/atlas/src/controller/models/pdf-status.ts">
import { z } from "zod";

export const pdfStatusResponseSchema = z.object({
  status: z.enum(["processing", "ready", "error"]),
  message: z.string().optional(),
});

export type PdfStatusResponse = z.infer<typeof pdfStatusResponseSchema>;
</file>

<file path="apps/atlas/src/controller/models/process-pdf.ts">
import { z } from "zod";

export const pdfProcessResponseSchema = z.object({
  stemUid: z.string(),
  pdfUid: z.string(),
});

export type PdfProcessResponse = z.infer<typeof pdfProcessResponseSchema>;
</file>

<file path="apps/atlas/src/controller/use-pdf-process-controller.ts">
import { env } from "@/env";
import { useMutation, useQuery } from "@tanstack/react-query";
import { useState } from "react";
import {
  pdfProcessResponseSchema,
  type PdfProcessResponse,
} from "./models/process-pdf";
import { pdfStatusResponseSchema } from "./models/pdf-status";

export type PdfDetails = {
  stemUid: string;
  pdfUid: string;
};

const PDF_PROCESS_KEY = ["pdf-process"] as const;
const PDF_PROCESS_STATUS_KEY = ["pdf-process-status"] as const;

export const usePdfProcessController = () => {
  const [attachedFile, setAttachedFile] = useState<File | null>(null);
  const [pdfDetails, setPdfDetails] = useState<PdfDetails | null>(null);

  const { mutateAsync: processPdf, data: pdfProcessData } = useMutation<
    PdfProcessResponse,
    Error,
    File
  >({
    mutationKey: PDF_PROCESS_KEY,
    mutationFn: async (file: File) => {
      const formData = new FormData();
      formData.append("file", file);

      const response = await fetch(`${env.VITE_NOGGIN_HOST}/pdfs/process-pdf`, {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(
          error.details || error.error || "Failed to upload file",
        );
      }

      return pdfProcessResponseSchema.parse(await response.json());
    },
  });

  const { isFetching, data } = useQuery({
    queryKey: PDF_PROCESS_STATUS_KEY,
    enabled: pdfProcessData !== undefined,
    queryFn: async () => {
      if (pdfProcessData === undefined) {
        throw new Error("PDF process data must be available");
      }

      const response = await fetch(
        `${env.VITE_NOGGIN_HOST}/pdfs/pdf-status/${pdfProcessData.stemUid}/${pdfProcessData.pdfUid}`,
        {
          method: "GET",
        },
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(
          error.details || error.error || "Failed to fetch PDF status",
        );
      }

      const data = pdfStatusResponseSchema.parse(await response.json());

      if (data.status === "error") {
        throw new Error(data.message || "Failed to process PDF");
      }

      return data;
    },
    refetchInterval: (query) => {
      if (query.state.data?.status === "processing") {
        return 5_000;
      }
      return false;
    },
  });

  const handlePdfChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      setAttachedFile(file);
      const result = await processPdf(file);
      setPdfDetails(result);
    }
  };

  const handleRemovePdf = () => {
    setAttachedFile(null);
    setPdfDetails(null);
  };

  return {
    isPdfProcessing: isFetching || data?.status === "processing",
    pdfDetails,
    attachedFile,
    onPdfChange: handlePdfChange,
    onRemovePdf: handleRemovePdf,
  };
};
</file>

<file path="apps/atlas/src/hooks/use-infinite-scroll.ts">
import { useCallback, useEffect } from "react";
import { useInView } from "react-intersection-observer";

/**
 * A custom hook that implements infinite scrolling functionality using the Intersection Observer API.
 * It triggers the next page fetch when the user scrolls near the bottom of the content.
 *
 * @param hasNextPage - Boolean indicating if there are more pages to fetch
 * @param isFetchingNextPage - Boolean indicating if the next page is currently being fetched
 * @param fetchNextPage - Function to call when the next page should be fetched
 * @returns An object containing:
 *   - ref: A ref to attach to the element that should trigger infinite scroll
 *   - inView: Boolean indicating if the observed element is in view
 */
export function useInfiniteScroll(
  hasNextPage: boolean,
  isFetchingNextPage: boolean,
  fetchNextPage: () => void,
) {
  const { ref, inView } = useInView();

  const debouncedFetchNextPage = useCallback(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  useEffect(() => {
    const timer = setTimeout(debouncedFetchNextPage, 100);
    return () => clearTimeout(timer);
  }, [debouncedFetchNextPage]);

  return { ref, inView };
}
</file>

<file path="apps/atlas/src/hooks/use-mobile.ts">
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
</file>

<file path="apps/atlas/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { extendTailwindMerge } from "tailwind-merge";

const extendedTwMerge = extendTailwindMerge({
  extend: {
    theme: {
      text: [
        "small-plus",
        "small",
        "base",
        "base-plus",
        "large",
        "large-plus",
        "title-one",
        "title-two",
        "title-three",
      ],
    },
  },
});

export function cn(...inputs: ClassValue[]) {
  return extendedTwMerge(clsx(inputs));
}
</file>

<file path="apps/atlas/src/reportWebVitals.ts">
const reportWebVitals = (onPerfEntry?: () => void) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import("web-vitals").then(({ onCLS, onINP, onFCP, onLCP, onTTFB }) => {
      onCLS(onPerfEntry);
      onINP(onPerfEntry);
      onFCP(onPerfEntry);
      onLCP(onPerfEntry);
      onTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="apps/atlas/src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

// Import Routes

import { Route as rootRoute } from './routes/__root'
import { Route as AtlasImport } from './routes/atlas'
import { Route as AtlasIndexImport } from './routes/atlas.index'

// Create/Update Routes

const AtlasRoute = AtlasImport.update({
  id: '/atlas',
  path: '/atlas',
  getParentRoute: () => rootRoute,
} as any)

const AtlasIndexRoute = AtlasIndexImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => AtlasRoute,
} as any)

// Populate the FileRoutesByPath interface

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/atlas': {
      id: '/atlas'
      path: '/atlas'
      fullPath: '/atlas'
      preLoaderRoute: typeof AtlasImport
      parentRoute: typeof rootRoute
    }
    '/atlas/': {
      id: '/atlas/'
      path: '/'
      fullPath: '/atlas/'
      preLoaderRoute: typeof AtlasIndexImport
      parentRoute: typeof AtlasImport
    }
  }
}

// Create and export the route tree

interface AtlasRouteChildren {
  AtlasIndexRoute: typeof AtlasIndexRoute
}

const AtlasRouteChildren: AtlasRouteChildren = {
  AtlasIndexRoute: AtlasIndexRoute,
}

const AtlasRouteWithChildren = AtlasRoute._addFileChildren(AtlasRouteChildren)

export interface FileRoutesByFullPath {
  '/atlas': typeof AtlasRouteWithChildren
  '/atlas/': typeof AtlasIndexRoute
}

export interface FileRoutesByTo {
  '/atlas': typeof AtlasIndexRoute
}

export interface FileRoutesById {
  __root__: typeof rootRoute
  '/atlas': typeof AtlasRouteWithChildren
  '/atlas/': typeof AtlasIndexRoute
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths: '/atlas' | '/atlas/'
  fileRoutesByTo: FileRoutesByTo
  to: '/atlas'
  id: '__root__' | '/atlas' | '/atlas/'
  fileRoutesById: FileRoutesById
}

export interface RootRouteChildren {
  AtlasRoute: typeof AtlasRouteWithChildren
}

const rootRouteChildren: RootRouteChildren = {
  AtlasRoute: AtlasRouteWithChildren,
}

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()

/* ROUTE_MANIFEST_START
{
  "routes": {
    "__root__": {
      "filePath": "__root.tsx",
      "children": [
        "/atlas"
      ]
    },
    "/atlas": {
      "filePath": "atlas.tsx",
      "children": [
        "/atlas/"
      ]
    },
    "/atlas/": {
      "filePath": "atlas.index.tsx",
      "parent": "/atlas"
    }
  }
}
ROUTE_MANIFEST_END */
</file>

<file path="apps/atlas/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="apps/atlas/vite.config.ts">
import { defineConfig } from "vite";
import viteReact from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

import { TanStackRouterVite } from "@tanstack/router-plugin/vite";
import { resolve } from "node:path";

// https://vitejs.dev/config/
export default defineConfig({
  base: "/atlas",
  plugins: [
    TanStackRouterVite({ autoCodeSplitting: true }),
    viteReact(),
    tailwindcss(),
  ],
  build: {
    sourcemap: true,
    // for asset tracking
    manifest: true,
  },
  resolve: {
    alias: {
      "@": resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="apps/flopilot/src/reportWebVitals.ts">
const reportWebVitals = (onPerfEntry?: () => void) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import("web-vitals").then(({ onCLS, onINP, onFCP, onLCP, onTTFB }) => {
      onCLS(onPerfEntry);
      onINP(onPerfEntry);
      onFCP(onPerfEntry);
      onLCP(onPerfEntry);
      onTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="apps/flopilot/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="apps/flopilot/vite.config.ts">
import { defineConfig } from "vite";
import viteReact from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

import { TanStackRouterVite } from "@tanstack/router-plugin/vite";
import { resolve } from "node:path";

// https://vitejs.dev/config/
export default defineConfig({
  base: "/flopilot/",
  plugins: [
    TanStackRouterVite({ autoCodeSplitting: true }),
    viteReact(),
    tailwindcss(),
  ],
  build: {
    sourcemap: true,
    // for asset tracking
    manifest: true,
  },
  resolve: {
    alias: {
      "@": resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="apps/shell/src/reportWebVitals.ts">
const reportWebVitals = (onPerfEntry?: () => void) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import("web-vitals").then(({ onCLS, onINP, onFCP, onLCP, onTTFB }) => {
      onCLS(onPerfEntry);
      onINP(onPerfEntry);
      onFCP(onPerfEntry);
      onLCP(onPerfEntry);
      onTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="apps/shell/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="apps/shell/package.json">
{
  "name": "shell",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "nx vite:serve",
    "build": "tsc -b && nx vite:build",
    "preview": "nx preview"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "globals": "^15.15.0",
    "typescript": "~5.7.2",
    "vite": "^6.2.0",
    "web-vitals": "^4.2.4"
  }
}
</file>

<file path="apps/shell/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="apps/shell/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  build: {
    sourcemap: true,
    // for asset tracking
    manifest: true,
  },
});
</file>

<file path="lib/neuron/src/icons/types.ts">
export interface IconProps extends React.SVGAttributes<SVGElement> {
  children?: never;
  color?: string;
}
</file>

<file path="lib/neuron/src/react/index.ts">
"use client"; // NOTE: Delete when we get rid of Next.js

export { Button, DestructiveActionButton, buttonVariants } from "./button";

export { ContextMenu } from "./context";
export { Dialog } from "./dialog";
export { Kbd, kbdVariants } from "./kbd";
export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
} from "./select";
export {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
} from "./table.tsx";
export { TabButton, TabLink, TabsRoot } from "./tabs";
export {
  Tooltip,
  TooltipArrow,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "./tooltip";
export {
  Typography,
  typographyVariants,
  type TypographyProps,
} from "./typography";

export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
} from "./sheet.tsx";
</file>

<file path="lib/neuron/src/index.ts">
export { cn } from "./utils";
</file>

<file path="lib/neuron/src/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { extendTailwindMerge } from "tailwind-merge";
import config from "./tailwind.config.js";

export const extendedTwMerge = extendTailwindMerge({
  extend: {
    classGroups: {
      "font-size": Object.keys(config.theme.fontSize).map(
        (key) => `text-${key}`,
      ),
    },
  },
});

export function cn(...inputs: ClassValue[]) {
  return extendedTwMerge(clsx(inputs));
}
</file>

<file path="lib/neuron/package.json">
{
  "name": "@anterior/neuron",
  "version": "0.1.0",
  "type": "module",
  "dependencies": {
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.1",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "tailwind-merge": "^2.5.2",
    "tailwind-variants": "^0.2.1",
    "tailwindcss": "^3.4.10"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.41"
  },
  "peerDependencies": {
    "react": "^18 || ^19",
    "react-dom": "^18 || ^19",
    "@types/react": "^18 || ^19",
    "@types/react-dom": "^18 || ^19",
    "typescript": "^5",
    "@radix-ui/react-accordion": "^1",
    "@radix-ui/react-icons": "^1",
    "@radix-ui/react-select": "^2",
    "@radix-ui/react-tooltip": "^1"
  }
}
</file>

<file path="lib/neuron/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "jsx": "react-jsx",
    "paths": {
      "@/*": ["./src/*"]
    },
    // Building for a library in a monorepo
    "rootDir": "./src",
    "lib": ["ES2023", "DOM", "DOM.Iterable"],
    "declarationDir": "./dist",
    "tsBuildInfoFile": "./dist/tsconfig.tsbuildinfo",
    "outDir": "./dist",
    "declaration": true,
    "composite": true,
    "sourceMap": true,
    "declarationMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "src/docs/**/*"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    /* Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ES2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "verbatimModuleSyntax": true,
    "forceConsistentCasingInFileNames": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "exactOptionalPropertyTypes": true,
    "noPropertyAccessFromIndexSignature": true,

    /* If NOT transpiling with TypeScript: */
    "module": "preserve",
    "noEmit": true,
    "allowImportingTsExtensions": true,

    /* If your code doesn't run in the DOM: */
    "lib": ["ES2022"]
  }
}
</file>

<file path="apps/agents/src/components/icons/types.ts">
export interface IconProps extends React.SVGAttributes<SVGElement> {
  children?: never;
  color?: string;
}
</file>

<file path="apps/agents/src/copytext/index.ts">
export default {
  en: {
    screenHome: {
      titleMain: "Tasks Workbench",
      titleAgents: "Agents",
      titleTasks: "Tasks",
    },

    screenMnr: {
      form: {
        clinicalsTitle: "Select Clinicals",
        criteriaTitle: "Select Criteria",
        contextTitle: "Add task context",
      },
    },
  },
};
</file>

<file path="apps/agents/src/lib/constants.ts">
export const NOGGIN_HOST = import.meta.env.VITE_NOGGIN_HOST;
export const MOCK = import.meta.env.VITE_MOCK === "true";

if (MOCK) console.warn("VITE_MOCK is enabled");

export const DEFAULT_JSON_HEADER = {
  "Content-Type": "application/json",
} as const;

export enum CodeType {
  CPT = "cpt",
  HCPCS = "hcpcs",
  ICD10 = "icd10",
  PROTOCOL = "protocol",
}
</file>

<file path="apps/agents/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { extendTailwindMerge } from "tailwind-merge";

const extendedTwMerge = extendTailwindMerge({
  extend: {
    theme: {
      text: [
        "small-plus",
        "small",
        "base",
        "base-plus",
        "large",
        "large-plus",
        "title-one",
        "title-two",
        "title-three",
      ],
    },
  },
});

export function cn(...inputs: ClassValue[]) {
  return extendedTwMerge(clsx(inputs));
}
</file>

<file path="apps/agents/src/requests/artifacts.ts">
import { CRITERIA_MOCK, MEMBER_MOCK, CLINICALS_MOCK } from "./mocks.ts";
import { fetchWithToast } from "./util.ts";

const baseArtStore = "/tasks/artifacts";

const _getter = (filter: string, MOCK: string[]) => {
  return (): Promise<string[]> => {
    return (
      fetchWithToast<string[]>(
        `${baseArtStore}/${filter}`,
        { method: "GET" },
        MOCK,
      ) || []
    );
  };
};

const _getters = {
  clinicals: _getter("clinicals", CLINICALS_MOCK),
  members: _getter("members", MEMBER_MOCK),
  criteria: _getter("criteria", CRITERIA_MOCK),
};

export type ArtifactCategories = keyof typeof _getters;
export const useArtifactGetter = (key: ArtifactCategories) => _getters[key];
</file>

<file path="apps/agents/src/requests/identify-indication.ts">
import { fetchWithToast } from "./util";

type IdentifyIndicationPayload = {
  queries: string[];
  serviceRequest: { codeType: string; codeValue: string; description: string };
};

const runIdentifyIndicationTaskPath = () =>
  `/tasks/identify-indication/actions/run`;

export const runIdentifyIndicationTask = async (
  form: IdentifyIndicationPayload,
) => {
  console.log("submitting request", form);
  const { queries, serviceRequest } = form;
  const { codeType, codeValue, description } = serviceRequest;
  const qClinicals = queries.filter((it) => it.includes("/clinicals"));

  const payload = {
    artQueries: {
      clinicals: qClinicals,
    },
    serviceRequest: {
      code: { type: codeType.toLowerCase(), value: codeValue },
      description,
    },
  };

  const { stemId } = await fetchWithToast<{ stemId: string }>(
    runIdentifyIndicationTaskPath(),
    {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json",
      },
    },
  );

  return { stemId };
};
</file>

<file path="apps/agents/src/requests/mnr.ts">
import { RUN_MNR_MOCK } from "./mocks";
import { fetchWithToast } from "./util";

type MnrPayload = {
  queries: string[];
  serviceRequest: { codeType: string; codeValue: string; description: string };
};

const runMnrTaskPath = () => `/tasks/mnr/actions/run`;

export const runMnrTask = async (form: MnrPayload) => {
  console.log("submitting request", form);
  const { queries, serviceRequest } = form;
  const { codeType, codeValue, description } = serviceRequest;
  const qClinicals = queries.filter((it) => it.includes("/clinicals"));
  const qCriteria = queries.filter((it) => it.includes("/criteria"))[0];

  const payload = {
    artQueries: {
      criteria: qCriteria,
      clinicals: qClinicals,
    },
    serviceRequest: {
      code: { type: codeType.toLowerCase(), value: codeValue },
      description,
    },
  };

  const { stemId } = await fetchWithToast<{ stemId: string }>(
    runMnrTaskPath(),
    {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json",
      },
    },
    RUN_MNR_MOCK,
  );

  return { stemId };
};
</file>

<file path="apps/agents/src/requests/mocks.ts">
export const CLINICALS_MOCK = [
  "ant://wks_mock_abc/clinicals/art_case_1",
  "ant://wks_mock_abc/clinicals/art_case_2",
  "ant://wks_mock_abc/clinicals/art_case_3",
];

export const MEMBER_MOCK = ["ant://wks_mock_abc/members/member_ab2_d61c"];

export const CRITERIA_MOCK = [
  "ant://wks_mock_abc/criteria/DME0015",
  "ant://wks_mock_abc/criteria/IQ6.01A_14559",
  "ant://wks_mock_abc/criteria/IQ6.01A_6855",
];

export const STEM_CREATED_MOCK = {
  stemId: "stm_123_abc",
};

export const STORE_MEMBER_MOCK = {
  stemId: "stm_123_abc",
  query: "ant://wks_mock_abc/members/member_ab2_d61c",
};

export const RUN_MNR_MOCK = { stemId: "stm_123_testing" };

export const STEM_LOGS_MOCK = [
  {
    event_type: "stem_log_v1_1",
    createdAt: new Date("2025-05-16T04:48:37.619Z"),
    data: '{"event_type":"stem_log_v1_1","message":"Mock log message for this stem."}',
  },
  {
    event_type: "stem_log_v1_1",
    createdAt: new Date("2025-05-16T04:48:37.619Z"),
    data: '{"event_type":"stem_log_v1_1","message":"Mock log message for this stem. This is a bit longer"}',
  },
  {
    event_type: "stem_log_v1_1",
    createdAt: new Date("2025-05-16T04:48:37.619Z"),
    data: '{"event_type":"stem_log_v1_1","message":"Another mock log message for this stem. This is a bit longer"}',
  },
  {
    event_type: "stem_log_v1_1",
    createdAt: new Date("2025-05-16T04:48:37.619Z"),
    data: '{"event_type":"stem_log_v1_1","message":"Mock log message for this stem. This is a bit longer"}',
  },
];
</file>

<file path="apps/agents/src/requests/select-relevant-criteria.ts">
import { fetchWithToast } from "./util";

type SelectRelevantCriteriaPayload = {
  queries: string[];
  serviceRequest: { codeType: string; codeValue: string; description: string };
  indication: string;
};

const runSelectRelevantCriteriaTaskPath = () =>
  `/tasks/select-relevant-criteria/actions/run`;

export const runSelectRelevantCriteriaTask = async (
  form: SelectRelevantCriteriaPayload,
) => {
  console.log("submitting request", form);
  const { queries, serviceRequest, indication } = form;
  const { codeType, codeValue, description } = serviceRequest;
  const qCriteria = queries.filter((it) => it.includes("/criteria"));

  const payload = {
    artQueries: {
      criteria: qCriteria,
    },
    serviceRequest: {
      code: { type: codeType.toLowerCase(), value: codeValue },
      description,
    },
    indication,
  };

  const { stemId } = await fetchWithToast<{ stemId: string }>(
    runSelectRelevantCriteriaTaskPath(),
    {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json",
      },
    },
  );

  return { stemId };
};
</file>

<file path="apps/agents/src/requests/stem-logs.ts">
import { STEM_LOGS_MOCK } from "./mocks";
import { fetchWithToast } from "./util";

export const fetchLogsForStem = async (stemId: string) =>
  await fetchWithToast<
    Array<{ event_type: string; createdAt: Date; data: string }>
  >(`/tasks/logs/${stemId}`, { method: "GET" }, STEM_LOGS_MOCK);
</file>

<file path="apps/agents/src/requests/util.ts">
import { toast } from "sonner";
import { NOGGIN_HOST, MOCK } from "@/lib/constants.ts";

export const delay = (millis = 1000) => {
  return new Promise((resolve) => {
    setTimeout(resolve, millis);
  });
};

const stripExcessSlashes = (url: string): string => {
  try {
    const parsed = new URL(url);
    parsed.pathname = parsed.pathname.replace(/\/{2,}/g, "/");
    return parsed.toString();
  } catch {
    throw new Error("Invalid URL provided.");
  }
};

export async function fetchWithToast<T>(
  apiPath: string,
  init?: RequestInit,
  mockResponse?: T,
  mockDelay: number = 1000,
): Promise<T> {
  const url = stripExcessSlashes(`${NOGGIN_HOST}/${apiPath}`);

  // handle mockery
  if (MOCK && mockResponse) {
    await delay(mockDelay);
    console.log(`Serving Mock for ${url}`);
    return mockResponse;
  }

  try {
    const response = await fetch(url, {
      credentials: "include",
      ...init,
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        errorText || `Request failed with status ${response.status}`,
      );
    }

    const contentType = response.headers.get("content-type");

    return contentType?.toLowerCase().includes("application/json")
      ? ((await response.json()) as T)
      : ((await response.text()) as unknown as T);
  } catch (err: unknown) {
    console.warn(`Error in fetchWithToast for ${url}`, err);
    const message =
      err instanceof Error && err?.message ? `[${err.message}]` : "";
    toast.error(`Oops! something went wrong. ${message}`);
    throw err;
  }
}
</file>

<file path="apps/agents/src/requests/validate-clinicals.ts">
import type { PatientData } from "../components/macro/patient-form";
import { STEM_CREATED_MOCK, STORE_MEMBER_MOCK } from "./mocks";
import { fetchWithToast } from "./util";

type ValidateClinicalsPayload = {
  queries: string[];
  patient: PatientData;
};

const createStemPath = "stems";
const storeMemberPath = "/tasks/artifacts/fhir";
const runValidateClinicalsTaskPath = "/tasks/validate-clinicals/actions/run";

export const createStem = async () => {
  return await fetchWithToast<{ stemId: string }>(
    createStemPath,
    {
      method: "POST",
      body: JSON.stringify({}),
      headers: {
        "Content-Type": "application/json",
      },
    },
    STEM_CREATED_MOCK,
  );
};

export const runValidateClinicalsTask = async (
  form: ValidateClinicalsPayload,
) => {
  console.log("submitting request", form);
  const { stemId } = await createStem();
  if (!stemId || stemId.trim().length === 0)
    throw new Error("invalid stemId:" + stemId);

  const { queries, patient } = form;
  const qClinicals = queries.filter((it) => it.includes("/clinicals"));

  const storeMemberPayload = {
    stemId,
    object: patient,
  };

  const storeMemberResponse = await fetchWithToast<{
    stemId: string;
    query: string;
  }>(
    storeMemberPath,
    {
      method: "POST",
      body: JSON.stringify(storeMemberPayload),
      headers: {
        "Content-Type": "application/json",
      },
    },
    STORE_MEMBER_MOCK,
  );

  const validateClinicalsPayload = {
    stemId,
    artQueries: {
      member: storeMemberResponse.query,
      clinicals: qClinicals,
    },
  };

  await fetchWithToast<object | void>(runValidateClinicalsTaskPath, {
    method: "POST",
    body: JSON.stringify(validateClinicalsPayload),
    headers: {
      "Content-Type": "application/json",
    },
  });

  return { stemId };
};
</file>

<file path="apps/agents/src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

// Import Routes

import { Route as rootRoute } from "./routes/__root";
import { Route as AgentsIndexImport } from "./routes/agents.index";
import { Route as AgentsAgentIdImport } from "./routes/agents_.$agentId";
import { Route as AgentsTasksImport } from "./routes/agents.tasks";
import { Route as AgentsTasksTaskIdImport } from "./routes/agents.tasks_.$taskId";
import { Route as AgentsLogsStemIdImport } from "./routes/agents.logs.$stemId";

// Create/Update Routes

const AgentsIndexRoute = AgentsIndexImport.update({
  id: "/agents/",
  path: "/agents/",
  getParentRoute: () => rootRoute,
} as any);

const AgentsAgentIdRoute = AgentsAgentIdImport.update({
  id: "/agents_/$agentId",
  path: "/agents/$agentId",
  getParentRoute: () => rootRoute,
} as any);

const AgentsTasksRoute = AgentsTasksImport.update({
  id: "/agents/tasks",
  path: "/agents/tasks",
  getParentRoute: () => rootRoute,
} as any);

const AgentsTasksTaskIdRoute = AgentsTasksTaskIdImport.update({
  id: "/agents/tasks_/$taskId",
  path: "/agents/tasks/$taskId",
  getParentRoute: () => rootRoute,
} as any);

const AgentsLogsStemIdRoute = AgentsLogsStemIdImport.update({
  id: "/agents/logs/$stemId",
  path: "/agents/logs/$stemId",
  getParentRoute: () => rootRoute,
} as any);

// Populate the FileRoutesByPath interface

declare module "@tanstack/react-router" {
  interface FileRoutesByPath {
    "/agents/tasks": {
      id: "/agents/tasks";
      path: "/agents/tasks";
      fullPath: "/agents/tasks";
      preLoaderRoute: typeof AgentsTasksImport;
      parentRoute: typeof rootRoute;
    };
    "/agents_/$agentId": {
      id: "/agents_/$agentId";
      path: "/agents/$agentId";
      fullPath: "/agents/$agentId";
      preLoaderRoute: typeof AgentsAgentIdImport;
      parentRoute: typeof rootRoute;
    };
    "/agents/": {
      id: "/agents/";
      path: "/agents";
      fullPath: "/agents";
      preLoaderRoute: typeof AgentsIndexImport;
      parentRoute: typeof rootRoute;
    };
    "/agents/logs/$stemId": {
      id: "/agents/logs/$stemId";
      path: "/agents/logs/$stemId";
      fullPath: "/agents/logs/$stemId";
      preLoaderRoute: typeof AgentsLogsStemIdImport;
      parentRoute: typeof rootRoute;
    };
    "/agents/tasks_/$taskId": {
      id: "/agents/tasks_/$taskId";
      path: "/agents/tasks/$taskId";
      fullPath: "/agents/tasks/$taskId";
      preLoaderRoute: typeof AgentsTasksTaskIdImport;
      parentRoute: typeof rootRoute;
    };
  }
}

// Create and export the route tree

export interface FileRoutesByFullPath {
  "/agents/tasks": typeof AgentsTasksRoute;
  "/agents/$agentId": typeof AgentsAgentIdRoute;
  "/agents": typeof AgentsIndexRoute;
  "/agents/logs/$stemId": typeof AgentsLogsStemIdRoute;
  "/agents/tasks/$taskId": typeof AgentsTasksTaskIdRoute;
}

export interface FileRoutesByTo {
  "/agents/tasks": typeof AgentsTasksRoute;
  "/agents/$agentId": typeof AgentsAgentIdRoute;
  "/agents": typeof AgentsIndexRoute;
  "/agents/logs/$stemId": typeof AgentsLogsStemIdRoute;
  "/agents/tasks/$taskId": typeof AgentsTasksTaskIdRoute;
}

export interface FileRoutesById {
  __root__: typeof rootRoute;
  "/agents/tasks": typeof AgentsTasksRoute;
  "/agents_/$agentId": typeof AgentsAgentIdRoute;
  "/agents/": typeof AgentsIndexRoute;
  "/agents/logs/$stemId": typeof AgentsLogsStemIdRoute;
  "/agents/tasks_/$taskId": typeof AgentsTasksTaskIdRoute;
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath;
  fullPaths:
    | "/agents/tasks"
    | "/agents/$agentId"
    | "/agents"
    | "/agents/logs/$stemId"
    | "/agents/tasks/$taskId";
  fileRoutesByTo: FileRoutesByTo;
  to:
    | "/agents/tasks"
    | "/agents/$agentId"
    | "/agents"
    | "/agents/logs/$stemId"
    | "/agents/tasks/$taskId";
  id:
    | "__root__"
    | "/agents/tasks"
    | "/agents_/$agentId"
    | "/agents/"
    | "/agents/logs/$stemId"
    | "/agents/tasks_/$taskId";
  fileRoutesById: FileRoutesById;
}

export interface RootRouteChildren {
  AgentsTasksRoute: typeof AgentsTasksRoute;
  AgentsAgentIdRoute: typeof AgentsAgentIdRoute;
  AgentsIndexRoute: typeof AgentsIndexRoute;
  AgentsLogsStemIdRoute: typeof AgentsLogsStemIdRoute;
  AgentsTasksTaskIdRoute: typeof AgentsTasksTaskIdRoute;
}

const rootRouteChildren: RootRouteChildren = {
  AgentsTasksRoute: AgentsTasksRoute,
  AgentsAgentIdRoute: AgentsAgentIdRoute,
  AgentsIndexRoute: AgentsIndexRoute,
  AgentsLogsStemIdRoute: AgentsLogsStemIdRoute,
  AgentsTasksTaskIdRoute: AgentsTasksTaskIdRoute,
};

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>();

/* ROUTE_MANIFEST_START
{
  "routes": {
    "__root__": {
      "filePath": "__root.tsx",
      "children": [
        "/agents/tasks",
        "/agents_/$agentId",
        "/agents/",
        "/agents/logs/$stemId",
        "/agents/tasks_/$taskId"
      ]
    },
    "/agents/tasks": {
      "filePath": "agents.tasks.tsx"
    },
    "/agents_/$agentId": {
      "filePath": "agents_.$agentId.tsx"
    },
    "/agents/": {
      "filePath": "agents.index.tsx"
    },
    "/agents/logs/$stemId": {
      "filePath": "agents.logs.$stemId.tsx"
    },
    "/agents/tasks_/$taskId": {
      "filePath": "agents.tasks_.$taskId.tsx"
    }
  }
}
ROUTE_MANIFEST_END */
</file>

<file path="apps/agents/src/types.ts">
export type ArtQuery = {
  category?: string | undefined;
  sourceId?: string | undefined;
  artifactId?: string | undefined;
  params?: Record<string, string[]>;
};

export type Criteria = {
  type: string;
  value: string;
};

export interface RollupEvent {
  type: string;
  createdAt: Date;
  data: string | undefined;
}

export interface RawRollupEvent {
  type: string;
  createdAt: string;
  data: string | undefined;
}

export interface MnrResult {
  status: "success" | "error";
  message: string;
  matches: Array<{
    patientId: string;
    score: number;
    details: {
      clinicalMatch: boolean;
      criteriaMatch: boolean;
      serviceMatch: boolean;
    };
  }>;
}
</file>

<file path="apps/agents/src/vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_NOGGIN_HOST: string;
  readonly VITE_MOCK: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

<file path="apps/agents/package.json">
{
  "name": "tasks",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev:mock": "VITE_MOCK=true VITE_NOGGIN_HOST=http://localhost:20701 nx vite:serve",
    "dev": "VITE_NOGGIN_HOST=http://localhost:20701 nx vite:serve",
    "build": "tsc -b && nx vite:build",
    "lint": "nx lint",
    "preview": "nx preview"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-label": "^2.1.6",
    "@radix-ui/react-radio-group": "^1.3.6",
    "@radix-ui/react-select": "^2.2.4",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-tabs": "^1.1.11",
    "@tailwindcss/vite": "^4.1.4",
    "@tanstack/react-router": "^1.120.4",
    "@tanstack/react-router-devtools": "^1.120.4",
    "add": "^2.0.6",
    "button": "^1.1.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.11.4",
    "input": "^1.0.1",
    "lucide-react": "^0.510.0",
    "next-themes": "^0.4.6",
    "npx": "^10.2.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-icons": "^5.5.0",
    "select": "^1.1.2",
    "shadcn-ui": "^0.9.5",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.0",
    "tailwindcss": "^4.1.4",
    "textarea": "^0.3.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@tanstack/router-plugin": "^1.120.4",
    "@types/node": "^22.14.1",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "tw-animate-css": "^1.2.9",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.26.1",
    "vite": "^6.3.1"
  }
}
</file>

<file path="apps/agents/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="apps/agents/vite.config.ts">
import { defineConfig } from "vite";
import viteReact from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import { resolve } from "node:path";
import { TanStackRouterVite } from "@tanstack/router-plugin/vite";

export default defineConfig({
  base: "/agents/",
  plugins: [
    TanStackRouterVite({ autoCodeSplitting: true }),
    viteReact(),
    tailwindcss(),
  ],
  build: {
    sourcemap: true,
    manifest: true,
  },
  resolve: {
    alias: {
      "@": resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="apps/ahip-super/src/components/icons/types.ts">
export interface IconProps extends React.SVGAttributes<SVGElement> {
  children?: never;
  color?: string;
}
</file>

<file path="apps/ahip-super/src/controller/agents/agents-controller.ts">
export interface Agent {
  id: string;
  name: string;
  description: string;
  color: string;
  bgColor?: string;
}

export class AgentsController {
  private agents: Agent[] = [
    {
      id: "1",
      name: "Outpatient Prior Auth",
      description:
        "Handles outpatient prior authorization requests and medical certifications",
      color: "var(--color-emerald-500)",
      bgColor: "var(--color-emerald-50)",
    },
    {
      id: "2",
      name: "Inpatient Prior Auth",
      description:
        "Manages inpatient prior authorization requests and medical certifications",
      color: "var(--color-green-500)",
      bgColor: "var(--color-green-50)",
    },
    {
      id: "3",
      name: "Intake Agent",
      description: "Processes member intake and eligibility verification",
      color: "var(--color-anterior-500)",
      bgColor: "var(--color-anterior-50)",
    },
    {
      id: "4",
      name: "Risk Adjustment Agent",
      description: "Manages risk score calculations and updates",
      color: "var(--color-blue-500)",
      bgColor: "var(--color-blue-50)",
    },
    {
      id: "5",
      name: "Care Management Agent",
      description: "Creates and updates care plans for members",
      color: "var(--color-purple-500)",
      bgColor: "var(--color-purple-50)",
    },
    {
      id: "6",
      name: "Disease Management Agent",
      description: "Develops and maintains disease management plans",
      color: "var(--color-red-500)",
      bgColor: "var(--color-red-50)",
    },
    {
      id: "7",
      name: "Member Services Agent",
      description: "Handles member inquiries and service requests",
      color: "var(--color-amber-500)",
      bgColor: "var(--color-amber-50)",
    },
    {
      id: "8",
      name: "Appeals Agent",
      description: "Processes and manages member appeals",
      color: "var(--color-orange-500)",
      bgColor: "var(--color-orange-50)",
    },
    {
      id: "9",
      name: "Grievance Agent",
      description: "Manages member grievances and resolutions",
      color: "var(--color-yellow-500)",
      bgColor: "var(--color-yellow-50)",
    },
    {
      id: "10",
      name: "Eligibility Agent",
      description: "Verifies member eligibility and coverage",
      color: "var(--color-brown-500)",
      bgColor: "var(--color-brown-50)",
    },
    {
      id: "11",
      name: "Benefits Agent",
      description: "Confirms and explains member benefits",
      color: "var(--color-ink-500)",
      bgColor: "var(--color-ink-50)",
    },
    {
      id: "12",
      name: "Claims Agent",
      description: "Processes and manages insurance claims",
      color: "var(--color-emerald-500)",
      bgColor: "var(--color-emerald-50)",
    },
    {
      id: "13",
      name: "Pharmacy Agent",
      description: "Handles pharmacy benefit requests and approvals",
      color: "var(--color-green-500)",
      bgColor: "var(--color-green-50)",
    },
    {
      id: "14",
      name: "Utilization Review Agent",
      description: "Conducts utilization reviews and assessments",
      color: "var(--color-anterior-500)",
      bgColor: "var(--color-anterior-50)",
    },
    {
      id: "15",
      name: "Case Management Agent",
      description: "Manages member cases and care coordination",
      color: "var(--color-blue-500)",
      bgColor: "var(--color-blue-50)",
    },
    {
      id: "16",
      name: "Network Agent",
      description: "Manages provider network verification and access",
      color: "var(--color-red-500)",
      bgColor: "var(--color-red-50)",
    },
    {
      id: "17",
      name: "Provider Relations Agent",
      description: "Handles provider inquiries and relationship management",
      color: "var(--color-amber-500)",
      bgColor: "var(--color-amber-50)",
    },
    {
      id: "18",
      name: "Enrollment Agent",
      description: "Processes member enrollment and registration",
      color: "var(--color-orange-500)",
      bgColor: "var(--color-orange-50)",
    },
    {
      id: "19",
      name: "Authorization Agent",
      description: "Manages service authorizations and approvals",
      color: "var(--color-yellow-500)",
      bgColor: "var(--color-yellow-50)",
    },
    {
      id: "20",
      name: "Coordination of Benefits Agent",
      description:
        "Coordinates benefits between primary and secondary insurance",
      color: "var(--color-brown-500)",
      bgColor: "var(--color-brown-50)",
    },
  ];

  getAgents(): Agent[] {
    return this.agents;
  }

  getAgentById(id: string): Agent | undefined {
    return this.agents.find((agent) => agent.id === id);
  }
}
</file>

<file path="apps/ahip-super/src/controller/models/draft-agent.ts">
import { z } from "zod";

const outcomeHandlerSchema = z.enum(["agent", "human"]);

export const draftAgentSchema = z.object({
  name: z.string().min(3, "Name must be at least 3 characters"),
  outcomes: z
    .record(z.string(), outcomeHandlerSchema)
    .refine(
      (outcomes) => Object.keys(outcomes).length === 3,
      "All outcomes must be assigned",
    ),
  triggers: z.string().refine((triggers) => {
    try {
      const parsed = JSON.parse(triggers);
      return Array.isArray(parsed) && parsed.length > 0;
    } catch {
      return false;
    }
  }, "At least one trigger method must be selected"),
  tools: z.array(z.string()).min(1, "At least one tool must be selected"),
  teams: z.array(z.string()),
  knowledge: z
    .array(z.string())
    .min(1, "At least one knowledge source must be selected"),
});

export type DraftAgent = z.infer<typeof draftAgentSchema>;

export class DraftAgentModel {
  private data: DraftAgent;

  constructor() {
    this.data = {
      name: "",
      outcomes: {},
      triggers: "",
      tools: [],
      teams: [],
      knowledge: [],
    };
  }

  getData(): DraftAgent {
    return { ...this.data };
  }

  update<K extends keyof DraftAgent>(key: K, value: DraftAgent[K]): void {
    this.data[key] = value;
  }

  reset(): void {
    this.data = {
      name: "",
      outcomes: {},
      triggers: "",
      tools: [],
      teams: [],
      knowledge: [],
    };
  }

  validate(): { success: boolean; error: z.ZodError<DraftAgent> | undefined } {
    const result = draftAgentSchema.safeParse(this.data);
    return {
      success: result.success,
      error: result.success ? undefined : result.error,
    };
  }

  validateField<K extends keyof DraftAgent>(
    key: K,
    value: DraftAgent[K],
  ): { success: boolean; error: string | undefined } {
    try {
      draftAgentSchema.shape[key].parse(value);
      return { success: true, error: undefined };
    } catch (error) {
      if (
        error instanceof z.ZodError &&
        error.errors.length > 0 &&
        error.errors[0]
      ) {
        return { success: false, error: error.errors[0].message };
      }
      return { success: false, error: "Invalid value" };
    }
  }
}
</file>

<file path="apps/ahip-super/src/controller/supervise-agents-controller.ts">
import { useState } from "react";

export function formatShortNumber(num: number): string {
  if (num < 1000) return num.toString();
  if (num < 10000) return (num / 1000).toFixed(1).replace(/\.0$/, "") + "k";
  if (num < 1_000_000) return Math.round(num / 1000) + "k";
  if (num < 10_000_000)
    return (
      (num / 1_000_000).toFixed(2).replace(/0+$/, "").replace(/\.$/, "") + "m"
    );
  return Math.round(num / 1_000_000) + "m";
}

const AGENTS = [
  {
    id: "1",
    name: "Outpatient Prior Auth",
    outcome: 1200,
    runs: 1700,
    donut: [
      {
        percent: 78,
        color: "var(--color-green-300)",
        label: "Medical certification",
      },
      {
        percent: 15,
        color: "var(--color-orange-300)",
        label: "Medical non-certification",
      },
      {
        percent: 7,
        color: "var(--color-red-300)",
        label: "Admin non-certification",
      },
    ],
  },
  {
    id: "2",
    name: "Inpatient Prior Auth",
    outcome: 950,
    runs: 1200,
    donut: [
      {
        percent: 80,
        color: "var(--color-green-300)",
        label: "Medical certification",
      },
      {
        percent: 12,
        color: "var(--color-orange-300)",
        label: "Medical non-certification",
      },
      {
        percent: 8,
        color: "var(--color-red-300)",
        label: "Admin non-certification",
      },
    ],
  },
  {
    id: "3",
    name: "Intake Agent",
    outcome: 800,
    runs: 900,
    donut: [
      {
        percent: 90,
        color: "var(--color-green-300)",
        label: "Eligible Member",
      },
      {
        percent: 10,
        color: "var(--color-red-300)",
        label: "Ineligible Member",
      },
    ],
  },
  {
    id: "4",
    name: "Risk Adjustment Agent",
    outcome: 670,
    runs: 800,
    donut: [
      {
        percent: 60,
        color: "var(--color-blue-300)",
        label: "Risk Score Updated",
      },
      {
        percent: 40,
        color: "var(--color-yellow-300)",
        label: "Risk Score Pending",
      },
    ],
  },
  {
    id: "5",
    name: "Care Management Agent",
    outcome: 540,
    runs: 600,
    donut: [
      {
        percent: 55,
        color: "var(--color-purple-300)",
        label: "Care Plan Created",
      },
      {
        percent: 45,
        color: "var(--color-blue-300)",
        label: "Care Plan Updated",
      },
    ],
  },
  {
    id: "6",
    name: "Disease Management Agent",
    outcome: 400,
    runs: 500,
    donut: [
      {
        percent: 70,
        color: "var(--color-green-300)",
        label: "Disease Management Plan Created",
      },
      {
        percent: 30,
        color: "var(--color-blue-300)",
        label: "Disease Management Plan Updated",
      },
    ],
  },
  {
    id: "7",
    name: "Member Services Agent",
    outcome: 1100,
    runs: 1600,
    donut: [
      {
        percent: 80,
        color: "var(--color-amber-300)",
        label: "Inquiry Resolved",
      },
      { percent: 20, color: "var(--color-orange-300)", label: "Escalated" },
    ],
  },
  {
    id: "8",
    name: "Appeals Agent",
    outcome: 980,
    runs: 1300,
    donut: [
      {
        percent: 65,
        color: "var(--color-green-300)",
        label: "Appeal Approved",
      },
      { percent: 35, color: "var(--color-red-300)", label: "Appeal Denied" },
    ],
  },
  {
    id: "9",
    name: "Grievance Agent",
    outcome: 820,
    runs: 950,
    donut: [
      { percent: 75, color: "var(--color-blue-300)", label: "Resolved" },
      { percent: 25, color: "var(--color-yellow-300)", label: "Unresolved" },
    ],
  },
  {
    id: "10",
    name: "Eligibility Agent",
    outcome: 700,
    runs: 850,
    donut: [
      { percent: 92, color: "var(--color-green-300)", label: "Eligible" },
      { percent: 8, color: "var(--color-red-300)", label: "Ineligible" },
    ],
  },
  {
    id: "11",
    name: "Benefits Agent",
    outcome: 560,
    runs: 650,
    donut: [
      {
        percent: 85,
        color: "var(--color-blue-300)",
        label: "Benefit Confirmed",
      },
      {
        percent: 15,
        color: "var(--color-orange-300)",
        label: "Benefit Not Covered",
      },
    ],
  },
  {
    id: "12",
    name: "Claims Agent",
    outcome: 420,
    runs: 520,
    donut: [
      { percent: 70, color: "var(--color-green-300)", label: "Claim Paid" },
      { percent: 30, color: "var(--color-red-300)", label: "Claim Denied" },
    ],
  },
  {
    id: "13",
    name: "Pharmacy Agent",
    outcome: 1250,
    runs: 1800,
    donut: [
      { percent: 82, color: "var(--color-green-300)", label: "Rx Approved" },
      { percent: 18, color: "var(--color-red-300)", label: "Rx Denied" },
    ],
  },
  {
    id: "14",
    name: "Utilization Review Agent",
    outcome: 1000,
    runs: 1400,
    donut: [
      { percent: 77, color: "var(--color-blue-300)", label: "Review Passed" },
      { percent: 23, color: "var(--color-yellow-300)", label: "Review Failed" },
    ],
  },
  {
    id: "15",
    name: "Case Management Agent",
    outcome: 850,
    runs: 1000,
    donut: [
      { percent: 68, color: "var(--color-purple-300)", label: "Case Closed" },
      { percent: 32, color: "var(--color-blue-300)", label: "Case Open" },
    ],
  },
  {
    id: "16",
    name: "Network Agent",
    outcome: 750,
    runs: 900,
    donut: [
      { percent: 90, color: "var(--color-green-300)", label: "In Network" },
      { percent: 10, color: "var(--color-red-300)", label: "Out of Network" },
    ],
  },
  {
    id: "17",
    name: "Provider Relations Agent",
    outcome: 600,
    runs: 700,
    donut: [
      { percent: 80, color: "var(--color-blue-300)", label: "Issue Resolved" },
      { percent: 20, color: "var(--color-orange-300)", label: "Pending" },
    ],
  },
  {
    id: "18",
    name: "Enrollment Agent",
    outcome: 450,
    runs: 550,
    donut: [
      { percent: 95, color: "var(--color-green-300)", label: "Enrolled" },
      { percent: 5, color: "var(--color-red-300)", label: "Not Enrolled" },
    ],
  },
  {
    id: "19",
    name: "Authorization Agent",
    outcome: 1300,
    runs: 1900,
    donut: [
      { percent: 88, color: "var(--color-green-300)", label: "Authorized" },
      { percent: 12, color: "var(--color-red-300)", label: "Not Authorized" },
    ],
  },
  {
    id: "20",
    name: "Coordination of Benefits Agent",
    outcome: 1050,
    runs: 1500,
    donut: [
      { percent: 60, color: "var(--color-blue-300)", label: "Primary" },
      { percent: 40, color: "var(--color-yellow-300)", label: "Secondary" },
    ],
  },
];

export function useSuperviseAgents(search: string) {
  const [agents] = useState(AGENTS);
  const filteredAgents = agents.filter((agent) =>
    agent.name.toLowerCase().includes(search.toLowerCase()),
  );
  return { agents, filteredAgents };
}
</file>

<file path="apps/ahip-super/src/hooks/use-infinite-scroll.ts">
import { useCallback, useEffect } from "react";
import { useInView } from "react-intersection-observer";

/**
 * A custom hook that implements infinite scrolling functionality using the Intersection Observer API.
 * It triggers the next page fetch when the user scrolls near the bottom of the content.
 *
 * @param hasNextPage - Boolean indicating if there are more pages to fetch
 * @param isFetchingNextPage - Boolean indicating if the next page is currently being fetched
 * @param fetchNextPage - Function to call when the next page should be fetched
 * @returns An object containing:
 *   - ref: A ref to attach to the element that should trigger infinite scroll
 *   - inView: Boolean indicating if the observed element is in view
 */
export function useInfiniteScroll(
  hasNextPage: boolean,
  isFetchingNextPage: boolean,
  fetchNextPage: () => void,
) {
  const { ref, inView } = useInView();

  const debouncedFetchNextPage = useCallback(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  useEffect(() => {
    const timer = setTimeout(debouncedFetchNextPage, 100);
    return () => clearTimeout(timer);
  }, [debouncedFetchNextPage]);

  return { ref, inView };
}
</file>

<file path="apps/ahip-super/src/hooks/use-mobile.ts">
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
</file>

<file path="apps/ahip-super/src/lib/tag-colors.ts">
export const COLORS = [
  "bg-blue-600/15",
  "bg-emerald-600/15",
  "bg-green-600/15",
  "bg-purple-600/15",
  "bg-red-600/15",
  "bg-orange-600/15",
  "bg-yellow-600/15",
  "bg-amber-600/15",
] as const;

export type ColorType = (typeof COLORS)[number];

export const TEXT_COLORS: Record<ColorType, string> = {
  "bg-blue-600/15": "text-blue-600",
  "bg-emerald-600/15": "text-emerald-600",
  "bg-green-600/15": "text-green-600",
  "bg-purple-600/15": "text-purple-600",
  "bg-red-600/15": "text-red-600",
  "bg-orange-600/15": "text-orange-600",
  "bg-yellow-600/15": "text-yellow-600",
  "bg-amber-600/15": "text-amber-600",
};

export const generateColorFromHash = (text: string): ColorType => {
  // Simple hash function
  let hash = 0;
  for (let i = 0; i < text.length; i++) {
    hash = text.charCodeAt(i) + ((hash << 5) - hash);
  }

  // Ensure we get a valid index by using modulo with the array length
  const index = Math.abs(hash) % COLORS.length;
  return COLORS[index] as ColorType;
};

export const getTagColors = (tag: string) => {
  const bgColor = generateColorFromHash(tag);
  const textColor = TEXT_COLORS[bgColor];
  return { bgColor, textColor };
};
</file>

<file path="apps/ahip-super/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { extendTailwindMerge } from "tailwind-merge";

const extendedTwMerge = extendTailwindMerge({
  extend: {
    theme: {
      text: [
        "small-plus",
        "small",
        "base",
        "base-plus",
        "large",
        "large-plus",
        "title-one",
        "title-two",
        "title-three",
      ],
    },
  },
});

export function cn(...inputs: ClassValue[]) {
  return extendedTwMerge(clsx(inputs));
}
</file>

<file path="apps/ahip-super/src/view/agents/builder/steps/index.ts">
export { NameAgentStep } from "./name-agent-step";
export { SetOutcomesStep } from "./set-outcomes-step";
export { SetKnowledgeStep } from "./set-knowledge-step";
export { EquipTasksStep } from "./equip-tasks-step";
export { EquipAgentsStep } from "./equip-agents-step";
export { SelectTeamsStep } from "./select-teams-step";
export { AgentCreatedStep } from "./agent-created-step";
</file>

<file path="apps/ahip-super/src/view/agents/builder/steps/types.ts">
export interface StepProps {
  onValidationChange: (isValid: boolean) => void;
}
</file>

<file path="apps/ahip-super/src/env.ts">
import { z } from "zod";

const envSchema = z.object({
  VITE_NOGGIN_HOST: z.string().url(),
  VITE_MOCK: z.string(),
});

// 🚨 This will only run time validate, but not at build time.
// Needs more work to make it do that, one attempt is writing
// your own Vite plugin.
export const env = envSchema.parse(import.meta.env);
</file>

<file path="apps/ahip-super/src/reportWebVitals.ts">
const reportWebVitals = (onPerfEntry?: () => void) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import("web-vitals").then(({ onCLS, onINP, onFCP, onLCP, onTTFB }) => {
      onCLS(onPerfEntry);
      onINP(onPerfEntry);
      onFCP(onPerfEntry);
      onLCP(onPerfEntry);
      onTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="apps/ahip-super/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="apps/ahip-super/vite.config.ts">
import { defineConfig } from "vite";
import viteReact from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

import { TanStackRouterVite } from "@tanstack/router-plugin/vite";
import { resolve } from "node:path";

// https://vitejs.dev/config/
export default defineConfig({
  base: "/ahip",
  plugins: [
    TanStackRouterVite({ autoCodeSplitting: true }),
    viteReact(),
    tailwindcss(),
  ],
  build: {
    sourcemap: true,
    // for asset tracking
    manifest: true,
  },
  resolve: {
    alias: {
      "@": resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="apps/atlas/src/controller/handlers/fetch-artifacts.ts">
import { env } from "@/env";

type Artifact = {
  artifact_id: string;
  title: string;
  artifact_type: string;
  mime_type: string;
  tags: string[];
};

const PAGE_SIZE = 20;

// Tags to filter out from each artifact
const TAGS_TO_REMOVE = [
  "artifact_id",
  "source_id",
  "workspace_id",
  "enterprise_id",
  "trace_id",
  "idempotency_key",
  "user_id",
  "artifact_type",
  "mime_type",
  "category",
];

// Format mime type to be more readable
function formatMimeType(mimeType: string): string {
  // Handle common mime types
  switch (mimeType) {
    case "image/jpeg":
      return "JPEG Image";
    case "image/png":
      return "PNG Image";
    case "image/gif":
      return "GIF Image";
    case "image/webp":
      return "WebP Image";
    case "image/svg+xml":
      return "SVG Image";
    case "video/mp4":
      return "MP4 Video";
    case "video/webm":
      return "WebM Video";
    case "audio/mpeg":
      return "MP3 Audio";
    case "audio/wav":
      return "WAV Audio";
    case "application/pdf":
      return "PDF Document";
    case "text/plain":
      return "Text File";
    case "text/html":
      return "HTML Document";
    case "application/json":
      return "JSON File";
    default:
      // For unknown types, split and format nicely
      return "Unknown MIME Type";
      // If we can't parse it, return the original
      return mimeType;
  }
}

export async function fetchArtifacts({
  tags = [],
  pageParam,
}: {
  tags?: string[];
  pageParam: number;
}): Promise<{
  items: Artifact[];
  nextCursor?: number | undefined;
}> {
  const allTags = ["artifact_type:raw", ...tags];
  const commaTags = allTags.join(",");
  const response = await fetch(
    `${env.VITE_NOGGIN_HOST}/artifacts/list?commaTags=${encodeURIComponent(commaTags)}`,
    {
      method: "GET",
    },
  );

  const data = await response.json();

  // Filter out unwanted tags and format mime type
  const filteredData = data.map((artifact: Artifact) => ({
    ...artifact,
    mime_type: formatMimeType(artifact.mime_type),
    tags: artifact.tags.filter(
      (tag) => !TAGS_TO_REMOVE.some((prefix) => tag.startsWith(prefix)),
    ),
  }));

  const start = pageParam * PAGE_SIZE;
  const end = start + PAGE_SIZE;
  const items = filteredData.slice(start, end);

  // Only add nextCursor if there are more items after this page
  const nextCursor = end < filteredData.length ? pageParam + 1 : undefined;
  const result: { items: Artifact[]; nextCursor?: number } = { items };
  if (nextCursor !== undefined) {
    result.nextCursor = nextCursor;
  }

  return result;
}
</file>

<file path="apps/atlas/src/lib/tag-colors.ts">
export const COLORS = [
  "bg-blue-600/15",
  "bg-emerald-600/15",
  "bg-green-600/15",
  "bg-purple-600/15",
  "bg-red-600/15",
  "bg-orange-600/15",
  "bg-yellow-600/15",
  "bg-amber-600/15",
] as const;

export type ColorType = (typeof COLORS)[number];

export const TEXT_COLORS: Record<ColorType, string> = {
  "bg-blue-600/15": "text-blue-600",
  "bg-emerald-600/15": "text-emerald-600",
  "bg-green-600/15": "text-green-600",
  "bg-purple-600/15": "text-purple-600",
  "bg-red-600/15": "text-red-600",
  "bg-orange-600/15": "text-orange-600",
  "bg-yellow-600/15": "text-yellow-600",
  "bg-amber-600/15": "text-amber-600",
};

export const generateColorFromHash = (text: string): ColorType => {
  // Simple hash function
  let hash = 0;
  for (let i = 0; i < text.length; i++) {
    hash = text.charCodeAt(i) + ((hash << 5) - hash);
  }

  // Ensure we get a valid index by using modulo with the array length
  const index = Math.abs(hash) % COLORS.length;
  return COLORS[index] as ColorType;
};

export const getTagColors = (tag: string) => {
  const bgColor = generateColorFromHash(tag);
  const textColor = TEXT_COLORS[bgColor];
  return { bgColor, textColor };
};
</file>

<file path="apps/atlas/src/env.ts">
import { z } from "zod";

const envSchema = z.object({
  VITE_NOGGIN_HOST: z.string().url(),
  VITE_MOCK: z.string(),
});

// 🚨 This will only run time validate, but not at build time.
// Needs more work to make it do that, one attempt is writing
// your own Vite plugin.
export const env = envSchema.parse(import.meta.env);
</file>

<file path="apps/flonotes/neuron/hooks/use-mobile.ts">
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
</file>

<file path="apps/flonotes/neuron/icons/types.ts">
export interface IconProps extends React.SVGAttributes<SVGElement> {
  children?: never;
  color?: string;
}
</file>

<file path="apps/flonotes/neuron/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { extendTailwindMerge } from "tailwind-merge";

const extendedTwMerge = extendTailwindMerge({
  extend: {
    theme: {
      text: ["small-plus", "small", "base", "base-plus", "large", "large-plus"],
    },
  },
});

export function cn(...inputs: ClassValue[]) {
  return extendedTwMerge(clsx(inputs));
}
</file>

<file path="apps/flonotes/src/components/shell/notes/config/templates.ts">
export const templates = {
  inpatientReview: {
    name: "Inpatient Admission Review",
    content: `<h1>Inpatient Admission Review</h1>
        <h2>Initial Admission Information</h2>
        <p><strong>Admission Date and Time</strong></p>
        <p>What is the admission date and time (MM/DD/YYYY HH:MM)? <span data-insert-info>QuickFill</span></p>

        <p><strong>Initial Admission Type</strong></p>
        <p>What is the patient's initial admission type (Inpatient/Observation)? <span data-insert-info>QuickFill</span></p>

        <p><strong>Days of Care</strong></p>
        <p>How many days of care has the patient received (not inclusive of the discharge day)? <span data-insert-info>QuickFill</span></p>

        <p><strong>Reason for Admission</strong></p>
        <p>What is the reason for admission? <span data-insert-info>QuickFill</span></p>

        <p><strong>Original DX ICD-10 Code</strong></p>
        <p>What diagnosis code and description was the patient admitted with? <span data-insert-info>QuickFill</span></p>

        <p><strong>Current Driving Diagnosis</strong></p>
        <p>What diagnosis is the patient mainly being treated for? <span data-insert-info>QuickFill</span></p>

        <p><strong>Other Diagnosis Being Treated</strong></p>
        <p>What other active diagnoses is the patient being treated for? <span data-insert-info>QuickFill</span></p>

        <hr/>
        
        <h2>Care Day 1: Date of Admission</h2>
        <p><strong>Admission Status</strong></p>
        <p>What is the patient's current admission status? (Inpatient/Observation)? <span data-insert-info>QuickFill</span></p>

        <p><strong>Bed-Type</strong></p>
        <p>What is the patient's current bed-type (ICU, Med, Surg)? <span data-insert-info>QuickFill</span></p>

        <p><strong>ED Course</strong></p>
        <p>Provide a brief history of the patient's interaction with the emergency department <span data-insert-info>QuickFill</span></p>

        <p><strong>H&P</strong></p>
        <p>What is documented in the patient's history and physical examination (inclusive of objective and subjective findings)? <span data-insert-info>QuickFill</span></p>

        <p><strong>PMH</strong></p>
        <p>What is the patient's past medical history? <span data-insert-info>QuickFill</span></p>

        <p><strong>VS</strong></p>
        <p>What were the patient's most recent vital signs at admission? <span data-insert-info>QuickFill</span></p>

        <p><strong>Current Labs</strong></p>
        <p>What were the patient's most recent laboratory results? <span data-insert-info>QuickFill</span></p>

        <p><strong>Imaging</strong></p>
        <p>What were the findings from the initial imaging studies? <span data-insert-info>QuickFill</span></p>

        <p><strong>Surgical Procedures</strong></p>
        <p>Has the patient had any surgical procedures? <span data-insert-info>QuickFill</span></p>

        <p><strong>Other Procedures</strong></p>
        <p>What non-surgical procedures has the patient undergone? <span data-insert-info>QuickFill</span></p>

        <p><strong>Consulting Specialties</strong></p>
        <p>Which medical specialties are currently consulting on this patient? <span data-insert-info>QuickFill</span></p>

        <p><strong>Plan</strong></p>
        <p>What is the current treatment plan and ongoing medical management? <span data-insert-info>QuickFill</span></p>

        <p><strong>Discharge Plan</strong></p>
        <p>What is the initial discharge plan for the patient? <span data-insert-info>QuickFill</span></p>`,
  },
  homeHealthReview: {
    name: "Home Health Review",
    content: `<h1>Home Health Review</h1>
        <p><strong>List of notes contained in the request (type of note, who authored the note, date and time of note):</strong></p>
        <ul><li><p><span data-insert-info>QuickFill</span></p></li></ul>
        <p><strong>Dx:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>PMH:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Brief summary of clinical course:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>MD order/plan of care date and time:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Name of provider signing plan of care/order: </strong><span data-insert-info>QuickFill</span></p>
        <p><strong>Services and frequency ordered: </strong><span data-insert-info>QuickFill</span></p>
        <p><strong>Indications for services: </strong><span data-insert-info>QuickFill</span></p>
        <p><strong>Home Bound status: </strong><span data-insert-info>QuickFill</span></p>
        <p><strong>Goals: </strong><span data-insert-info>QuickFill</span></p>
        <p><strong>Prior Level of function: </strong><span data-insert-info>QuickFill</span></p>
        <p><strong>Level of function on most recent evaluation: </strong><span data-insert-info>QuickFill</span></p>`,
  },
  outpatientPainManagement: {
    name: "Outpatient Pain Management",
    content: `<h1>Outpatient Pain Management</h1>
        <p><strong>Pain Diagnosis:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Other diagnoses:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Pain Medications:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Other medications:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Surgical Hx:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Procedure history:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Current treatments:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Plan:</strong> <span data-insert-info>QuickFill</span></p>`,
  },
  caseManagement: {
    name: "Case Management",
    content: `<h1>Case Management</h1>
        <h2>Patient Demographics &amp; Contact Information</h2>
        <p><strong>Full Name:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Date of Birth (DOB):</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Gender:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Address:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Phone Number:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Email:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Preferred Language:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Emergency Contact (Name &amp; Phone):</strong> <span data-insert-info>QuickFill</span></p>
        <h2>Insurance &amp; Health Plan Details</h2>
        <p><strong>Health Plan Name &amp; ID:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Plan Type (HMO, PPO, Medicare, Medicaid, ACA, etc.):</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Primary Care Physician (PCP):</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Specialist(s) Assigned:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Covered Benefits &amp; Limitations:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Prior Authorizations Required for:</strong> <span data-insert-info>QuickFill</span></p>
        <h2>Medical History &amp; Diagnoses</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Diabetes</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Hypertension</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>COPD / Asthma</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Chronic Kidney Disease</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Congestive Heart Failure</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Behavioral Health Condition(s)</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Cancer</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Other:</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Recent Hospitalizations (Last 6-12 months):</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Allergies / contraindications:</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Functional limitations (Mobility, ADLs, cognitive impairments)</p></div></li>
        </ul>
        <h2>Medications &amp; Pharmacy Information</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Medication List Attached</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Medicated Adherence Issues Identified</p></div></li>
        </ul>
        <p><strong>Pharmacy Name &amp; Contact:</strong> <span data-insert-info>QuickFill</span></p>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Medical Reconciliation Needed?</p></div></li>
        </ul>
        <h2>Utilization &amp; Care History</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Upcoming Appointments (PCP/Specialist):</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Home Health or Skilled Nursing Services: Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>DME (e.g., Oxygen, Wheelchair, CPAP): Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Preventive Screenings Completed (Annual Visit, Cancer Screenings, Vaccinations, Diabetes &amp; Hypertension, Other)</p></div></li>
        </ul>
        <h2>Social Determinants of Health (SDOH)</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Stable Housing</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Homeless / Unstable Housing</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Lives Alone</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>With Family / Caregiver</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Food Security Issues? Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Transportation Issues? Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Financial Challenges Impacting Care? Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Support System (Family, Community, Church, etc.):</p></div></li>
        </ul>
        <h2>Care Coordination &amp; Referrals</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Specialist Referral</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Behavioral Health Support</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Substance Use Support</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Community-Based Services</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Other:</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Enrolled in a Case Management / Disease Management Program? Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Gaps in Care Identified? Yes / No</p></div></li>
        </ul>
        <h2>Risk Stratification &amp; Predictive Analytics</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Predictive Risk Score (If Available):</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>High-Risk for Readmission? Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Flagged for High-Cost Utilization? Yes / No</p></div></li>
        </ul>
        <h2>Behavioral Health &amp; Psychosocial Factors</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Depression</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Anxiety</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Bipolar Disorder</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>PTSD</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Schizophrenia</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Other:</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Substance Use History? Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Cognitive Decline / Dementia Concerns? Yes / No</p></div></li>
        </ul>
        <h2>Advance Care Planning &amp; Legal Considerations</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Advance Directives in Place? Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Power of Attorney / Legal Guardian? Yes / No</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>DNR / DNI Orders? Yes / No</p></div></li>
        </ul>
        <h2>Communication &amp; Case Notes</h2>
        <ul data-type="taskList">
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Last Contact Date:</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Patient Engagement Level (Active &amp; Engaged, Needs Encouragement, Non-Adherent)</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Interdisciplinary Team Coordination Notes</p></div></li>
          <li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Next Steps / Case Manager Action Plan:</p></div></li>
        </ul>`,
  },
  outpatientReview: {
    name: "Outpatient Review",
    content: `<h1>Outpatient Review</h1>
        <p><strong>Date of most recent note:</strong></p>
        <p>What is the date on the most recent note? <span data-insert-info>QuickFill</span></p>
        <p><strong>Plan/Assessment (requested service):</strong></p>
        <p>What is the summary of the plan and/or assessment in the most recent note? <span data-insert-info>QuickFill</span></p>
        <p><strong>DX (Diagnosis):</strong></p>
        <p>What is the provider's diagnosis from the most recent note? <span data-insert-info>QuickFill</span></p>
        <p><strong>HPI (History of Present Illness, Chief Complaint):</strong></p>
        <p>What is the summary of the History of present illness and chief complaint from the most recent note <span data-insert-info>QuickFill</span></p>
        <p><strong>ROS (Review of Systems):</strong></p>
        <p>What is the review of systems from the most recent note? <span data-insert-info>QuickFill</span></p>
        <p><strong>PE (Physical Exam):</strong></p>
        <p>What are the physical exam findings from the most recent note? <span data-insert-info>QuickFill</span></p>
        <p><strong>PMH (Past Medical History):</strong></p>
        <p>What is the patient's past medical history? <span data-insert-info>QuickFill</span></p>
        <p><strong>Medications:</strong></p>
        <p>What are the patient's medication names, dosages and frequency in the most recent note? <span data-insert-info>QuickFill</span></p>
        <p><strong>Labs:</strong></p>
        <p>What are the patient's most recent labs? <span data-insert-info>QuickFill</span></p>
        <p><strong>Imaging:</strong></p>
        <p>What is the patient's most recent imaging study, including the impression? <span data-insert-info>QuickFill</span></p>
        <p><strong>Orders:</strong></p>
        <p>What are the provider's most recent orders? <span data-insert-info>QuickFill</span></p>
        <p><strong>Other notes attached:</strong></p>
        <p>What is the summary of each note attached other than the most recent organized by date? <span data-insert-info>QuickFill</span></p>`,
  },
  multiDayIPReview: {
    name: "Multi-Day IP Review",
    content: `<h1>Multi-Day IP Review</h1>
        <p><strong>Admission Date and time:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Initial Admission type:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Current Admission Type:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Days of Care:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Dates of Care:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Discharged:</strong></p>
        <ul>
          <li>Status: <span data-insert-info>QuickFill</span></li>
          <li>Discharge Date: <span data-insert-info>QuickFill</span></li>
          <li>Discharge Summary Available: <span data-insert-info>QuickFill</span></li>
        </ul>
        <p><strong>Reason for Admission:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Original DX ICD-10 code:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Current Driving Diagnosis:</strong> <span data-insert-info>QuickFill</span></p>
        <p><strong>Other diagnosis being treated:</strong> <span data-insert-info>QuickFill</span></p>
        
        <h2>Care Day Reviews</h2>
        <p>Detailed summary of each care day organized by date:</p>
        <span data-insert-info>QuickFill</span></p>`,
  },
} as const;

export type TemplateKey = keyof typeof templates;
</file>

<file path="apps/flonotes/src/components/shell/notes/hooks/use-editor-callbacks.ts">
// NB: i don't like how prompts are in the frontend like this...
// even if we were to keep them in the frontend, we'd want to separate them
// from the logic so long as we could do so without too much indirection
import { Editor } from "@tiptap/react";
import { useCallback } from "react";
import { replaceInsertInfoSpans } from "../utils/editor-utils";
import { db } from "../../../../indexed-db/db";
import { useLiveQuery } from "dexie-react-hooks";
import { useMutation } from "@tanstack/react-query";
import { createAndWaitForNote } from "../../../../services/noggin-api";

/**
 * Sanitizes HTML responses from the LLM to ensure they're compatible with TipTap
 *
 * This handles different formats of HTML that might be returned and extracts
 * the relevant content for insertion into the editor.
 */
const sanitizeHtml = (html: string): string => {
  // Skip sanitization if html is not a string
  if (typeof html !== "string") {
    console.error("Invalid HTML received:", html);
    return "<p>Error: Invalid response from LLM service</p>";
  }

  // Sometimes the API returns HTML without proper document structure
  // Ensure we have proper HTML structure
  if (!html.includes("<html>") && !html.includes("<!DOCTYPE")) {
    // If we just have fragments, wrap them properly
    if (!html.includes("<body>")) {
      // This appears to be just HTML fragments, not a complete document
      return html;
    }
  }

  // If we got a full HTML document, extract just the body content
  const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
  if (bodyMatch && bodyMatch[1]) {
    return bodyMatch[1].trim();
  }

  return html;
};

export const useEditorCallbacks = (editor: Editor | null) => {
  // Always use direct API calls with React Query
  // This ensures we're using real hooks within the component
  const noteMutation = useMutation({
    // Use the updated function that handles polling automatically
    mutationKey: ["llm.notes"],
    mutationFn: createAndWaitForNote,
  });

  const pdfs =
    useLiveQuery(() =>
      db.pdfs.where("documentType").equals("clinical").toArray(),
    ) ?? [];

  const handleRunAutoFill = useCallback(async () => {
    if (!editor) return;
    const currentContent = editor.getHTML();
    console.log("Current content before extraction:", currentContent);
    const extractedContent = replaceInsertInfoSpans(currentContent);
    console.log(
      "Extracted content with replaced QuickFill tags:",
      extractedContent,
    );

    const extractsArray =
      pdfs
        .filter((pdf) => pdf && pdf.extracts)
        .map((pdf) => {
          return {
            id: pdf.id.toString(),
            extracts: pdf.extracts.result.extracts || [],
          };
        }) || [];

    // Find the first PDF that has a stemUid from the server
    const pdfWithStemUid = pdfs.find((pdf) => pdf.stemUid);

    // Check if we have a server-provided stemUid
    if (!pdfWithStemUid?.stemUid) {
      console.error(
        "No stemUid found in PDFs. Cannot create note without a server-assigned stemUid.",
      );
      alert(
        "Error: Cannot create note without processing a PDF first. Please upload a PDF document.",
      );
      return;
    }

    const stemUid = pdfWithStemUid.stemUid;
    console.log(
      `Using server-assigned stemUid ${stemUid} from PDF for note creation`,
    );

    try {
      console.log(
        "Sending request to LLM with clinicals:",
        extractsArray.length,
        "stemUid:",
        stemUid,
      );

      // This now handles the complete flow including polling
      const noteContent = await noteMutation.mutateAsync({
        stemUid,
        clinicals: extractsArray,
        messages: [],
        userMessage: `Write a clinical note by:
1. Using the following template structure: ${extractedContent}
2. Replace each {{QuickFill}} placeholder with ONLY the specific information being requested based on context
3. Each {{QuickFill}} replacement should be brief and focused only on what is asked for in the preceding label
4. Maintain the exact HTML structure and formatting, unless the {{QuickFill}} replacement calls for an ordered or unordered list (<ol> or <ul>) with list items (<li>)
5. For EACH piece of information, include a citation tag immediately after the text
6. Format dates as MM/DD/YYYY
7. Use consistent medical terminology following [specify standard, e.g. SNOMED CT]
8. For missing or unclear data, write "[Not documented]"
9. Flag any critical values with <critical></critical> tags
10. Validate all numbers are within typical clinical ranges
11. DO NOT include the entire content of the source - only extract the relevant information
12. Keep your answers SPECIFIC and CONCISE for each field
13. Checkbox should be filled in if the information is present from [] to [x], including a citation tag.
14. Citation tags should exist within a <li> tag if the citation is relevant to a list item.

Citation format:
- Use <citation fileId="X" extractId="Y" blockIds="Z" /> tags after each piece of information
- Each {{QuickFill}} should be replaced by ONLY the requested data with appropriate citation(s)
- Include page numbers in the citation when available

Example input:
<p><strong>Address:</strong> {{QuickFill}}</p>

Example output with exactly one citation:
<p><strong>Address:</strong> 123 TOON AVENUE, TOONTOWN, 12345, ARIZONA <citation fileId="1" extractId="abc123" blockIds="1" /></p>

Example input:
<p><strong>Date of Birth:</strong> {{QuickFill}}</p>

Example output with exactly two citations:
<p><strong>Date of Birth:</strong> 03/12/1962 <citation fileId="1" extractId="def456" blockIds="1,2" /></p>

Example input:
<p><strong>ICD-10 Codes:</strong> {{QuickFill}}</p>

Example output with ordered one citation and ordered list of values:
<p>
    All ICD-10 Codes: C23 <citation extractid="E1" fileid="1" blockids="7"></citation>
    <ol>
        <li>ICD 10 diagnoses: Malignant neoplasm of gallbladder (C23)</li>
        <li>Unspecified asthma, uncomplicated (J45.909)</li>
        <li>Type 2 diabetes mellitus without complications (E11.9)</li>
        <li>Essential (primary) hypertension (I10)</li>
        <li>Depression, unspecified (F32.A)</li>
        <li>Bilateral primary osteoarthritis of hip (M16.0)</li>
        <li>Hypothyroidism, unspecified (E03.9)</li>
        <li>History of falling (Z91.81)</li>
        <li>Long term (current) use of insulin (Z79.4)</li>
        <li>Acquired absence of kidney (Z90.5)</li>
    </ol>
</p>

Invalid outputs:
- Adding extra HTML elements, unless the {{QuickFill}} replacement calls for an ordered or unordered list (<ol> or <ul>) with list items (<li>)
- Changing template structure
- Omitting citations
- Free-form text outside template
- Including information not specifically requested by the field label
- Returning entire sections or paragraphs when only a specific data point is asked for`,
      });

      console.log(
        "Received completed note content from LLM:",
        typeof noteContent === "string"
          ? noteContent.substring(0, 100) + "..."
          : noteContent,
      );

      // Clean up the HTML - now we know we have a string from createAndWaitForNote
      const cleanedHtml = sanitizeHtml(noteContent);
      console.log("Cleaned HTML:", cleanedHtml.substring(0, 100) + "...");

      // Force a complete content replacement
      editor.commands.clearContent();
      setTimeout(() => {
        console.log("Setting editor content with cleaned response");
        editor.commands.setContent(cleanedHtml);

        // Validate content was set
        setTimeout(() => {
          const newContent = editor.getHTML();
          console.log(
            "New editor content after update:",
            newContent.substring(0, 100) +
              (newContent.length > 100 ? "..." : ""),
          );

          if (newContent.trim() === "" || newContent === "<p></p>") {
            console.error(
              "Editor content is still empty after update, falling back to direct HTML insertion",
            );
            // As a fallback, try a different approach to insert content
            editor.commands.insertContent(cleanedHtml);
          }
        }, 100);
      }, 100);
    } catch (error) {
      console.error("Error in handleRunAutoFill:", error);
      // Show an error message to the user
      alert(
        `Error generating note: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  }, [editor, noteMutation, pdfs]);

  const handleAddDetail = useCallback(async () => {
    // No-op for now - button remains but no network call
    console.log("Add detail button clicked - functionality disabled for now");
    // Return immediately without making any changes
    return;
  }, []);

  // Compute PDF-related state flags
  const hasPDFs: boolean = pdfs.length > 0;
  const isExtractionComplete: boolean = pdfs.some(
    (pdf) =>
      pdf.extracts?.result?.extracts && pdf.extracts.result.extracts.length > 0,
  );

  return {
    handleRunAutoFill,
    handleAddDetail,
    noteMutation,
    hasPDFs,
    isExtractionComplete,
  };
};
</file>

<file path="apps/flonotes/src/components/shell/notes/utils/editor-utils.ts">
export const replaceInsertInfoSpans = (html: string): string => {
  return html.replace(
    /<span[^>]*data-insert-info[^>]*>.*?<\/span>/g,
    "{{QuickFill}}",
  );
};
</file>

<file path="apps/flonotes/src/components/shell/notes/utils/parser.ts">
// markdownToTiptap.ts

interface MarkdownParserResult {
  success: boolean;
  content: string | null;
  error: string | null;
}

/**
 * Converts markdown content to HTML format compatible with Tiptap editor
 * @param markdownContent - The markdown string to be converted
 * @returns MarkdownParserResult containing the parsed content or error information
 */
export const markdownToTiptap = (
  markdownContent: string | null | undefined,
): MarkdownParserResult => {
  // Skip parsing if content is empty or not a string
  if (!markdownContent || typeof markdownContent !== "string") {
    return {
      success: false,
      content: null,
      error: "Invalid input: Content must be a non-empty string",
    };
  }

  const escapeHTML = (text: string): string => {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  };

  const parseContent = (markdown: string): string => {
    let html = markdown;

    // Parse code blocks (```code```)
    html = html.replace(/```([^`]+?)```/g, (match: string, code: string) => {
      return `<pre><code>${escapeHTML(code.trim())}</code></pre>`;
    });

    // Parse inline code (`code`)
    html = html.replace(/`([^`]+?)`/g, "<code>$1</code>");

    // Parse headers (# Header)
    html = html.replace(
      /^(#{1,6})\s+(.+?)$/gm,
      (match: string, hashes: string, content: string) => {
        const level = hashes.length;
        return `<h${level}>${content.trim()}</h${level}>`;
      },
    );

    // Parse bold (**text**)
    html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");

    // Parse italic (*text*)
    html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");

    // Parse unordered lists with proper TypeScript types
    html = html
      .split("\n")
      .map((line: string) => {
        const listMatch = line.match(/^(\s*)-\s+(.+)$/);
        if (listMatch) {
          const [, indent, content] = listMatch;
          const indentLevel = Math.floor((indent?.length || 0) / 2);
          return `${"  ".repeat(indentLevel)}<ul><li>${content}</li></ul>`;
        }
        return line;
      })
      .join("\n");

    // Parse ordered lists with proper TypeScript types
    html = html
      .split("\n")
      .map((line: string) => {
        const listMatch = line.match(/^(\s*)\d+\.\s+(.+)$/);
        if (listMatch) {
          const [, indent, content] = listMatch;
          const indentLevel = Math.floor((indent?.length || 0) / 2);
          return `${"  ".repeat(indentLevel)}<ol><li>${content}</li></ol>`;
        }
        return line;
      })
      .join("\n");

    // Parse horizontal rules
    html = html.replace(/^---$/gm, "<hr>");

    // Parse paragraphs (lines not matching other patterns)
    html = html.replace(/^(?!<[a-z]|\s*$)(.+?)$/gm, "<p>$1</p>");

    // Clean up extra newlines
    html = html.replace(/\n{3,}/g, "\n\n");

    return html.trim();
  };

  try {
    const htmlContent = parseContent(markdownContent);

    return {
      success: true,
      content: htmlContent,
      error: null,
    };
  } catch (error) {
    return {
      success: false,
      content: null,
      error:
        error instanceof Error ? error.message : "An unknown error occurred",
    };
  }
};
</file>

<file path="apps/flonotes/src/components/shell/notes/extension-insert.ts">
import {
  Mark,
  markInputRule,
  markPasteRule,
  mergeAttributes,
} from "@tiptap/core";

export interface InsertInfoOptions {
  HTMLAttributes: Record<string, unknown>;
}

declare module "@tiptap/core" {
  interface Commands<ReturnType> {
    insertInfo: {
      setInsertInfo: () => ReturnType;
      toggleInsertInfo: () => ReturnType;
      unsetInsertInfo: () => ReturnType;
    };
  }
}

/**
 * Matches insert text via `{{}}` as input.
 */
export const insertInputRegex =
  /(?:^|\s)(\{\{(?!\s+\}\})((?:[^}]+))\}\}(?!\s+\}\}))$/;

/**
 * Matches insert text via `{{}}` while pasting.
 */
export const insertPasteRegex =
  /(?:^|\s)(\{\{(?!\s+\}\})((?:[^}]+))\}\}(?!\s+\}\}))/g;

export const InsertInfo = Mark.create<InsertInfoOptions>({
  name: "insertInfo",
  group: "inline",
  contenteditable: "false",
  inline: true,
  selectable: true,
  atom: true,

  addOptions() {
    return {
      HTMLAttributes: {},
    };
  },

  parseHTML() {
    return [
      {
        tag: "span[data-insert-info]",
      },
    ];
  },

  renderHTML({ HTMLAttributes }) {
    return [
      "span",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        "data-insert-info": "",
        class:
          "bg-anterior-400/10 text-anterior-600 px-fib-5 text-base-plus rounded-sm mx-fib-3 py-fib-2 shadow-[inset_0_1.5px_1px_rgba(255,255,255,0.3)]",
      }),
      0,
    ];
  },

  addCommands() {
    return {
      setInsertInfo:
        () =>
        ({ chain }) => {
          return chain()
            .insertContent(
              '<span data-insert-info="" class="bg-anterior-400/10 text-anterior-600 px-fib-5 text-base-plus rounded-sm mx-fib-3 py-fib-2 shadow-[inset_0_1.5px_1px_rgba(255,255,255,0.3)]">QuickFill</span> ',
            )
            .run();
        },
      toggleInsertInfo:
        () =>
        ({ commands }) => {
          return commands.toggleMark(this.name);
        },
      unsetInsertInfo:
        () =>
        ({ commands }) => {
          return commands.unsetMark(this.name);
        },
    };
  },

  addInputRules() {
    return [
      markInputRule({
        find: insertInputRegex,
        type: this.type,
      }),
    ];
  },

  addPasteRules() {
    return [
      markPasteRule({
        find: insertPasteRegex,
        type: this.type,
      }),
    ];
  },
});
</file>

<file path="apps/flonotes/src/components/shell/pdf/hooks/use-throttled-scroll.ts">
import { usePageNumber } from "../providers/use-page-number-provider";
import { throttle } from "lodash";
import { useEffect } from "react";

export function useThrottledScroll() {
  const [pageNumber, setPageNumber] = usePageNumber();

  useEffect(() => {
    const handleScroll = () => {
      // Get all PDF pages
      const pages = Array.from(document.querySelectorAll(".react-pdf__Page"));
      if (!pages.length) return;

      // Get viewport dimensions
      const headerOffset = 72; // 40px tabs + 32px indicator
      const viewportHeight = window.innerHeight;

      // Try multiple methods to find the current page

      // Method 1: Most visible area
      let maxVisiblePage = 0;
      let maxVisibleArea = 0;

      pages.forEach((page, index) => {
        const rect = page.getBoundingClientRect();
        // Calculate visible area
        const visibleTop = Math.max(rect.top, headerOffset);
        const visibleBottom = Math.min(rect.bottom, viewportHeight);
        const visibleHeight = Math.max(0, visibleBottom - visibleTop);
        const visibleArea = visibleHeight * rect.width;

        if (visibleArea > maxVisibleArea) {
          maxVisibleArea = visibleArea;
          maxVisiblePage = index + 1;
        }
      });

      // Method 2: Page center in viewport
      if (maxVisiblePage === 0) {
        maxVisiblePage =
          pages.findIndex((page) => {
            const rect = page.getBoundingClientRect();
            const pageCenter = rect.top + rect.height / 2;
            return pageCenter > headerOffset && pageCenter < viewportHeight;
          }) + 1;
      }

      // Method 3: First visible page
      if (maxVisiblePage === 0) {
        maxVisiblePage =
          pages.findIndex((page) => {
            const rect = page.getBoundingClientRect();
            return rect.top < viewportHeight && rect.bottom > headerOffset;
          }) + 1;
      }

      // Only update if we found a valid page and it's different from current
      if (maxVisiblePage > 0 && maxVisiblePage !== pageNumber) {
        setPageNumber(maxVisiblePage);
      }
    };

    // Handle scroll events with throttling
    const throttledHandleScroll = throttle(handleScroll, 50); // More responsive

    // Try multiple selectors to find the scrollable container
    const selectors = [
      ".react-pdf__Document.overflow-y-auto",
      ".react-pdf__Document",
      ".overflow-y-auto",
    ];

    let scrollContainer = null;
    for (const selector of selectors) {
      scrollContainer = document.querySelector(selector);
      if (scrollContainer) break;
    }

    // Initial check for current page
    setTimeout(handleScroll, 500);

    // Add scroll event listener
    if (scrollContainer) {
      scrollContainer.addEventListener("scroll", throttledHandleScroll);
      // Also listen for window scroll as a fallback
      window.addEventListener("scroll", throttledHandleScroll);
    } else {
      // If no container found, listen to window scroll
      window.addEventListener("scroll", throttledHandleScroll);
    }

    return () => {
      if (scrollContainer) {
        scrollContainer.removeEventListener("scroll", throttledHandleScroll);
      }
      window.removeEventListener("scroll", throttledHandleScroll);
    };
  }, [pageNumber]);
}
</file>

<file path="apps/flonotes/src/components/shell/pdf/providers/citations/types.ts">
import { z } from "zod";

export const verticesApiSchema = z
  .array(z.array(z.number()).length(2))
  .length(4);
export type VerticesApi = z.infer<typeof verticesApiSchema>;

export const orientationApiSchema = z.enum([
  "ORIENTATION_UNSPECIFIED",
  "PAGE_UP",
  "PAGE_DOWN",
  "PAGE_LEFT",
  "PAGE_RIGHT",
]);
export type OrientationApiSchema = z.infer<typeof orientationApiSchema>;

export const layoutApiSchema = z.object({
  vertices: verticesApiSchema.nullable(),
  orientation: orientationApiSchema.optional(),
});
export type LayoutApi = z.infer<typeof layoutApiSchema>;

export const blockApiSchema = z.object({
  id: z.number().int().nullable(),
  content: z.string(),
  layout: layoutApiSchema.nullable(),
  type: z.string().nullable(),
  page: z.number().int().nullable().optional(),
});
export type BlockApi = z.infer<typeof blockApiSchema>;

export const extractSourceApiSchema = z.object({
  fileUid: z.string().nullable(),
  location: z.string(),
  fileName: z.string(),
  mimeType: z.string(),
  metadata: z.record(z.string(), z.string()).nullish(),
});
export type ExtractSourceApi = z.infer<typeof extractSourceApiSchema>;

export const extractApiSchema = z.object({
  uid: z.string(),
  id: z.string(),
  pages: z.array(z.number()),
  text: z.string(),
  blocks: z.array(blockApiSchema),
  source: z.string(),
  blockIds: z.array(z.number()).nullable(),
});
export type ExtractApi = z.infer<typeof extractApiSchema>;
</file>

<file path="apps/flonotes/src/components/shell/pdf/providers/citations/use-highlights.ts">
import { useCitationsContext } from "./use-citations";
import { isFullArray } from "is-what";

export function useHighlights() {
  const citationsContext = useCitationsContext();
  const highlights = citationsContext.activeCitations;

  function getHighlightsForPage(pageNumber: number, pdfId: string) {
    if (!highlights) {
      return [];
    }
    return highlights.filter(
      (highlight) =>
        highlight.pages.includes(pageNumber) && highlight.source === pdfId,
    );
  }

  const isHighlights = isFullArray(highlights);

  return { getHighlightsForPage, isHighlights };
}
</file>

<file path="apps/flonotes/src/hooks/use-pdf-storage.ts">
import { ExtractApi } from "../components/shell/pdf/providers/citations/types";
import { db, ProcessedPDF } from "../indexed-db/db";

/**
 * Saves a PDF to the local database
 * @param pdf The PDF to save, without an ID
 * @returns The ID of the newly created PDF record
 */
export const savePdf = async (pdf: Omit<ProcessedPDF, "id">) => {
  return await db.pdfs.add(pdf);
};

/**
 * Deletes a PDF from the local database
 * @param id The ID of the PDF to delete
 */
export const deletePdf = async (id: number) => {
  return await db.pdfs.delete(id);
};

/**
 * Updates a PDF with extracts and associated metadata
 * This function is called after the PDF has been processed by the server
 *
 * @param id The ID of the PDF to update
 * @param extracts The extracts from the processed PDF
 * @param stemUid The stem UID associated with the PDF
 * @param pdfUid The PDF UID from the server
 */
export const updatePdfExtracts = async (
  id: number,
  extracts: ExtractApi[],
  stemUid?: string,
  pdfUid?: string,
) => {
  const updateObject: Partial<ProcessedPDF> = { extracts };

  // Always store the stemUid and pdfUid if provided
  if (stemUid) {
    updateObject.stemUid = stemUid;
    console.log(`Storing stemUid ${stemUid} for PDF ${id}`);
  }

  if (pdfUid) {
    updateObject.pdfUid = pdfUid;
    console.log(`Storing pdfUid ${pdfUid} for PDF ${id}`);
  }

  return await db.pdfs.update(id, updateObject);
};
</file>

<file path="apps/flonotes/src/indexed-db/db.ts">
import Dexie, { EntityTable } from "dexie";
import { ExtractApi } from "../components/shell/pdf/providers/citations/types";

export interface ProcessedPDF {
  id: number;
  fileName: string;
  documentType: "clinical" | "criteria";
  blob: Blob;
  extracts?: ExtractApi[];
  timestamp: number;
  stemUid?: string; // stemUid from the PDF processing API
  pdfUid?: string; // pdfUid from the PDF processing API
}

const db = new Dexie("PDFDatabase") as Dexie & {
  pdfs: EntityTable<ProcessedPDF, "id">;
};

db.version(2).stores({
  pdfs: "++id, documentType, stemUid",
});

export { db };
</file>

<file path="apps/flonotes/src/types/pdf-worker.d.ts">
/**
 * Declaration for PDF.js worker module.
 *
 * This is necessary because:
 * - The worker runs in a separate thread and must be loaded by URL at runtime
 * - It can't be handled through normal package.json imports
 * - In Vite, we load it with: new URL("pdfjs-dist/build/pdf.worker.min.mjs", import.meta.url)
 * - This declaration prevents TypeScript errors when referencing the module
 */
declare module "pdfjs-dist/build/pdf.worker.min.mjs";
</file>

<file path="apps/flonotes/src/utils/rotate-vertices.ts">
import { VerticesApi } from "../components/shell/pdf/providers/citations/types";

/**
 * Rotates PDF highlight vertices by specified degrees counter-clockwise.
 *
 * @param {VerticesApi} vertices - Array of [x, y] coordinate pairs
 * @param {number} degrees - Rotation angle in degrees (0, 90, 180, or 270)
 * @returns {Array<Array<number>>} Transformed vertices in the same format
 */
export default function rotateVertices(
  vertices: VerticesApi,
  degrees: number,
): VerticesApi {
  let _degrees = ((degrees % 360) + 360) % 360;

  // if input degrees is not 0, 90, 180, or 270, default to 0
  if (![0, 90, 180, 270].includes(_degrees)) {
    _degrees = 0;
  }

  const rotatedVertices = vertices.map(([x, y]) => {
    switch (_degrees) {
      case 0:
        return [x, y];
      case 90:
        return [1 - Number(y), x]; // Verified with test coordinates
      case 180:
        return [1 - Number(x), 1 - Number(y)]; // Flips both coordinates
      case 270:
        return [y, 1 - Number(x)]; // Verified with test coordinates
      default:
        return [x, y];
    }
  });

  return rotatedVertices as VerticesApi;
}
</file>

<file path="apps/flonotes/src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

// Import Routes

import { Route as rootRoute } from "./routes/__root";
import { Route as FlonotesImport } from "./routes/flonotes";
import { Route as IndexImport } from "./routes/index";

// Create/Update Routes

const FlonotesRoute = FlonotesImport.update({
  id: "/flonotes",
  path: "/flonotes",
  getParentRoute: () => rootRoute,
} as any);

const IndexRoute = IndexImport.update({
  id: "/",
  path: "/",
  getParentRoute: () => rootRoute,
} as any);

// Populate the FileRoutesByPath interface

declare module "@tanstack/react-router" {
  interface FileRoutesByPath {
    "/": {
      id: "/";
      path: "/";
      fullPath: "/";
      preLoaderRoute: typeof IndexImport;
      parentRoute: typeof rootRoute;
    };
    "/flonotes": {
      id: "/flonotes";
      path: "/flonotes";
      fullPath: "/flonotes";
      preLoaderRoute: typeof FlonotesImport;
      parentRoute: typeof rootRoute;
    };
  }
}

// Create and export the route tree

export interface FileRoutesByFullPath {
  "/": typeof IndexRoute;
  "/flonotes": typeof FlonotesRoute;
}

export interface FileRoutesByTo {
  "/": typeof IndexRoute;
  "/flonotes": typeof FlonotesRoute;
}

export interface FileRoutesById {
  __root__: typeof rootRoute;
  "/": typeof IndexRoute;
  "/flonotes": typeof FlonotesRoute;
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath;
  fullPaths: "/" | "/flonotes";
  fileRoutesByTo: FileRoutesByTo;
  to: "/" | "/flonotes";
  id: "__root__" | "/" | "/flonotes";
  fileRoutesById: FileRoutesById;
}

export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute;
  FlonotesRoute: typeof FlonotesRoute;
}

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  FlonotesRoute: FlonotesRoute,
};

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>();

/* ROUTE_MANIFEST_START
{
  "routes": {
    "__root__": {
      "filePath": "__root.tsx",
      "children": [
        "/",
        "/flonotes"
      ]
    },
    "/": {
      "filePath": "index.tsx"
    },
    "/flonotes": {
      "filePath": "flonotes.tsx"
    }
  }
}
ROUTE_MANIFEST_END */
</file>

<file path="apps/flonotes/package.json">
{
  "name": "@anterior-vibe/flonotes",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "typecheck": "tsc --noEmit",
    "dev": "nx vite:serve --port=3000",
    "build": "nx vite:build",
    "serve": "nx preview",
    "start": "nx vite:serve"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.0.14",
    "@tanstack/react-query": "^5.51.21",
    "@tanstack/react-query-devtools": "^5.51.21",
    "@tanstack/react-router": "^1.57.17",
    "@tanstack/react-table": "^8.20.5",
    "@tanstack/router-devtools": "^1.57.17",
    "@tanstack/router-plugin": "^1.57.15",
    "@types/lodash": "^4.17.16",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "postcss": "^8.4.47",
    "prettier": "^3.5.3",
    "tailwindcss": "^4.0.14",
    "vite": "^5.4.4"
  },
  "dependencies": {
    "@radix-ui/react-context-menu": "^2.2.5",
    "@radix-ui/react-dialog": "^1.1.5",
    "@radix-ui/react-dropdown-menu": "^2.1.5",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-select": "^2.1.5",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.7",
    "@tailwindcss/typography": "^0.5.16",
    "@tiptap/extension-collaboration": "^2.11.3",
    "@tiptap/extension-document": "^2.9.1",
    "@tiptap/extension-placeholder": "^2.9.1",
    "@tiptap/extension-task-item": "^2.11.5",
    "@tiptap/extension-task-list": "^2.11.5",
    "@tiptap/react": "^2.9.1",
    "@tiptap/starter-kit": "^2.9.1",
    "class-variance-authority": "^0.7.1",
    "client": "file:",
    "cmdk": "^1.0.4",
    "dexie": "^4.0.9",
    "dexie-react-hooks": "^1.1.7",
    "framer-motion": "^12.0.6",
    "lodash": "^4.17.21",
    "react": "^18.3.1",
    "react-aria": "^3.37.0",
    "react-dom": "^18.3.1",
    "react-pdf": "^9.1.1",
    "react-resize-detector": "^12.0.2",
    "superjson": "^2.2.1",
    "tailwind-merge": "^3.0.2",
    "tailwind-variants": "^0.3.1",
    "y-indexeddb": "^9.0.12",
    "yjs": "^13.6.23",
    "zod": "^3.23.8"
  }
}
</file>

<file path="apps/flonotes/tsconfig.json">
{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
</file>

<file path="apps/flonotes/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { TanStackRouterVite } from "@tanstack/router-plugin/vite";
import path from "path";

export default defineConfig({
  // nb: we may want to default to root "/"
  base: "/flonotes/",
  plugins: [react(), TanStackRouterVite()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./"),
    },
  },
  build: {
    sourcemap: true,
    // for asset tracking
    manifest: true,
  },
});
</file>

<file path="apps/flopilot/src/env.ts">
import { z } from "zod/v4";

const envSchema = z.object({
  VITE_NOGGIN_HOST: z.url(),
});

// 🚨 This will only run time validate, but not at build time.
// Needs more work to make it do that, one attempt is writing
// your own Vite plugin.
export const env = envSchema.parse(import.meta.env);
</file>

<file path="apps/mnr-determination-viewer/src/env.ts">
import { z } from "zod";

const envSchema = z.object({
  VITE_NOGGIN_HOST: z.string().url(),
});

// 🚨 This will only run time validate, but not at build time.
// Needs more work to make it do that, one attempt is writing
// your own Vite plugin.
export const env = envSchema.parse(import.meta.env);
</file>

<file path="apps/mnr-determination-viewer/src/reportWebVitals.ts">
const reportWebVitals = (onPerfEntry?: () => void) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import("web-vitals").then(({ onCLS, onINP, onFCP, onLCP, onTTFB }) => {
      onCLS(onPerfEntry);
      onINP(onPerfEntry);
      onFCP(onPerfEntry);
      onLCP(onPerfEntry);
      onTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="lib/shared/flopilot/components/icons/types.ts">
export interface IconProps extends React.SVGAttributes<SVGElement> {
  children?: never;
  color?: string;
}
</file>

<file path="lib/shared/flopilot/components/ui/pdf/hooks/use-throttled-scroll.ts">
import { usePageNumber } from "../providers/use-page-number-provider";
import { throttle } from "lodash";
import { useEffect } from "react";

export function useThrottledScroll() {
  const [pageNumber, setPageNumber] = usePageNumber();

  useEffect(() => {
    const handleScroll = () => {
      // Get all PDF pages
      const pages = Array.from(document.querySelectorAll(".react-pdf__Page"));
      if (!pages.length) return;

      // Get viewport dimensions
      const headerOffset = 72; // 40px tabs + 32px indicator
      const viewportHeight = window.innerHeight;

      // Try multiple methods to find the current page

      // Method 1: Most visible area
      let maxVisiblePage = 0;
      let maxVisibleArea = 0;

      pages.forEach((page, index) => {
        const rect = page.getBoundingClientRect();
        // Calculate visible area
        const visibleTop = Math.max(rect.top, headerOffset);
        const visibleBottom = Math.min(rect.bottom, viewportHeight);
        const visibleHeight = Math.max(0, visibleBottom - visibleTop);
        const visibleArea = visibleHeight * rect.width;

        if (visibleArea > maxVisibleArea) {
          maxVisibleArea = visibleArea;
          maxVisiblePage = index + 1;
        }
      });

      // Method 2: Page center in viewport
      if (maxVisiblePage === 0) {
        maxVisiblePage =
          pages.findIndex((page) => {
            const rect = page.getBoundingClientRect();
            const pageCenter = rect.top + rect.height / 2;
            return pageCenter > headerOffset && pageCenter < viewportHeight;
          }) + 1;
      }

      // Method 3: First visible page
      if (maxVisiblePage === 0) {
        maxVisiblePage =
          pages.findIndex((page) => {
            const rect = page.getBoundingClientRect();
            return rect.top < viewportHeight && rect.bottom > headerOffset;
          }) + 1;
      }

      // Only update if we found a valid page and it's different from current
      if (maxVisiblePage > 0 && maxVisiblePage !== pageNumber) {
        setPageNumber(maxVisiblePage);
      }
    };

    // Handle scroll events with throttling
    const throttledHandleScroll = throttle(handleScroll, 50); // More responsive

    // Try multiple selectors to find the scrollable container
    const selectors = [
      ".react-pdf__Document.overflow-y-auto",
      ".react-pdf__Document",
      ".overflow-y-auto",
    ];

    let scrollContainer = null;
    for (const selector of selectors) {
      scrollContainer = document.querySelector(selector);
      if (scrollContainer) break;
    }

    // Initial check for current page
    setTimeout(handleScroll, 500);

    // Add scroll event listener
    if (scrollContainer) {
      scrollContainer.addEventListener("scroll", throttledHandleScroll);
      // Also listen for window scroll as a fallback
      window.addEventListener("scroll", throttledHandleScroll);
    } else {
      // If no container found, listen to window scroll
      window.addEventListener("scroll", throttledHandleScroll);
    }

    return () => {
      if (scrollContainer) {
        scrollContainer.removeEventListener("scroll", throttledHandleScroll);
      }
      window.removeEventListener("scroll", throttledHandleScroll);
    };
  }, [pageNumber]);
}
</file>

<file path="lib/shared/flopilot/components/ui/pdf/providers/citations/schemas.ts">
import { z } from "zod/v4";

export const boundingBoxSchema = z.object({
  top: z.number(),
  bottom: z.number(),
  left: z.number(),
  right: z.number(),
}) satisfies z.ZodType<BoundingBox>;

export type BoundingBox = {
  top: number;
  bottom: number;
  left: number;
  right: number;
};

export const pdfSectionSchema = z.object({
  pdfId: z.string(),
  page: z.number().int().positive(),
  boundingBox: boundingBoxSchema,
}) satisfies z.ZodType<PdfSection>;

export type PdfSection = {
  pdfId: string;
  page: number;
  boundingBox: BoundingBox;
};

export const textSectionSchema = z.object({
  messageId: z.string(),
  start: z.number(),
  end: z.number(),
}) satisfies z.ZodType<TextSection>;

export type TextSection = {
  messageId: string;
  start: number;
  end: number;
};
</file>

<file path="lib/shared/flopilot/components/ui/pdf/providers/citations/use-highlights.ts">
import { useCitationsContext } from "./use-citations";

export function useHighlights() {
  const citationsContext = useCitationsContext();
  const highlights = citationsContext.citations;

  function getHighlightsForPage(pageNumber: number, pdfId: string) {
    if (!highlights) {
      return [];
    }
    return highlights.filter(
      (highlight) => highlight.page === pageNumber && highlight.pdfId === pdfId,
    );
  }

  const isHighlights = Array.isArray(highlights) && highlights.length > 0;

  return { getHighlightsForPage, isHighlights };
}
</file>

<file path="lib/shared/flopilot/controller/indexed-db/db.ts">
import Dexie, { type EntityTable } from "dexie";

export type UploadedPdfDetails = {
  ref: string;
  file: File;
};

const db = new Dexie("flopilot-uploaded-pdfs-db") as Dexie & {
  uploadedPdfs: EntityTable<UploadedPdfDetails, "ref">;
};

db.version(1).stores({
  uploadedPdfs: "ref",
});

export { db };
</file>

<file path="lib/shared/flopilot/controller/models/llm-message.ts">
import { z } from "zod/v4";

export type Section = {
  section_type: string;
  section_artifact_ref: string;
  section_data: unknown;
};
export type ContentBlock =
  | {
      content_block_type: "text";
      text: string;
    }
  | {
      content_block_type: "citation";
      to_section: Section;
    }
  | {
      content_block_type: "artifact";
      artifact_type: string;
      artifact_ref: string;
    };

export type ChatLlmMessageV0120250607 = {
  artifact_type: "chat_llm_message_v01_20250607";
  message_id: string;
  content_blocks: Array<ContentBlock>;
};

export const chatLlmMessageV0120250607 = z
  .object({
    artifact_type: z.literal("chat_llm_message_v01_20250607"),
    message_id: z.string(),
    content_blocks: z.array(
      z.discriminatedUnion("content_block_type", [
        z.object({
          content_block_type: z.literal("text"),
          text: z.string(),
        }),
        z.object({
          content_block_type: z.literal("citation"),
          to_section: z.object({
            section_type: z.string(),
            section_artifact_ref: z.string(),
            section_data: z.unknown(),
          }),
        }),
        z.object({
          content_block_type: z.literal("artifact"),
          artifact_type: z.string(),
          artifact_ref: z.string(),
        }),
      ]),
    ),
  })
  .strict() satisfies z.ZodType<ChatLlmMessageV0120250607>;
</file>

<file path="lib/shared/flopilot/controller/models/note-template.ts">
import { z } from "zod";

export const noteTemplatePopulatedV0120250606 = z
  .object({
    questions_w_answers: z
      .record(
        z.object({
          display_question: z
            .string()
            .describe("The question shown to the user."),
          style: z.enum([
            "text",
            "short_text",
            "date",
            "list",
            "temporal_list",
          ]),
          question: z
            .string()
            .describe("Descriptive question sent to the LLM."),
          context: z
            .union([z.string(), z.null()])
            .describe("Extra LLM context to guide the answer.")
            .default(""),
          answer_complete: z
            .union([z.string(), z.null()])
            .describe("The answer to the question, populated by the LLM.")
            .default(null),
          answer_text: z
            .union([z.string(), z.null()])
            .describe("Just the text of the answer.")
            .default(null),
          clinical_set_id: z
            .union([z.string(), z.null()])
            .describe("The clinical ID this filled template is associated with")
            .default(null),
        }),
      )
      .describe("All template questions."),
    artifact_type: z.literal("note_template_populated_v01_20250606"),
  })
  .describe(
    "A template for structured, LLM-infused notes.\n\nWe may want to add validators depending on what we all agree a NoteTemplate should\nlook like, before it's injected with LLM content based on a clinical source document(s).\n\nWe need fns to generate the HTML for this template.",
  ) satisfies z.ZodType<NoteTemplatePopulatedV0120250606>;

export type NoteTemplatePopulatedV0120250606 = {
  questions_w_answers: Record<
    string,
    {
      display_question: string;
      style: "text" | "short_text" | "date" | "list" | "temporal_list";
      question: string;
      context?: string | null | undefined;
      answer_complete?: string | null | undefined;
      answer_text?: string | null | undefined;
      clinical_set_id?: string | null | undefined;
    }
  >;
  artifact_type: "note_template_populated_v01_20250606";
};
</file>

<file path="lib/shared/flopilot/controller/models/sections.ts">
import { z } from "zod/v4";

export const pdfSectionV0120250514 = z
  .object({
    bounding_box: z
      .object({
        bottom: z.number().gte(0).lte(1),
        left: z.number().gte(0).lte(1),
        right: z.number().gte(0).lte(1),
        top: z.number().gte(0).lte(1),
      })
      .strict()
      .describe(
        "Defines a rectangle using four edges (top, right, bottom, and left). All values are percentages ranging from 0 to 1.",
      ),
    page: z
      .number()
      .gte(1)
      .describe("Page index in the source document (1-based)."),
    section_type: z.literal("pdf_section_v01_20250514"),
  })
  .strict()
  .describe("A rectangular region on a PDF page");
export type PdfSectionV0120250514 = z.infer<typeof pdfSectionV0120250514>;

export const textSectionV0120250514 = z
  .object({
    end: z.number(),
    section_type: z.literal("text_section_v01_20250514"),
    start: z.number(),
  })
  .strict()
  .describe(
    "Section of text with char range indices [start, end) in the source document.",
  );
export type TextSectionV0120250514 = z.infer<typeof textSectionV0120250514>;
</file>

<file path="lib/shared/flopilot/controller/models/user-message.ts">
import { z } from "zod/v4";

export type ChatUserMessageV0120250606 = {
  artifact_type: "chat_user_message_v01_20250606";
  message_id: string;
  content: string;
  source_refs?: string[] | undefined;
};

export const chatUserMessageV0120250606 = z
  .object({
    artifact_type: z.literal("chat_user_message_v01_20250606"),
    message_id: z.string().describe("The unique ID of the message"),
    content: z.string().describe("The content of the message"),
    source_refs: z
      .array(z.string().regex(new RegExp("^ant://wks_.*$")))
      .describe("The source references uploaded in the context of this message")
      .optional(),
  })
  .strict() satisfies z.ZodType<ChatUserMessageV0120250606>;
</file>

<file path="lib/shared/flopilot/controller/utils/llm-mesasge.ts">
import type { PdfSection } from "../../components/ui/pdf/providers/citations/schemas";
import { pdfSectionV0120250514 } from "../models/sections";
import type { ChatLlmMessageV0120250607 } from "../models/llm-message";

export function getTextContentFromMessage(
  message: ChatLlmMessageV0120250607,
): string {
  return message.content_blocks.reduce((acc, eachMessage) => {
    if (eachMessage.content_block_type === "text") {
      return acc + eachMessage.text;
    }
    return acc;
  }, "");
}

export function getPdfSectionsFromMessage(
  message: ChatLlmMessageV0120250607,
): PdfSection[] {
  return message.content_blocks
    .filter((citation) => citation.content_block_type === "citation")
    .map((citation) => {
      if (citation.to_section.section_type === "pdf_section_v01_20250514") {
        const pdfSection = pdfSectionV0120250514.parse(
          citation.to_section.section_data,
        );
        return {
          pdfId: citation.to_section.section_artifact_ref,
          boundingBox: pdfSection.bounding_box,
          page: pdfSection.page,
        };
      }
      return undefined;
    })
    .filter((section) => section !== undefined);
}
</file>

<file path="lib/shared/flopilot/controller/use-chat-controller.ts">
import { env } from "../env";
import { useMutation } from "@tanstack/react-query";
import { z } from "zod/v4";
import { useSavedPromptController } from "./use-saved-prompt-controller";
import { useQueryClient } from "@tanstack/react-query";
import type { InitialMessageType } from "../types/initial-message-type";
import { anteriorSavedPrompts } from "../view/anterior-prompts/saved-prompts-db";

type ChatRequestBody = {
  stem_id: string;
  user_message: {
    content: string;
    source_refs?: string[] | undefined;
  };
};
const chatRequestBodySchema = z.object({
  stem_id: z.string(),
  user_message: z.object({
    content: z.string().min(1),
    source_refs: z.optional(z.string().array()),
  }),
}) satisfies z.ZodType<ChatRequestBody>;

type ChatResponseBody = {
  stem_id: string;
};
const chatResponseBodySchema = z.object({
  stem_id: z.string(),
}) satisfies z.ZodType<ChatResponseBody>;

export function useChatController(stemId: string) {
  const { savedPrompts } = useSavedPromptController();
  const queryClient = useQueryClient();

  const {
    mutateAsync,
    error,
    status: chatMutationStatus,
  } = useMutation<
    ChatResponseBody,
    Error,
    {
      userMessage: string;
      messageType: InitialMessageType;
      sourceRefs?: string[];
    }
  >({
    mutationKey: ["chat", stemId],
    mutationFn: async ({ userMessage, messageType, sourceRefs }) => {
      // 1. Prepare the message to be sent to the `/chat` API

      // In case of a saved prompt, we need to unpack the saved prompt. The
      // prompt title is used as the message shown to the user. So, we replace
      // the prompt title with the actual saved prompt content.
      let unpackedMessage = userMessage;
      if (messageType === "saved-prompt-user") {
        const savedPrompt = savedPrompts.find(
          (savedPrompt) => savedPrompt.title === userMessage,
        );
        if (savedPrompt === undefined) {
          throw new Error("Saved prompt not found");
        }
        unpackedMessage = savedPrompt.content;
      } else if (messageType === "saved-prompt-anterior") {
        const savedPrompt = anteriorSavedPrompts
          .flatMap((category) => category.saved_prompts)
          .find((savedPrompt) => savedPrompt.title === userMessage);
        if (savedPrompt === undefined) {
          throw new Error("Saved prompt not found");
        }
        unpackedMessage = savedPrompt.prompt;
      }

      // 2. Send the message to the `/chat` API
      const response = await fetch(`${env.VITE_NOGGIN_HOST}/chat/orchestrate`, {
        method: "POST",
        credentials: "include",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(
          chatRequestBodySchema.parse({
            stem_id: stemId,
            user_message: {
              content: unpackedMessage,
              source_refs: sourceRefs,
            },
          }),
        ),
      });
      if (!response.ok) {
        throw new Error(
          `Failed to send message to /chat API: ${response.status} ${response.statusText}`,
        );
      }
      queryClient.invalidateQueries({ queryKey: ["flopilot-stem", stemId] });
      const message = await response.json();
      return chatResponseBodySchema.parse(message);
    },
  });

  type ChatProps = {
    userMessage: string;
    messageType: InitialMessageType;
    sourceRefs?: string[];
    onSuccess?: () => void;
  };
  async function chat({
    userMessage,
    messageType,
    sourceRefs = [],
    onSuccess = () => {},
  }: ChatProps) {
    await mutateAsync({
      userMessage,
      messageType,
      sourceRefs,
    });
    onSuccess();
  }

  return {
    chat,
    error,
    chatMutationStatus,
  };
}
</file>

<file path="lib/shared/flopilot/controller/use-create-stem-controller.ts">
import { env } from "../env";
import { useMutation } from "@tanstack/react-query";
import { useState, useEffect, useRef } from "react";
import { z } from "zod/v4";

type CreateStemResponse = {
  stemId: string;
};
const createStemResponseSchema = z.object({
  stemId: z.string(),
}) satisfies z.ZodType<CreateStemResponse>;

export function useCreateStemController() {
  const [stemId, setStemId] = useState<string | null>(null);
  const { mutateAsync, error } = useMutation<void, Error, void>({
    mutationKey: ["create-stem"],
    mutationFn: async () => {
      const response = await fetch(`${env.VITE_NOGGIN_HOST}/stems`, {
        method: "POST",
        credentials: "include",
      });
      if (!response.ok) {
        throw new Error(
          `Failed to create stem: ${response.status} ${response.statusText}`,
        );
      }
      const data = createStemResponseSchema.parse(await response.json());
      setStemId(data.stemId);
    },
  });
  const createdStemRef = useRef(false);

  useEffect(() => {
    if (stemId === null && createdStemRef.current === false) {
      createdStemRef.current = true;
      mutateAsync();
    }
  }, [stemId]);

  return { stemId, error };
}
</file>

<file path="lib/shared/flopilot/controller/use-flopilot-stem-controller.ts">
import { env } from "../env";
import { useQuery } from "@tanstack/react-query";
import { z } from "zod/v4";
import { chatUserMessageV0120250606 } from "./models/user-message";
import { useSavedPromptController } from "./use-saved-prompt-controller";
import { getPdfSectionsFromMessage } from "./utils/llm-mesasge";
import { chatLlmMessageV0120250607 } from "./models/llm-message";
import { useCitationsContext } from "../components/ui/pdf/providers/citations/use-citations";
import type { InitialMessageType } from "../types/initial-message-type";
import { anteriorSavedPrompts } from "../view/anterior-prompts/saved-prompts-db";

type Message = {
  role: "user" | "assistant";
  created_at: string;
  message_data: unknown;
};

export type Artifact = {
  artifact_ref_source: string;
  artifact_data: unknown;
};

export type FlopilotStemResponse = {
  messages: Message[];
  artifacts: Array<Artifact>;
  is_assistant_pending: boolean;
};

export const flopilotStemResponseSchema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(["user", "assistant"]),
      created_at: z.iso.datetime(),
      message_data: z.unknown(),
    }),
  ),
  artifacts: z
    .array(
      z.object({
        artifact_ref_source: z.string(),
        artifact_data: z.unknown(),
      }),
    )
    .default([]),
  is_assistant_pending: z.boolean(),
}) satisfies z.ZodType<FlopilotStemResponse>;

export function useFlopilotStemController(
  stemId: string,
  initialMessageType: InitialMessageType,
) {
  const { savedPrompts } = useSavedPromptController();
  const { setCitations } = useCitationsContext();

  const { data, error } = useQuery({
    queryKey: ["flopilot-stem", stemId],
    queryFn: async () => {
      const response = await fetch(
        `${env.VITE_NOGGIN_HOST}/flopilot/stems/${stemId}/project`,
        {
          method: "GET",
          credentials: "include",
        },
      );
      if (!response.ok) {
        throw new Error(
          `Failed to create stem: ${response.status} ${response.statusText}`,
        );
      }
      const flopilotStem = flopilotStemResponseSchema.parse(
        await response.json(),
      );

      // Do frontend post-processing of the responses

      // In case of a saved prompt, we need to repack the message to go from the
      // actual saved prompt content to the prompt title.
      flopilotStem.messages = flopilotStem.messages.map((message, index) => {
        if (index > 0) {
          // Only the first message can be a saved prompt, so they don't need to
          // be repacked.
          return message;
        }
        if (initialMessageType === "text") {
          // Early return if the first message is not a saved prompt
          return message;
        }
        if (message.role !== "user") {
          throw new Error("Expected user message to be the first message");
        }
        const userMessageData = chatUserMessageV0120250606.parse(
          message.message_data,
        );
        // Go from the saved prompt content to the prompt title
        if (initialMessageType === "saved-prompt-user") {
          const savedPrompt = savedPrompts.find(
            (savedPrompt) => savedPrompt.content === userMessageData.content,
          );
          if (savedPrompt === undefined) {
            // This should be an impossible state
            throw new Error("Saved prompt not found");
          }
          userMessageData.content = savedPrompt.title;
        } else if (initialMessageType === "saved-prompt-anterior") {
          const savedPrompt = anteriorSavedPrompts
            .flatMap((category) => category.saved_prompts)
            .find(
              (savedPrompt) => savedPrompt.prompt === userMessageData.content,
            );
          if (savedPrompt === undefined) {
            // This should be an impossible state
            throw new Error("Saved prompt not found");
          }
          userMessageData.content = savedPrompt.title;
        }
        return {
          ...message,
          message_data: userMessageData,
        };
      });

      const lastAssistantMessage =
        flopilotStem.messages[flopilotStem.messages.length - 1];
      if (!lastAssistantMessage || lastAssistantMessage.role !== "assistant") {
        // Early return if the last message is not an assistant message
        return flopilotStem;
      }
      const assistantMessageData = chatLlmMessageV0120250607.parse(
        lastAssistantMessage.message_data,
      );
      setCitations(getPdfSectionsFromMessage(assistantMessageData));
      return flopilotStem;
    },
    refetchInterval: (query) => {
      if (query.state.data?.is_assistant_pending) {
        return 1_000;
      }
      return 5_000;
    },
  });
  return { data, error };
}
</file>

<file path="lib/shared/flopilot/controller/use-prompt-controller.ts">
import { useNavigate } from "@tanstack/react-router";
import { type InitialMessageType } from "../types/initial-message-type";

export function usePromptController() {
  const navigate = useNavigate();
  const navigateToChat = async (stemId: string, type: InitialMessageType) => {
    try {
      // Navigate to the chat route with the initial message
      navigate({
        to: "/flopilot/chats/$stemId",
        params: { stemId },
        search: { initialMessageType: type },
      });
    } catch (error) {
      console.error("Failed to send message:", error);
      // TODO: Add error handling UI
    }
  };

  return { navigateToChat };
}
</file>

<file path="lib/shared/flopilot/controller/use-saved-prompt-controller.ts">
import { useState, useEffect } from "react";
import type { SavedPrompt } from "../types/saved-prompt";

const STORAGE_KEY = "saved-prompts" as const;

export function useSavedPromptController() {
  const [savedPrompts, setSavedPrompts] = useState<SavedPrompt[]>(() => {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        return Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        console.error("Failed to load saved prompts:", error);
        return [];
      }
    }
    return [];
  });

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(savedPrompts));
  }, [savedPrompts]);

  const handleSavePromptClick = (content: string, title: string) => {
    const newPrompt: SavedPrompt = {
      id: crypto.randomUUID(),
      title: title.trim() || `Prompt ${savedPrompts.length + 1}`,
      content,
      createdAt: new Date().toISOString(),
    };
    setSavedPrompts((prev) => [...prev, newPrompt]);
  };

  const handleDeletePromptClick = (id: string) => {
    setSavedPrompts((prev) => prev.filter((prompt) => prompt.id !== id));
  };

  return {
    savedPrompts,
    handleSavePromptClick,
    handleDeletePromptClick,
    isSavedPrompt: (content: string) =>
      savedPrompts.some((p) => p.content === content),
  };
}
</file>

<file path="lib/shared/flopilot/controller/use-upload-artifacts-controller.ts">
import { env } from "../env";
import { useMutation } from "@tanstack/react-query";
import { type BulkError } from "dexie";
import { type UploadedPdfDetails, db } from "./indexed-db/db";
import { useState } from "react";
import { useLiveQuery } from "dexie-react-hooks";
import { z } from "zod/v4";

type UploadArtifactResponse = {
  artifacts: string[];
};
const uploadArtifactResponseSchema = z.object({
  artifacts: z.array(z.string()),
}) satisfies z.ZodType<UploadArtifactResponse>;

type AttachToStemRequest = {
  artifacts: string[];
};
const attachToStemRequestSchema = z.object({
  artifacts: z.array(z.string()),
}) satisfies z.ZodType<AttachToStemRequest>;

type AttachToStemResponse = {
  success: boolean;
};
const attachToStemResponseSchema = z.object({
  success: z.boolean(),
}) satisfies z.ZodType<AttachToStemResponse>;

const ARTIFACTS_KEY = ["artifacts"] as const;

export const useUploadArtifactsController = (stemId: string) => {
  const [uploadedRefs, setUploadedRefs] = useState<string[]>([]);
  const uploadedFiles =
    useLiveQuery(
      () => db.uploadedPdfs.where("ref").anyOf(uploadedRefs).toArray(),
      [uploadedRefs],
    ) ?? [];
  const [uploadingFileMap, setUploadingFileMap] = useState<Map<string, File>>(
    new Map(),
  );

  const { mutateAsync: uploadPdfs, status: uploadingStatus } = useMutation<
    UploadedPdfDetails[],
    Error,
    File[]
  >({
    mutationKey: ["POST", ARTIFACTS_KEY],
    mutationFn: async (files: File[]) => {
      // Create a map of temporary IDs to files
      const newUploadingMap = new Map(
        files.map((file) => [`uploading-${file.name}`, file]),
      );

      setUploadingFileMap((prev) => new Map([...prev, ...newUploadingMap]));

      const formData = new FormData();
      files.forEach((file) => {
        formData.append("artifacts[]", file);
      });

      const uploadArtifactsRes = await fetch(
        `${env.VITE_NOGGIN_HOST}/artifacts`,
        {
          method: "POST",
          credentials: "include",
          body: formData,
        },
      );
      if (!uploadArtifactsRes.ok) {
        throw new Error(
          `Failed to upload PDF: ${uploadArtifactsRes.status} ${uploadArtifactsRes.statusText}`,
        );
      }
      const uploadArtifactsData = uploadArtifactResponseSchema.parse(
        await uploadArtifactsRes.json(),
      );

      // Attach artifacts to stem
      const attachToStemRes = await fetch(
        `${env.VITE_NOGGIN_HOST}/stems/${stemId}/artifacts`,
        {
          method: "POST",
          credentials: "include",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(
            attachToStemRequestSchema.parse(uploadArtifactsData),
          ),
        },
      );
      if (!uploadArtifactsRes.ok) {
        throw new Error(
          `Failed to attach artifacts ${uploadArtifactsData.artifacts} to stem ${stemId}: ${uploadArtifactsRes.status} ${uploadArtifactsRes.statusText}`,
        );
      }
      const attachToStemData = attachToStemResponseSchema.parse(
        await attachToStemRes.json(),
      );
      if (attachToStemData.success === false) {
        throw new Error(
          `Failed to attach artifacts ${uploadArtifactsData.artifacts} to stem ${stemId}`,
        );
      }

      // Update state AFTER attaching to stem
      setUploadedRefs((current) => [
        ...current,
        ...uploadArtifactsData.artifacts,
      ]);

      const uploadedDetails = uploadArtifactsData.artifacts.map((ref, i) => {
        const file = files[i];
        if (file === undefined) {
          throw new Error("File is undefined");
        }
        return {
          ref,
          file,
        };
      });
      // Add to database
      try {
        await db.uploadedPdfs.bulkAdd(uploadedDetails);
      } catch (e) {
        // Allow key already exists in store Error
        if (e instanceof Object && "name" in e && e.name === "BulkError") {
          const error = e as BulkError;
          const isAllKeyError = error.failures.every(
            (failure) =>
              failure.name === "ConstraintError" &&
              failure.message.toLowerCase().includes("key already exists"),
          );
          if (!isAllKeyError) {
            throw e;
          }
          // Do nothing if all key already exists error
        } else {
          throw e;
        }
      }

      return uploadedDetails;
    },
    onSettled: (_, __, files) => {
      setUploadingFileMap((prev) => {
        const newMap = new Map(prev);
        files.forEach((file) => newMap.delete(`uploading-${file.name}`));
        return newMap;
      });
    },
  });

  const allFiles = [
    ...uploadedFiles,
    ...Array.from(uploadingFileMap.entries()).map(([ref, file]) => ({
      ref,
      file,
    })),
  ];

  type HandleAddPdfProps = {
    event: React.ChangeEvent<HTMLInputElement>;
    onSuccess?: (uploadedPdfs: UploadedPdfDetails[]) => void;
  };
  const handleAddPdf = async ({
    event,
    onSuccess = () => {},
  }: HandleAddPdfProps) => {
    if (!event.target.files || event.target.files.length === 0) return;
    const files = Array.from(event.target.files);
    const uploadedPdfs = await uploadPdfs(files);
    onSuccess(uploadedPdfs);
  };

  return {
    handleAddPdf,
    uploadedRefs,
    allFiles,
    uploadingStatus,
  };
};
</file>

<file path="lib/shared/flopilot/hooks/use-mobile.ts">
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
</file>

<file path="lib/shared/flopilot/hooks/use-save-prompt-state.ts">
import { useState } from "react";

type SavePromptState = "idle" | "editing" | "saved";

interface UseSavePromptStateProps {
  initialSaved?: boolean;
  onSave: (title: string) => void;
}

export const useSavePromptState = ({
  initialSaved = false,
  onSave,
}: UseSavePromptStateProps) => {
  const [state, setState] = useState<SavePromptState>(
    initialSaved ? "saved" : "idle",
  );
  const [title, setTitle] = useState("");

  const startEditing = () => {
    if (state !== "saved") {
      setState("editing");
    }
  };

  const cancelEditing = () => {
    setState("idle");
    setTitle("");
  };

  const handleSave = () => {
    onSave(title);
    setState("saved");
    setTitle("");
  };

  return {
    state,
    title,
    setTitle,
    isEditing: state === "editing",
    isSaved: state === "saved",
    actions: {
      startEditing,
      cancelEditing,
      handleSave,
    },
  };
};
</file>

<file path="lib/shared/flopilot/lib/format-compact-number.ts">
export function formatCompactNumber(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1).replace(/\.0$/, "") + "M";
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1).replace(/\.0$/, "") + "k";
  }
  return num.toString();
}
</file>

<file path="lib/shared/flopilot/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export const convertMIMEToUserFriendlyFormat = (mime: string) => {
  switch (mime) {
    case "application/pdf":
      return "PDF";
    case "image/jpeg":
      return "JPEG";
    case "image/png":
      return "PNG";
  }
  return mime;
};
</file>

<file path="lib/shared/flopilot/types/initial-message-type.ts">
import { z } from "zod/v4";

export const initialMessageTypeSchema = z.enum([
  "text",
  "saved-prompt-user",
  "saved-prompt-anterior",
]) satisfies z.ZodType<InitialMessageType>;

export type InitialMessageType =
  | "text"
  | "saved-prompt-user"
  | "saved-prompt-anterior";
</file>

<file path="lib/shared/flopilot/types/saved-prompt.ts">
export interface SavedPrompt {
  id: string;
  content: string;
  title: string;
  createdAt: string;
}
</file>

<file path="lib/shared/flopilot/view/anterior-prompts/saved-prompts-db.ts">
import type { AnteriorSavedPromptsByCategory } from "./types";

export const anteriorSavedPrompts: AnteriorSavedPromptsByCategory[] = [
  {
    category: "quality",
    title: "Quality Review",
    description: "Prompts to speed your workflow",
    color: "var(--color-anterior-950)",
    saved_prompts: [
      {
        title: "HEDIS",
        prompt: "Analyze the clinicals for a patient outpatient visit",
        icon: "outpatient-icon",
      },
      {
        title: "Trigger Review",
        prompt: "Analyze the clinicals for outpatient pain management",
        icon: "drugs-icon",
      },
      {
        title: "Accreditation",
        prompt: "Analyze the clinicals for an inpatient admission",
        icon: "inpatient-icon",
      },
      {
        title: "CAHPS",
        prompt: "Analyze the clinicals for a multi-day inpatient visit",
        icon: "hashtag-icon",
      },
    ],
  },
  {
    category: "claims",
    title: "Claims",
    description: "Start every review on solid ground",
    color: "var(--color-blue-950)",
    saved_prompts: [
      {
        title: "Payment Integrity",
        prompt: "Lorem",
        icon: "search-icon",
      },
      {
        title: "Claim Edits",
        prompt: "Lorem",
        icon: "help-icon",
      },
      {
        title: "DRG Review",
        prompt: "Lorem",
        icon: "reviews-icon",
      },
      {
        title: "Pre-payment Review",
        prompt: "Lorem",
        icon: "member-icon",
      },
    ],
  },
  {
    category: "management",
    title: "Medical Management",
    description: "Draft compliant communication",
    color: "var(--color-yellow-950)",
    saved_prompts: [
      {
        title: "Home Health",
        prompt: "Lorem",
        icon: "outpatient-icon",
      },
      {
        title: "Outpatient Review",
        prompt: "Lorem",
        icon: "drugs-icon",
      },
      {
        title: "Inpatient Review",
        prompt: "Lorem",
        icon: "inpatient-icon",
      },
      {
        title: "Behavioral Health",
        prompt: "Lorem",
        icon: "hashtag-icon",
      },
    ],
  },
  {
    category: "billing",
    title: "Enrollment and Billing",
    description: "Check your work",
    color: "var(--color-ink-950)",
    saved_prompts: [
      {
        title: "Demographics",
        prompt: "Lorem",
        icon: "outpatient-icon",
      },
      {
        title: "Premium Billing",
        prompt: "Lorem",
        icon: "drugs-icon",
      },
      {
        title: "Plan Allocation",
        prompt: "Lorem",
        icon: "inpatient-icon",
      },
      {
        title: "Payment Collections",
        prompt: "Lorem",
        icon: "hashtag-icon",
      },
    ],
  },
  {
    category: "risk",
    title: "Risk Adjustment",
    description: "Ensure regulatory alignment",
    color: "var(--color-green-950)",
    saved_prompts: [
      {
        title: "Retrospective Clinical Review",
        prompt: "Lorem",
        icon: "outpatient-icon",
      },
      {
        title: "Prospective",
        prompt: "Lorem",
        icon: "drugs-icon",
      },
      {
        title: "HCC Hierarchy",
        prompt: "Lorem",
        icon: "inpatient-icon",
      },
      {
        title: "Edge Server Submission",
        prompt: "Lorem",
        icon: "hashtag-icon",
      },
    ],
  },
];
</file>

<file path="lib/shared/flopilot/view/anterior-prompts/types.ts">
export type AnteriorSavedPrompt = {
  title: string;
  prompt: string;
  icon: string;
};

export type AnteriorSavedPromptsByCategory = {
  category: string;
  title: string;
  description: string;
  color: string;
  saved_prompts: AnteriorSavedPrompt[];
};
</file>

<file path="lib/shared/flopilot/view/artifact-viewer/tiptap/editor-config.ts">
import StarterKit from "@tiptap/starter-kit";
import Document from "@tiptap/extension-document";

export function getEditorConfig() {
  return [
    Document,
    StarterKit.configure({
      document: false,
      history: false,
    }),
  ];
}
</file>

<file path="lib/shared/flopilot/env.ts">
import { z } from "zod/v4";

const envSchema = z.object({
  VITE_NOGGIN_HOST: z.url(),
});

// 🚨 This will only run time validate, but not at build time.
// Needs more work to make it do that, one attempt is writing
// your own Vite plugin.
export const env = envSchema.parse(import.meta.env);
</file>

<file path="lib/shared/package.json">
{
  "name": "@anterior-vibe/lib-shared",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "exports": {
    "./*": {
      "import": "./*"
    }
  },
  "dependencies": {
    "reactflow": "^11.11.4",
    "elkjs": "^0.10.0",
    "react-aria-components": "^1.8.0",
    "cmdk": "^1.1.1",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-radio-group": "^1.3.7",
    "react-intersection-observer": "^9.16.0"
  }
}
</file>

<file path="lib/shared/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "types": [
      "vite/client"
    ],
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": false,
    "verbatimModuleSyntax": true,
    "noEmit": false,
    "outDir": "./dist",
    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  }
}
</file>

<file path="package.json">
{
  "name": "@anterior/vibes",
  "private": true,
  "type": "module",
  "workspaces": [
    "apps/ahip-super",
    "lib/shared"
  ],
  "scripts": {
    "prettier:format": "prettier --write \"**/*.{ts,tsx,js,md,mdx,css,yaml,html}\"",
    "prettier:check": "prettier --check \"**/*.{ts,tsx,js,md,mdx,css,yaml,html}\"",
    "lint": "npx eslint ."
  },
  "dependencies": {
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@tailwindcss/vite": "^4.0.6",
    "@tanstack/react-query": "^5.69.0",
    "@tanstack/react-query-devtools": "^5.69.0",
    "@tanstack/react-router": "^1.114.3",
    "@tanstack/react-router-devtools": "^1.114.3",
    "@tanstack/react-table": "^8.21.2",
    "@tanstack/router-plugin": "^1.114.3",
    "@tiptap/pm": "^2.14.0",
    "@tiptap/react": "^2.14.0",
    "@tiptap/starter-kit": "^2.14.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dexie": "^4.0.11",
    "dexie-react-hooks": "^1.1.7",
    "framer-motion": "^12.16.0",
    "lodash": "^4.17.21",
    "lucide-react": "^0.476.0",
    "openai": "^4.90.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-pdf": "^9.2.1",
    "react-resize-detector": "^12.0.2",
    "recharts": "^2.15.3",
    "tailwind-merge": "^3.3.0",
    "tailwind-variants": "^1.0.0",
    "tailwindcss": "^4.0.6",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.25.56"
  },
  "overrides": {
    "react-is": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/compat": "^1.2.8",
    "@eslint/js": "^9.24.0",
    "@nx/eslint": "21.1.3",
    "@nx/js": "^21.1.3",
    "@nx/vite": "21.1.3",
    "@nx/web": "21.1.3",
    "@swc-node/register": "~1.9.1",
    "@swc/core": "~1.5.7",
    "@swc/helpers": "~0.5.11",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/react": "^16.2.0",
    "@types/lodash": "^4.17.16",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "@vitejs/plugin-react": "^4.3.4",
    "@vitest/ui": "^3.0.0",
    "eslint": "^9.24.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-react": "^7.37.5",
    "globals": "^16.0.0",
    "jiti": "2.4.2",
    "jsdom": "^26.0.0",
    "nx": "21.1.3",
    "prettier": "3.5.3",
    "tw-animate-css": "^1.2.5",
    "typescript": "^5.7.2",
    "typescript-eslint": "^8.29.0",
    "vite": "^6.1.0",
    "vitest": "^3.0.5",
    "web-vitals": "^4.2.4"
  }
}
</file>

<file path="apps/ahip-super/src/controller/supervise-agent-controller.ts">
import { useState } from "react";
import type { AgentRun } from "@/view/supervise/runs/columns";

const OUTCOME_BREAKDOWN_DATA = [
  {
    day: "Mo",
    certification: 1200,
    noncertification: 800,
    adminnoncertification: 200,
  },
  {
    day: "Tu",
    certification: 900,
    noncertification: 600,
    adminnoncertification: 100,
  },
  {
    day: "We",
    certification: 1100,
    noncertification: 700,
    adminnoncertification: 150,
  },
  {
    day: "Th",
    certification: 1300,
    noncertification: 900,
    adminnoncertification: 120,
  },
  {
    day: "Fr",
    certification: 1000,
    noncertification: 800,
    adminnoncertification: 180,
  },
  {
    day: "Sa",
    certification: 400,
    noncertification: 200,
    adminnoncertification: 50,
  },
  {
    day: "Su",
    certification: 700,
    noncertification: 500,
    adminnoncertification: 90,
  },
];

const DURATION_DATA = [
  { day: "Mo", duration: 220 },
  { day: "Tu", duration: 140 },
  { day: "We", duration: 180 },
  { day: "Th", duration: 160 },
  { day: "Fr", duration: 170 },
  { day: "Sa", duration: 60 },
  { day: "Su", duration: 100 },
];

const TRIGGERS = ["SMART on FHIR", "Florence", "API", "Epic EHR"];

const RUNS: AgentRun[] = Array.from({ length: 60 }, (_, i) => {
  let outcome: string;
  if (i % 3 === 0) outcome = "Medical certification";
  else if (i % 3 === 1) outcome = "Medical non-certification";
  else outcome = "Administrative non-certification";

  const trigger = TRIGGERS[i % TRIGGERS.length];
  if (!trigger) throw new Error("No trigger found");

  return {
    runTitle: `Run ${i + 1} C1234${i}`,
    outcome,
    duration: `${Math.floor(Math.random() * 40) + 1}m ${Math.floor(Math.random() * 60)}s`,
    trigger,
  };
});

export function useSuperviseAgent() {
  // In a real app, fetch by agentId
  const [outcomeBreakdownData] = useState(OUTCOME_BREAKDOWN_DATA);
  const [durationData] = useState(DURATION_DATA);
  const [runs] = useState(RUNS);
  return { outcomeBreakdownData, durationData, runs };
}
</file>

<file path="apps/atlas/src/controller/use-artifacts.ts">
import { useInfiniteQuery } from "@tanstack/react-query";
import { fetchArtifacts } from "./handlers/fetch-artifacts";

export const useArtifacts = (tags: string[] = []) => {
  return useInfiniteQuery({
    queryKey: ["artifacts", tags],
    queryFn: ({ pageParam }) => fetchArtifacts({ tags, pageParam }),
    initialPageParam: 0,
    getNextPageParam: (lastPage) => lastPage.nextCursor,
  });
};
</file>

<file path="apps/atlas/package.json">
{
  "name": "@anterior-vibe/atlas",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "nx vite:serve --port 3000",
    "build": "nx vite:build && tsc",
    "serve": "nx preview",
    "test": "vitest run"
  },
  "dependencies": {
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@tailwindcss/vite": "^4.0.6",
    "@tanstack/react-query": "^5.69.0",
    "@tanstack/react-query-devtools": "^5.69.0",
    "@tanstack/react-router": "^1.114.3",
    "@tanstack/react-router-devtools": "^1.114.3",
    "@tanstack/react-table": "^8.21.2",
    "@tanstack/router-plugin": "^1.114.3",
    "ai": "^4.2.6",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.6.2",
    "lucide-react": "^0.476.0",
    "marked": "^15.0.7",
    "openai": "^4.90.0",
    "react": "^19.0.0",
    "react-aria-components": "^1.8.0",
    "react-dom": "^19.0.0",
    "react-intersection-observer": "^9.16.0",
    "react-markdown": "^10.1.0",
    "react-pdf": "^9.2.1",
    "recharts": "^2.15.1",
    "tailwind-merge": "^3.0.2",
    "tailwindcss": "^4.0.6",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.3"
  },
  "overrides": {
    "react-is": "^19.0.0"
  },
  "devDependencies": {
    "@testing-library/dom": "^10.4.0",
    "@testing-library/react": "^16.2.0",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "@vitejs/plugin-react": "^4.3.4",
    "globals": "^16.0.0",
    "jsdom": "^26.0.0",
    "tw-animate-css": "^1.2.5",
    "typescript": "^5.7.2",
    "vite": "^6.1.0",
    "vitest": "^3.0.5",
    "web-vitals": "^4.2.4"
  }
}
</file>

<file path="apps/flonotes/neuron/react/index.ts">
"use client"; // NOTE: Delete when we get rid of Next.js

export { Button, DestructiveActionButton, buttonVariants } from "./button";
export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuRadioGroup,
} from "./dropdown";

export { ContextMenu } from "./context";
export { Dialog } from "./dialog";
export { Kbd, kbdVariants } from "./kbd";
export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
} from "./select";
export {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
} from "./table.tsx";
export {
  Tooltip,
  TooltipArrow,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "./tooltip";
export {
  Typography,
  typographyVariants,
  type TypographyProps,
} from "./typography";

export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
} from "./sheet.tsx";
</file>

<file path="apps/flonotes/src/components/shell/notes/config/editor-config.ts">
import Document from "@tiptap/extension-document";
import StarterKit from "@tiptap/starter-kit";
import Placeholder from "@tiptap/extension-placeholder";
import { InsertInfo } from "../extension-insert";
import { Citation } from "../custom-nodes/citation";
import TaskItem from "@tiptap/extension-task-item";
import TaskList from "@tiptap/extension-task-list";
import Collaboration from "@tiptap/extension-collaboration";
import * as Y from "yjs";
import { IndexeddbPersistence } from "y-indexeddb";

const ydoc = new Y.Doc();
const CustomDocument = Document.extend({
  content: "heading block*",
});

new IndexeddbPersistence("example-document", ydoc);

function getEditorConfig() {
  return [
    CustomDocument,
    Collaboration.configure({
      document: ydoc,
    }),
    TaskList,
    TaskItem.configure({
      nested: true,
    }),
    StarterKit.configure({
      document: false,
      history: false,
    }),
    Citation,
    InsertInfo,
    Placeholder.configure({
      placeholder: ({ node, pos }) => {
        if (node.type.name === "heading") {
          return "New FloNote";
        }

        // Only show placeholder in the first paragraph
        if (pos === 2) {
          // Show different placeholder messages
          const messages = [
            "Write something...",
            "Ask Florence...",
            "Use a template...",
            "Add Quickfill...",
          ];

          // Change message every 3 seconds
          const index = Math.floor(Date.now() / 3000) % messages.length;
          return messages[index];
        }
        return "";
      },
      showOnlyWhenEditable: true,
      includeChildren: false,
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
    }),
  ];
}

export default getEditorConfig;
</file>

<file path="apps/flonotes/src/components/shell/notes/styles/index.ts">
import { tv } from "tailwind-variants";

const editorClassStyles = tv({
  base: "focus:outline-hidden prose prose-paper prose-strong:font-saans-medium prose-p:text-base prose-h1:text-title-two prose-h2:text-large-plus text-body h-full w-full p-fib-13 pt-0 caret-anterior-400 [&_.is-empty:first-child::before]:content-[attr(data-placeholder)] [&_.is-empty:first-child::before]:float-left [&_.is-empty:first-child::before]:text-ink-400 [&_.is-empty:first-child::before]:pointer-events-none selection:bg-anterior-500/50 [&_ul[data-type=taskList]_p]:my-0 [&_ul[data-type=taskList]_p]:leading-[28px]",
});

export { editorClassStyles };
</file>

<file path="apps/flonotes/src/hooks/use-process-pdf.ts">
import { useMutation } from "@tanstack/react-query";
import { savePdf, updatePdfExtracts } from "./use-pdf-storage";
import { processAndGetPdfExtracts } from "../services/noggin-api";

export const processPdfsMutationKey = [["pdf", "processPdfs"]];

/**
 * Hook for processing PDF files with the noggin service
 * This replaces the previous tRPC-based implementation
 */
export function useProcessPdfs() {
  return useMutation({
    // for use with noggin pdfs/process-pdfs
    mutationKey: processPdfsMutationKey,
    mutationFn: async (variables: {
      fileData: number[];
      fileName: string;
      documentType: "clinical" | "criteria";
      stemUid?: string; // Optional stemUid parameter - should almost never be used
    }) => {
      // Create a blob for local storage
      // NB: we are NOT yet persisting the PDF in the backend
      const blob = new Blob([new Uint8Array(variables.fileData)], {
        type: "application/pdf",
      });

      const id = await savePdf({
        fileName: variables.fileName,
        documentType: variables.documentType,
        blob,
        timestamp: Date.now(),
      });

      const contextId = id;

      // Process the PDF and get the extracts
      // We deliberately don't provide a stemUid here - the server will generate one
      // (variables.stemUid should only be used in very specific circumstances)
      const result = await processAndGetPdfExtracts(
        variables.fileData,
        variables.fileName,
        variables.documentType,
      );

      // Extract stemUid and pdfUid from the result
      // The processAndGetPdfExtracts function returns the complete PDF extracts,
      // but also includes metadata like stemUid and pdfUid
      const stemUid = result?.stemUid;
      const pdfUid = result?.pdfUid;

      // Log the association for debugging
      if (stemUid && pdfUid) {
        console.log(
          `PDF processed with server-assigned stemUid: ${stemUid}, pdfUid: ${pdfUid}`,
        );
      } else {
        console.error(
          "Server did not return required stemUid or pdfUid in PDF processing response:",
          result,
        );
        throw new Error("Server did not return required stemUid in response");
      }

      // Add stemUid and pdfUid to the result object for storage
      const enhancedResult = {
        ...result,
        stemUid,
        pdfUid,
      };

      return { result: enhancedResult, contextId, stemUid, pdfUid };
    },

    onSuccess: async (data) => {
      if (data.contextId) {
        // Update the PDF extracts and store the stemUid and pdfUid
        await updatePdfExtracts(
          data.contextId,
          data.result,
          data.stemUid,
          data.pdfUid,
        );
      }
    },

    onError: (error) => {
      console.error("Error processing PDF:", error);
    },
  });
}
</file>

<file path="apps/flopilot/src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

// Import Routes

import { Route as rootRoute } from './routes/__root'
import { Route as FlopilotImport } from './routes/flopilot'
import { Route as FlopilotIndexImport } from './routes/flopilot.index'
import { Route as FlopilotChatsStemIdImport } from './routes/flopilot.chats.$stemId'

// Create/Update Routes

const FlopilotRoute = FlopilotImport.update({
  id: '/flopilot',
  path: '/flopilot',
  getParentRoute: () => rootRoute,
} as any)

const FlopilotIndexRoute = FlopilotIndexImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => FlopilotRoute,
} as any)

const FlopilotChatsStemIdRoute = FlopilotChatsStemIdImport.update({
  id: '/chats/$stemId',
  path: '/chats/$stemId',
  getParentRoute: () => FlopilotRoute,
} as any)

// Populate the FileRoutesByPath interface

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/flopilot': {
      id: '/flopilot'
      path: '/flopilot'
      fullPath: '/flopilot'
      preLoaderRoute: typeof FlopilotImport
      parentRoute: typeof rootRoute
    }
    '/flopilot/': {
      id: '/flopilot/'
      path: '/'
      fullPath: '/flopilot/'
      preLoaderRoute: typeof FlopilotIndexImport
      parentRoute: typeof FlopilotImport
    }
    '/flopilot/chats/$stemId': {
      id: '/flopilot/chats/$stemId'
      path: '/chats/$stemId'
      fullPath: '/flopilot/chats/$stemId'
      preLoaderRoute: typeof FlopilotChatsStemIdImport
      parentRoute: typeof FlopilotImport
    }
  }
}

// Create and export the route tree

interface FlopilotRouteChildren {
  FlopilotIndexRoute: typeof FlopilotIndexRoute
  FlopilotChatsStemIdRoute: typeof FlopilotChatsStemIdRoute
}

const FlopilotRouteChildren: FlopilotRouteChildren = {
  FlopilotIndexRoute: FlopilotIndexRoute,
  FlopilotChatsStemIdRoute: FlopilotChatsStemIdRoute,
}

const FlopilotRouteWithChildren = FlopilotRoute._addFileChildren(
  FlopilotRouteChildren,
)

export interface FileRoutesByFullPath {
  '/flopilot': typeof FlopilotRouteWithChildren
  '/flopilot/': typeof FlopilotIndexRoute
  '/flopilot/chats/$stemId': typeof FlopilotChatsStemIdRoute
}

export interface FileRoutesByTo {
  '/flopilot': typeof FlopilotIndexRoute
  '/flopilot/chats/$stemId': typeof FlopilotChatsStemIdRoute
}

export interface FileRoutesById {
  __root__: typeof rootRoute
  '/flopilot': typeof FlopilotRouteWithChildren
  '/flopilot/': typeof FlopilotIndexRoute
  '/flopilot/chats/$stemId': typeof FlopilotChatsStemIdRoute
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths: '/flopilot' | '/flopilot/' | '/flopilot/chats/$stemId'
  fileRoutesByTo: FileRoutesByTo
  to: '/flopilot' | '/flopilot/chats/$stemId'
  id: '__root__' | '/flopilot' | '/flopilot/' | '/flopilot/chats/$stemId'
  fileRoutesById: FileRoutesById
}

export interface RootRouteChildren {
  FlopilotRoute: typeof FlopilotRouteWithChildren
}

const rootRouteChildren: RootRouteChildren = {
  FlopilotRoute: FlopilotRouteWithChildren,
}

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()

/* ROUTE_MANIFEST_START
{
  "routes": {
    "__root__": {
      "filePath": "__root.tsx",
      "children": [
        "/flopilot"
      ]
    },
    "/flopilot": {
      "filePath": "flopilot.tsx",
      "children": [
        "/flopilot/",
        "/flopilot/chats/$stemId"
      ]
    },
    "/flopilot/": {
      "filePath": "flopilot.index.tsx",
      "parent": "/flopilot"
    },
    "/flopilot/chats/$stemId": {
      "filePath": "flopilot.chats.$stemId.tsx",
      "parent": "/flopilot"
    }
  }
}
ROUTE_MANIFEST_END */
</file>

<file path="apps/mnr-determination-viewer/src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

// Import Routes

import { Route as rootRoute } from "./routes/__root";
import { Route as MnrDeterminationViewerImport } from "./routes/mnr-determination-viewer";
import { Route as DemoTanstackQueryImport } from "./routes/demo.tanstack-query";

// Create/Update Routes

const MnrDeterminationViewerRoute = MnrDeterminationViewerImport.update({
  id: "/mnr-determination-viewer",
  path: "/mnr-determination-viewer",
  getParentRoute: () => rootRoute,
} as any);

const DemoTanstackQueryRoute = DemoTanstackQueryImport.update({
  id: "/demo/tanstack-query",
  path: "/demo/tanstack-query",
  getParentRoute: () => rootRoute,
} as any);

// Populate the FileRoutesByPath interface

declare module "@tanstack/react-router" {
  interface FileRoutesByPath {
    "/mnr-determination-viewer": {
      id: "/mnr-determination-viewer";
      path: "/mnr-determination-viewer";
      fullPath: "/mnr-determination-viewer";
      preLoaderRoute: typeof MnrDeterminationViewerImport;
      parentRoute: typeof rootRoute;
    };
    "/demo/tanstack-query": {
      id: "/demo/tanstack-query";
      path: "/demo/tanstack-query";
      fullPath: "/demo/tanstack-query";
      preLoaderRoute: typeof DemoTanstackQueryImport;
      parentRoute: typeof rootRoute;
    };
  }
}

// Create and export the route tree

export interface FileRoutesByFullPath {
  "/mnr-determination-viewer": typeof MnrDeterminationViewerRoute;
  "/demo/tanstack-query": typeof DemoTanstackQueryRoute;
}

export interface FileRoutesByTo {
  "/mnr-determination-viewer": typeof MnrDeterminationViewerRoute;
  "/demo/tanstack-query": typeof DemoTanstackQueryRoute;
}

export interface FileRoutesById {
  __root__: typeof rootRoute;
  "/mnr-determination-viewer": typeof MnrDeterminationViewerRoute;
  "/demo/tanstack-query": typeof DemoTanstackQueryRoute;
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath;
  fullPaths: "/mnr-determination-viewer" | "/demo/tanstack-query";
  fileRoutesByTo: FileRoutesByTo;
  to: "/mnr-determination-viewer" | "/demo/tanstack-query";
  id: "__root__" | "/mnr-determination-viewer" | "/demo/tanstack-query";
  fileRoutesById: FileRoutesById;
}

export interface RootRouteChildren {
  MnrDeterminationViewerRoute: typeof MnrDeterminationViewerRoute;
  DemoTanstackQueryRoute: typeof DemoTanstackQueryRoute;
}

const rootRouteChildren: RootRouteChildren = {
  MnrDeterminationViewerRoute: MnrDeterminationViewerRoute,
  DemoTanstackQueryRoute: DemoTanstackQueryRoute,
};

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>();

/* ROUTE_MANIFEST_START
{
  "routes": {
    "__root__": {
      "filePath": "__root.tsx",
      "children": [
        "/mnr-determination-viewer",
        "/demo/tanstack-query"
      ]
    },
    "/mnr-determination-viewer": {
      "filePath": "mnr-determination-viewer.tsx"
    },
    "/demo/tanstack-query": {
      "filePath": "demo.tanstack-query.tsx"
    }
  }
}
ROUTE_MANIFEST_END */
</file>

<file path="apps/mnr-determination-viewer/package.json">
{
  "name": "mnr-determination-viewer",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "nx vite:serve --port 3000",
    "start": "nx vite:serve --port 3000",
    "build": "nx vite:build && tsc",
    "serve": "nx preview",
    "test": "nx test run"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.0.6",
    "@tanstack/react-query": "^5.66.5",
    "@tanstack/react-query-devtools": "^5.66.5",
    "@tanstack/react-router": "^1.114.3",
    "@tanstack/react-router-devtools": "^1.114.3",
    "@tanstack/router-plugin": "^1.114.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwindcss": "^4.0.6"
  },
  "devDependencies": {
    "@testing-library/dom": "^10.4.0",
    "@testing-library/react": "^16.2.0",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "@vitejs/plugin-react": "^4.3.4",
    "jsdom": "^26.0.0",
    "typescript": "^5.7.2",
    "vite": "^6.1.0",
    "vitest": "^3.0.5",
    "web-vitals": "^4.2.4"
  }
}
</file>

<file path="apps/mnr-determination-viewer/tsconfig.json">
{
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="apps/flonotes/src/services/noggin-api.ts">
/**
 * Prototype Noggin API Service
 * Provides examples of how to directly access noggin services,
 * which will power FloNotes and other experimental apps.
 */

import { ExtractApi } from "../components/shell/pdf/providers/citations/types";

declare global {
  interface ImportMeta {
    env: Record<string, string>;
  }
}

interface AuthResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
}

interface NoteMessage {
  role: "user" | "assistant";
  content: string;
}

interface NoteRequest {
  stemUid: string;
  messages?: NoteMessage[];
  userMessage: string;
  clinicals?: unknown[];
}

interface ProcessPdfsResponse {
  pdfUids: string[];
  stemUid: string;
}

// HACK
function getRequiredEnv(key: string, isDevelopment = false): string {
  const value = import.meta.env[key];

  if (!value && !isDevelopment) {
    console.error(`Required environment variable ${key} is missing!`);
  }

  return value || "";
}

const NOGGIN_HOST = getRequiredEnv("VITE_NOGGIN_HOST");

const API_ENDPOINTS = {
  processPdfs: `${NOGGIN_HOST}/pdfs/process-pdfs`,
  getPdfExtracts: `${NOGGIN_HOST}/pdfs/pdf-extracts`,
  pdfStatus: `${NOGGIN_HOST}/pdfs/pdf-status`,
  notes: `${NOGGIN_HOST}/notes/notes`,
  noteStatus: `${NOGGIN_HOST}/notes/notes-status`,
  getNote: `${NOGGIN_HOST}/notes/notes`,
  // we need to build auth within the shell, properly
  // discuss with paul
  login: `${NOGGIN_HOST}/auth/login`,
  verifyOtp: `${NOGGIN_HOST}/auth/otp/verify`,
  authStatus: `${NOGGIN_HOST}/auth/status`,
} as const;

// Create a promise that resolves when auth is properly initialized
// This helps prevent race conditions where API requests are made before auth is ready
let authInitResolveFn: () => void;

// Authentication state tracking
let _isAuthenticated = false;

// Initialize the promise
const authInitPromise: Promise<void> = new Promise((resolve) => {
  authInitResolveFn = resolve;
});

// Set up proper initialization sequence,
// we should do this early
function initializeAuth() {
  console.log("Auth: Initializing authentication system");

  checkLoginState().then((isLoggedIn) => {
    console.log(
      `Auth: Initial login check completed, logged in: ${isLoggedIn}`,
    );
    _isAuthenticated = isLoggedIn;

    authInitResolveFn();
  });
}

initializeAuth();

export async function processPdfs(
  fileData: number[],
  fileName: string,
  documentType: "clinical" | "criteria",
  stemUid?: string,
): Promise<ProcessPdfsResponse> {
  const buffer = new Uint8Array(fileData);
  const blob = new Blob([buffer], { type: "application/pdf" });

  const formData = new FormData();
  formData.append("files[]", blob, fileName);
  formData.append("documentType", documentType);

  // Add stemUid to request if provided
  if (stemUid) {
    formData.append("stemUid", stemUid);
  }

  console.log(
    `PDF request data: filename=${fileName}, has stemUid=${!!stemUid}`,
  );

  try {
    // Check authentication status
    const isAuthenticated = await ensureAuthentication();

    if (!isAuthenticated) {
      console.warn(
        "PDF processing attempted without authentication - will likely fail",
      );
      // We continue anyway to get a proper 401 response for debugging
    }

    // Make the request with credentials to include HttpOnly cookies
    const response = await apiRequest(API_ENDPOINTS.processPdfs, {
      method: "POST",
      body: formData,
    });

    console.log(`PDF processing response status: ${response.status}`);

    if (!response.ok) {
      let errorDetails = "";
      try {
        errorDetails = await response.text();
      } catch {
        errorDetails = "No error details available";
      }
      console.error(`PDF processing error (${response.status}):`, errorDetails);

      throw new Error(
        `HTTP error! status: ${response.status}, details: ${errorDetails}`,
      );
    }

    const data = await response.json();
    console.log(
      `PDF processing success. Got stemUid=${data.stemUid}, pdfUid=${data.pdfUid}`,
    );

    // Ensure we have both stemUid and pdfUid from the response
    if (!data.stemUid || !data.pdfUids) {
      throw new Error(
        "Invalid response from PDF processing service: missing required IDs",
      );
    }

    return data;
  } catch (error) {
    console.error("Error processing PDF:", error);
    throw error;
  }
}

export async function getPdfStatus(
  stemUid: string,
  pdfUid: string,
): Promise<{ status: "processing" | "ready" | "error"; message?: string }> {
  try {
    // Try to ensure we have authentication before proceeding
    await ensureAuthentication();

    const response = await apiRequest(
      `${API_ENDPOINTS.pdfStatus}/${stemUid}/${pdfUid}`,
      {
        method: "GET",
        cache: "no-store",
      },
    );

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error("Error checking PDF status:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : String(error),
    };
  }
}

export async function getPdfExtracts(
  stemUid: string,
  pdfUid: string,
  maxRetries = 100,
  intervalMs = 5000,
): Promise<unknown> {
  if (!pdfUid || !stemUid) {
    throw new Error(
      "Both stemUid and pdfUid are required for polling PDF extracts",
    );
  }

  let retries = 0;
  let lastError: Error | null = null;

  // for debugging, but not un-useful. though a crutch
  await ensureAuthentication();

  while (retries < maxRetries) {
    try {
      // First check status
      const status = await getPdfStatus(stemUid, pdfUid);

      if (status.status === "processing") {
        await new Promise((resolve) => setTimeout(resolve, intervalMs));
        retries++;
        continue;
      }

      if (status.status === "error") {
        throw new Error(`PDF processing error: ${status.message}`);
      }

      // get the url for the pdf extracts
      const url = `${API_ENDPOINTS.getPdfExtracts}/${stemUid}/${pdfUid}`;

      // attempt to get pdf extracts
      const response = await apiRequest(url, {
        method: "GET",
        cache: "no-store",
      });

      if (!response.ok) {
        lastError = new Error(`HTTP error! status: ${response.status}`);
        await new Promise((resolve) => setTimeout(resolve, intervalMs));
        retries++;
        continue;
      }

      return await response.json();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      await new Promise((resolve) => setTimeout(resolve, intervalMs));
      retries++;
    }
  }

  throw new Error(
    `PDF processing timed out after ${maxRetries} attempts. Last error: ${lastError?.message || "Unknown error"}`,
  );
}

// hack to debug auth race conditions. we should remove
// when we move landing/login into the shell properly
export function delayRequest(ms = 1000): Promise<void> {
  console.log(`Auth: Delaying request for ${ms}ms to allow cookie propagation`);
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Clear all authentication data (useful for logout or debugging)
 * TODO: we need a logout button...and to logout via the server anyway
 */
export function clearAuth(): void {
  console.log("Auth: Clearing all authentication data");

  // clear cookies by setting expiration in the past
  document.cookie =
    "access_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax";
  document.cookie =
    "auth_indicator=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax";

  _isAuthenticated = false;
}

export async function processAndGetPdfExtracts(
  fileData: number[],
  fileName: string,
  documentType: "clinical" | "criteria",
  stemUid?: string,
  maxRetries = 100,
  intervalMs = 5000,
): Promise<ExtractApi[]> {
  // Ensure we have auth before proceeding
  await ensureAuthentication();

  // Process the PDF - stemUid is optional and should rarely be provided
  // Server will generate a stemUid which will be returned in the response
  const response = await processPdfs(fileData, fileName, documentType, stemUid);
  const { pdfUids, stemUid: responseStemUid } = response;

  if (!pdfUids[0] || !responseStemUid) {
    throw new Error(
      "Failed to get required UIDs from PDF processing - server must provide stemUid",
    );
  }

  console.log(
    `Using server-assigned stemUid: ${responseStemUid} for further operations`,
  );

  // Short delay before polling to allow server to start processing
  await delayRequest(2000);

  try {
    // Get the extracts using the server-assigned stemUid
    const extractsResponse = await getPdfExtracts(
      responseStemUid,
      pdfUids[0],
      maxRetries,
      intervalMs,
    );

    // Add the stemUid and pdfUid to the response for client-side tracking
    return {
      ...extractsResponse,
      stemUid: responseStemUid,
      pdfUid: pdfUids[0],
    };
  } catch (pollError) {
    throw new Error(
      `Failed to retrieve PDF extraction results: ${pollError instanceof Error ? pollError.message : String(pollError)}`,
    );
  }
}

export async function ensureAuthentication(): Promise<boolean> {
  // First, check if we already know the authentication state
  if (_isAuthenticated) {
    return true;
  }

  console.log("Auth: Checking for authentication indicators...");

  // Check for auth_indicator cookie (visible to JavaScript)
  const hasIndicatorCookie = document.cookie.includes("auth_indicator=true");

  if (hasIndicatorCookie) {
    console.log("Auth: Found auth_indicator cookie");
    _isAuthenticated = true;
    return true;
  }

  console.log(
    "Auth: No authentication indicators found (but HttpOnly cookies may still be working)",
  );
  return false;
}

export async function createNote({
  stemUid,
  messages = [],
  userMessage,
  clinicals = [],
}: NoteRequest): Promise<string> {
  try {
    if (!stemUid) {
      throw new Error("stemUid is required for creating notes");
    }

    // Try to ensure we have authentication before proceeding
    await ensureAuthentication();

    // Construct the request data
    const requestData = {
      stemUid,
      messages,
      userMessage,
      clinicals,
    };

    console.log(
      `Request data with stemUid ${stemUid}:`,
      JSON.stringify(requestData).substring(0, 200) + "...",
    );

    const headers = {
      "Content-Type": "application/json",
    };

    // Make the request with credentials (cookies) for authentication
    const response = await apiRequest(API_ENDPOINTS.notes, {
      method: "POST",
      headers,
      body: JSON.stringify(requestData),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(
        `Error response from notes endpoint (${response.status}):`,
        errorText,
      );
      throw new Error(
        `HTTP error! status: ${response.status}, details: ${errorText}`,
      );
    }

    const responseText = await response.text();
    console.log(
      "Received note response:",
      responseText.substring(0, 100) + (responseText.length > 100 ? "..." : ""),
    );

    if (
      responseText.trim().startsWith("{") &&
      responseText.trim().endsWith("}")
    ) {
      try {
        const data = JSON.parse(responseText);
        if (data.response) {
          return data.response;
        }
      } catch (e) {
        console.error("Error parsing JSON response:", e);
      }
    }

    return responseText;
  } catch (error) {
    console.error("Error creating note:", error);
    throw error;
  }
}

/**
 * Creates a note via LLM and polls until it's complete
 *
 * This handles the complete flow of creating a note and waiting for the LLM
 * to finish generating content, with automatic polling until completion.
 */
export async function createAndWaitForNote(
  request: NoteRequest,
  maxRetries = 100,
  intervalMs = 2000,
): Promise<string> {
  try {
    console.log("Creating note with polling for stemUid:", request.stemUid);

    // Step 1: Create the note - this returns a noteUid we'll use for polling
    const stemUid = request.stemUid;

    // Make initial POST request to create the note
    const response = await apiRequest(API_ENDPOINTS.notes, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Error creating note (${response.status}):`, errorText);
      throw new Error(`HTTP error when creating note: ${response.status}`);
    }

    // Extract the noteUid from the response
    let noteUid: string;
    try {
      const data = await response.json();
      console.log("Note creation response:", data);

      if (!data.noteUid) {
        throw new Error("Response missing noteUid");
      }

      noteUid = data.noteUid;
      console.log(`Successfully created note with noteUid: ${noteUid}`);
    } catch (e) {
      console.error("Error parsing note creation response:", e);
      throw new Error("Failed to get noteUid from creation response");
    }

    // Step 2: Poll the status endpoint until the note is ready
    let retries = 0;
    while (retries < maxRetries) {
      await new Promise((resolve) => setTimeout(resolve, intervalMs));

      try {
        console.log(
          `Checking note status for noteUid: ${noteUid} (attempt ${retries + 1}/${maxRetries})`,
        );
        const statusUrl = `${API_ENDPOINTS.noteStatus}/${stemUid}/${noteUid}`;
        const statusResponse = await apiRequest(statusUrl, { method: "GET" });

        if (!statusResponse.ok) {
          console.warn(`Note status check failed: ${statusResponse.status}`);
          retries++;
          continue;
        }

        const statusData = await statusResponse.json();
        console.log(`Status check response:`, statusData);

        // If the note is ready, get the content
        if (statusData.status === "ready") {
          console.log("Note is ready, fetching content");

          // Step 3: Fetch the completed note
          const noteUrl = `${API_ENDPOINTS.getNote}/${stemUid}/${noteUid}`;
          const noteResponse = await apiRequest(noteUrl, { method: "GET" });

          if (!noteResponse.ok) {
            throw new Error(
              `Failed to get completed note: ${noteResponse.status}`,
            );
          }

          // Try to parse the response as JSON first
          try {
            const responseData = await noteResponse.json();
            console.log("Note response data:", responseData);

            // If it's JSON with a content field, return just the content
            if (responseData && typeof responseData.content === "string") {
              console.log("Extracted content from JSON response");
              return responseData.content;
            }

            // If it's JSON but structured differently, stringify it for debugging
            console.warn("Unexpected JSON response structure:", responseData);
            return JSON.stringify(responseData);
          } catch {
            // If it's not JSON, just return the text content
            console.log("Response is not JSON, returning as text");
            const noteContent = await noteResponse.text();
            return noteContent;
          }
        }

        // If the note is still processing, continue polling
        if (
          statusData.status === "processing" ||
          statusData.status === "queued"
        ) {
          console.log(`Note is still ${statusData.status}, continuing to poll`);
          retries++;
          continue;
        }

        // If the note has an error, throw
        if (statusData.status === "error") {
          throw new Error(
            `Note generation error: ${statusData.message || "Unknown error"}`,
          );
        }
      } catch (e) {
        console.warn("Error during status check:", e);
        retries++;
      }
    }

    throw new Error(`Note generation timed out after ${maxRetries} retries`);
  } catch (error) {
    console.error("Error in createAndWaitForNote:", error);
    throw error;
  }
}

/**
 * Initiates login flow by submitting email and password
 * @param email User's email address
 * @param password User's password
 * @returns Promise that resolves when OTP is sent
 */
export async function initiateLogin(
  email: string,
  password: string,
): Promise<void> {
  console.log(`Auth: Initiating login for email: ${email}`);
  try {
    const response = await apiRequest(API_ENDPOINTS.login, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(
        `Auth: Login failed with status ${response.status}:`,
        errorText,
      );
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    console.log("Auth: Login initiation successful, OTP should be sent");
  } catch (error) {
    console.error("Auth: Login initiation error:", error);
    throw error;
  }
}

/**
 * Verifies OTP code and completes authentication
 * @param email User's email address
 * @param otp One-time verification code
 * @returns Authentication response with tokens
 */
export async function verifyOtp(
  email: string,
  otp: string,
): Promise<AuthResponse> {
  console.log(`Auth: Verifying OTP for email: ${email}`);
  try {
    const response = await apiRequest(API_ENDPOINTS.verifyOtp, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, otp }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(
        `Auth: OTP verification failed with status ${response.status}:`,
        errorText,
      );
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const authData = await response.json();
    console.log(
      "Auth: OTP verification successful, tokens received as HttpOnly cookies",
    );

    // Wait a moment for browser to process cookies
    await delayRequest(500);

    // Update authentication state
    _isAuthenticated = true;

    return authData;
  } catch (error) {
    console.error("Auth: OTP verification error:", error);
    throw error;
  }
}

export async function checkLoginState(): Promise<boolean> {
  console.log("Auth: Checking login state...");

  try {
    // Check for auth_indicator cookie (visible to JavaScript)
    const hasIndicatorCookie = document.cookie.includes("auth_indicator=true");

    if (hasIndicatorCookie) {
      console.log("Auth: Found auth_indicator cookie, user is authenticated");
      _isAuthenticated = true;
      return true;
    }

    // No indicator cookie found, user is not authenticated
    console.log(
      "Auth: No auth_indicator cookie found, user is not authenticated",
    );
    _isAuthenticated = false;
    return false;
  } catch (error) {
    console.error("Auth: Error checking login state:", error);
    _isAuthenticated = false;
    return false;
  }
}

/**
 * Simple API request function that includes credentials
 * Auth is handled entirely by HttpOnly cookies
 */
async function apiRequest(
  url: string,
  options: RequestInit = {},
): Promise<Response> {
  console.log(`API Request to: ${url}`);

  // debugging race conditions
  // we'll revisit auth when we include properly into the shell
  return authInitPromise.then(async () => {
    const requestOptions = {
      ...options,
      credentials: "include" as RequestCredentials, // This ensures HttpOnly cookies are sent
    };

    // Make the request with credentials to send HttpOnly cookies
    const response = await fetch(url, requestOptions);
    // If we get a successful response (not 401/403), mark that we're authenticated
    // This helps correct our auth state if HttpOnly cookies are working but indicators aren't present
    if (response.status !== 401 && response.status !== 403) {
      _isAuthenticated = true;
    }
    return response;
  });
}
</file>

<file path="apps/ahip-super/src/routeTree.gen.ts">
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

// Import Routes

import { Route as rootRoute } from './routes/__root'
import { Route as EEnterpriseIdWWorkspaceIdFlorencerootImport } from './routes/e.$enterpriseId.w.$workspaceId/florence/__root'
import { Route as IndexImport } from './routes/index'
import { Route as EEnterpriseIdWWorkspaceIdImport } from './routes/e.$enterpriseId.w.$workspaceId'
import { Route as EEnterpriseIdWWorkspaceIdIndexImport } from './routes/e.$enterpriseId.w.$workspaceId/index'
import { Route as EEnterpriseIdWWorkspaceIdVaultImport } from './routes/e.$enterpriseId.w.$workspaceId/vault'
import { Route as EEnterpriseIdWWorkspaceIdSuperviseImport } from './routes/e.$enterpriseId.w.$workspaceId/supervise'
import { Route as EEnterpriseIdWWorkspaceIdFlorenceImport } from './routes/e.$enterpriseId.w.$workspaceId/florence'
import { Route as EEnterpriseIdWWorkspaceIdAtlasImport } from './routes/e.$enterpriseId.w.$workspaceId/atlas'
import { Route as EEnterpriseIdWWorkspaceIdAgentsImport } from './routes/e.$enterpriseId.w.$workspaceId/agents'
import { Route as EEnterpriseIdWWorkspaceIdVaultIndexImport } from './routes/e.$enterpriseId.w.$workspaceId/vault/index'
import { Route as EEnterpriseIdWWorkspaceIdSuperviseIndexImport } from './routes/e.$enterpriseId.w.$workspaceId/supervise/index'
import { Route as EEnterpriseIdWWorkspaceIdFlorenceIndexImport } from './routes/e.$enterpriseId.w.$workspaceId/florence/index'
import { Route as EEnterpriseIdWWorkspaceIdAgentsIndexImport } from './routes/e.$enterpriseId.w.$workspaceId/agents/index'
import { Route as EEnterpriseIdWWorkspaceIdSuperviseAgentImport } from './routes/e.$enterpriseId.w.$workspaceId/supervise/agent'
import { Route as EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdImport } from './routes/e.$enterpriseId.w.$workspaceId/supervise/agent.$agentId'
import { Route as EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdImport } from './routes/e.$enterpriseId.w.$workspaceId/florence/chats.$stemId'
import { Route as EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddImport } from './routes/e.$enterpriseId.w.$workspaceId/atlas/guideline-intelligence/add'
import { Route as EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineImport } from './routes/e.$enterpriseId.w.$workspaceId/atlas/guideline-intelligence/guideline/$guideline'

// Create/Update Routes

const EEnterpriseIdWWorkspaceIdFlorencerootRoute =
  EEnterpriseIdWWorkspaceIdFlorencerootImport.update({
    id: '/__root',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdFlorenceRoute,
  } as any)

const IndexRoute = IndexImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => rootRoute,
} as any)

const EEnterpriseIdWWorkspaceIdRoute = EEnterpriseIdWWorkspaceIdImport.update({
  id: '/e/$enterpriseId/w/$workspaceId',
  path: '/e/$enterpriseId/w/$workspaceId',
  getParentRoute: () => rootRoute,
} as any)

const EEnterpriseIdWWorkspaceIdIndexRoute =
  EEnterpriseIdWWorkspaceIdIndexImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdVaultRoute =
  EEnterpriseIdWWorkspaceIdVaultImport.update({
    id: '/vault',
    path: '/vault',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdSuperviseRoute =
  EEnterpriseIdWWorkspaceIdSuperviseImport.update({
    id: '/supervise',
    path: '/supervise',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdFlorenceRoute =
  EEnterpriseIdWWorkspaceIdFlorenceImport.update({
    id: '/florence',
    path: '/florence',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdAtlasRoute =
  EEnterpriseIdWWorkspaceIdAtlasImport.update({
    id: '/atlas',
    path: '/atlas',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdAgentsRoute =
  EEnterpriseIdWWorkspaceIdAgentsImport.update({
    id: '/agents',
    path: '/agents',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdVaultIndexRoute =
  EEnterpriseIdWWorkspaceIdVaultIndexImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdVaultRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdSuperviseIndexRoute =
  EEnterpriseIdWWorkspaceIdSuperviseIndexImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdSuperviseRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdFlorenceIndexRoute =
  EEnterpriseIdWWorkspaceIdFlorenceIndexImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdFlorenceRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdAgentsIndexRoute =
  EEnterpriseIdWWorkspaceIdAgentsIndexImport.update({
    id: '/',
    path: '/',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdAgentsRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdSuperviseAgentRoute =
  EEnterpriseIdWWorkspaceIdSuperviseAgentImport.update({
    id: '/agent',
    path: '/agent',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdSuperviseRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdRoute =
  EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdImport.update({
    id: '/$agentId',
    path: '/$agentId',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdSuperviseAgentRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdRoute =
  EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdImport.update({
    id: '/chats/$stemId',
    path: '/chats/$stemId',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdFlorenceRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddRoute =
  EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddImport.update({
    id: '/guideline-intelligence/add',
    path: '/guideline-intelligence/add',
    getParentRoute: () => EEnterpriseIdWWorkspaceIdAtlasRoute,
  } as any)

const EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineRoute =
  EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineImport.update(
    {
      id: '/guideline-intelligence/guideline/$guideline',
      path: '/guideline-intelligence/guideline/$guideline',
      getParentRoute: () => EEnterpriseIdWWorkspaceIdAtlasRoute,
    } as any,
  )

// Populate the FileRoutesByPath interface

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof IndexImport
      parentRoute: typeof rootRoute
    }
    '/e/$enterpriseId/w/$workspaceId': {
      id: '/e/$enterpriseId/w/$workspaceId'
      path: '/e/$enterpriseId/w/$workspaceId'
      fullPath: '/e/$enterpriseId/w/$workspaceId'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdImport
      parentRoute: typeof rootRoute
    }
    '/e/$enterpriseId/w/$workspaceId/agents': {
      id: '/e/$enterpriseId/w/$workspaceId/agents'
      path: '/agents'
      fullPath: '/e/$enterpriseId/w/$workspaceId/agents'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdAgentsImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdImport
    }
    '/e/$enterpriseId/w/$workspaceId/atlas': {
      id: '/e/$enterpriseId/w/$workspaceId/atlas'
      path: '/atlas'
      fullPath: '/e/$enterpriseId/w/$workspaceId/atlas'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdAtlasImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdImport
    }
    '/e/$enterpriseId/w/$workspaceId/florence': {
      id: '/e/$enterpriseId/w/$workspaceId/florence'
      path: '/florence'
      fullPath: '/e/$enterpriseId/w/$workspaceId/florence'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdImport
    }
    '/e/$enterpriseId/w/$workspaceId/supervise': {
      id: '/e/$enterpriseId/w/$workspaceId/supervise'
      path: '/supervise'
      fullPath: '/e/$enterpriseId/w/$workspaceId/supervise'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdImport
    }
    '/e/$enterpriseId/w/$workspaceId/vault': {
      id: '/e/$enterpriseId/w/$workspaceId/vault'
      path: '/vault'
      fullPath: '/e/$enterpriseId/w/$workspaceId/vault'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdVaultImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdImport
    }
    '/e/$enterpriseId/w/$workspaceId/': {
      id: '/e/$enterpriseId/w/$workspaceId/'
      path: '/'
      fullPath: '/e/$enterpriseId/w/$workspaceId/'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdIndexImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdImport
    }
    '/e/$enterpriseId/w/$workspaceId/florence/__root': {
      id: '/e/$enterpriseId/w/$workspaceId/florence/__root'
      path: ''
      fullPath: '/e/$enterpriseId/w/$workspaceId/florence'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdFlorencerootImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceImport
    }
    '/e/$enterpriseId/w/$workspaceId/supervise/agent': {
      id: '/e/$enterpriseId/w/$workspaceId/supervise/agent'
      path: '/agent'
      fullPath: '/e/$enterpriseId/w/$workspaceId/supervise/agent'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseAgentImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseImport
    }
    '/e/$enterpriseId/w/$workspaceId/agents/': {
      id: '/e/$enterpriseId/w/$workspaceId/agents/'
      path: '/'
      fullPath: '/e/$enterpriseId/w/$workspaceId/agents/'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdAgentsIndexImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdAgentsImport
    }
    '/e/$enterpriseId/w/$workspaceId/florence/': {
      id: '/e/$enterpriseId/w/$workspaceId/florence/'
      path: '/'
      fullPath: '/e/$enterpriseId/w/$workspaceId/florence/'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceIndexImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceImport
    }
    '/e/$enterpriseId/w/$workspaceId/supervise/': {
      id: '/e/$enterpriseId/w/$workspaceId/supervise/'
      path: '/'
      fullPath: '/e/$enterpriseId/w/$workspaceId/supervise/'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseIndexImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseImport
    }
    '/e/$enterpriseId/w/$workspaceId/vault/': {
      id: '/e/$enterpriseId/w/$workspaceId/vault/'
      path: '/'
      fullPath: '/e/$enterpriseId/w/$workspaceId/vault/'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdVaultIndexImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdVaultImport
    }
    '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add': {
      id: '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add'
      path: '/guideline-intelligence/add'
      fullPath: '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdAtlasImport
    }
    '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId': {
      id: '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId'
      path: '/chats/$stemId'
      fullPath: '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceImport
    }
    '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId': {
      id: '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId'
      path: '/$agentId'
      fullPath: '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseAgentImport
    }
    '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline': {
      id: '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline'
      path: '/guideline-intelligence/guideline/$guideline'
      fullPath: '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline'
      preLoaderRoute: typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineImport
      parentRoute: typeof EEnterpriseIdWWorkspaceIdAtlasImport
    }
  }
}

// Create and export the route tree

interface EEnterpriseIdWWorkspaceIdAgentsRouteChildren {
  EEnterpriseIdWWorkspaceIdAgentsIndexRoute: typeof EEnterpriseIdWWorkspaceIdAgentsIndexRoute
}

const EEnterpriseIdWWorkspaceIdAgentsRouteChildren: EEnterpriseIdWWorkspaceIdAgentsRouteChildren =
  {
    EEnterpriseIdWWorkspaceIdAgentsIndexRoute:
      EEnterpriseIdWWorkspaceIdAgentsIndexRoute,
  }

const EEnterpriseIdWWorkspaceIdAgentsRouteWithChildren =
  EEnterpriseIdWWorkspaceIdAgentsRoute._addFileChildren(
    EEnterpriseIdWWorkspaceIdAgentsRouteChildren,
  )

interface EEnterpriseIdWWorkspaceIdAtlasRouteChildren {
  EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddRoute: typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddRoute
  EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineRoute: typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineRoute
}

const EEnterpriseIdWWorkspaceIdAtlasRouteChildren: EEnterpriseIdWWorkspaceIdAtlasRouteChildren =
  {
    EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddRoute:
      EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddRoute,
    EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineRoute:
      EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineRoute,
  }

const EEnterpriseIdWWorkspaceIdAtlasRouteWithChildren =
  EEnterpriseIdWWorkspaceIdAtlasRoute._addFileChildren(
    EEnterpriseIdWWorkspaceIdAtlasRouteChildren,
  )

interface EEnterpriseIdWWorkspaceIdFlorenceRouteChildren {
  EEnterpriseIdWWorkspaceIdFlorencerootRoute: typeof EEnterpriseIdWWorkspaceIdFlorencerootRoute
  EEnterpriseIdWWorkspaceIdFlorenceIndexRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceIndexRoute
  EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdRoute
}

const EEnterpriseIdWWorkspaceIdFlorenceRouteChildren: EEnterpriseIdWWorkspaceIdFlorenceRouteChildren =
  {
    EEnterpriseIdWWorkspaceIdFlorencerootRoute:
      EEnterpriseIdWWorkspaceIdFlorencerootRoute,
    EEnterpriseIdWWorkspaceIdFlorenceIndexRoute:
      EEnterpriseIdWWorkspaceIdFlorenceIndexRoute,
    EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdRoute:
      EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdRoute,
  }

const EEnterpriseIdWWorkspaceIdFlorenceRouteWithChildren =
  EEnterpriseIdWWorkspaceIdFlorenceRoute._addFileChildren(
    EEnterpriseIdWWorkspaceIdFlorenceRouteChildren,
  )

interface EEnterpriseIdWWorkspaceIdSuperviseAgentRouteChildren {
  EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdRoute
}

const EEnterpriseIdWWorkspaceIdSuperviseAgentRouteChildren: EEnterpriseIdWWorkspaceIdSuperviseAgentRouteChildren =
  {
    EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdRoute:
      EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdRoute,
  }

const EEnterpriseIdWWorkspaceIdSuperviseAgentRouteWithChildren =
  EEnterpriseIdWWorkspaceIdSuperviseAgentRoute._addFileChildren(
    EEnterpriseIdWWorkspaceIdSuperviseAgentRouteChildren,
  )

interface EEnterpriseIdWWorkspaceIdSuperviseRouteChildren {
  EEnterpriseIdWWorkspaceIdSuperviseAgentRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseAgentRouteWithChildren
  EEnterpriseIdWWorkspaceIdSuperviseIndexRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseIndexRoute
}

const EEnterpriseIdWWorkspaceIdSuperviseRouteChildren: EEnterpriseIdWWorkspaceIdSuperviseRouteChildren =
  {
    EEnterpriseIdWWorkspaceIdSuperviseAgentRoute:
      EEnterpriseIdWWorkspaceIdSuperviseAgentRouteWithChildren,
    EEnterpriseIdWWorkspaceIdSuperviseIndexRoute:
      EEnterpriseIdWWorkspaceIdSuperviseIndexRoute,
  }

const EEnterpriseIdWWorkspaceIdSuperviseRouteWithChildren =
  EEnterpriseIdWWorkspaceIdSuperviseRoute._addFileChildren(
    EEnterpriseIdWWorkspaceIdSuperviseRouteChildren,
  )

interface EEnterpriseIdWWorkspaceIdVaultRouteChildren {
  EEnterpriseIdWWorkspaceIdVaultIndexRoute: typeof EEnterpriseIdWWorkspaceIdVaultIndexRoute
}

const EEnterpriseIdWWorkspaceIdVaultRouteChildren: EEnterpriseIdWWorkspaceIdVaultRouteChildren =
  {
    EEnterpriseIdWWorkspaceIdVaultIndexRoute:
      EEnterpriseIdWWorkspaceIdVaultIndexRoute,
  }

const EEnterpriseIdWWorkspaceIdVaultRouteWithChildren =
  EEnterpriseIdWWorkspaceIdVaultRoute._addFileChildren(
    EEnterpriseIdWWorkspaceIdVaultRouteChildren,
  )

interface EEnterpriseIdWWorkspaceIdRouteChildren {
  EEnterpriseIdWWorkspaceIdAgentsRoute: typeof EEnterpriseIdWWorkspaceIdAgentsRouteWithChildren
  EEnterpriseIdWWorkspaceIdAtlasRoute: typeof EEnterpriseIdWWorkspaceIdAtlasRouteWithChildren
  EEnterpriseIdWWorkspaceIdFlorenceRoute: typeof EEnterpriseIdWWorkspaceIdFlorenceRouteWithChildren
  EEnterpriseIdWWorkspaceIdSuperviseRoute: typeof EEnterpriseIdWWorkspaceIdSuperviseRouteWithChildren
  EEnterpriseIdWWorkspaceIdVaultRoute: typeof EEnterpriseIdWWorkspaceIdVaultRouteWithChildren
  EEnterpriseIdWWorkspaceIdIndexRoute: typeof EEnterpriseIdWWorkspaceIdIndexRoute
}

const EEnterpriseIdWWorkspaceIdRouteChildren: EEnterpriseIdWWorkspaceIdRouteChildren =
  {
    EEnterpriseIdWWorkspaceIdAgentsRoute:
      EEnterpriseIdWWorkspaceIdAgentsRouteWithChildren,
    EEnterpriseIdWWorkspaceIdAtlasRoute:
      EEnterpriseIdWWorkspaceIdAtlasRouteWithChildren,
    EEnterpriseIdWWorkspaceIdFlorenceRoute:
      EEnterpriseIdWWorkspaceIdFlorenceRouteWithChildren,
    EEnterpriseIdWWorkspaceIdSuperviseRoute:
      EEnterpriseIdWWorkspaceIdSuperviseRouteWithChildren,
    EEnterpriseIdWWorkspaceIdVaultRoute:
      EEnterpriseIdWWorkspaceIdVaultRouteWithChildren,
    EEnterpriseIdWWorkspaceIdIndexRoute: EEnterpriseIdWWorkspaceIdIndexRoute,
  }

const EEnterpriseIdWWorkspaceIdRouteWithChildren =
  EEnterpriseIdWWorkspaceIdRoute._addFileChildren(
    EEnterpriseIdWWorkspaceIdRouteChildren,
  )

export interface FileRoutesByFullPath {
  '/': typeof IndexRoute
  '/e/$enterpriseId/w/$workspaceId': typeof EEnterpriseIdWWorkspaceIdRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/agents': typeof EEnterpriseIdWWorkspaceIdAgentsRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/atlas': typeof EEnterpriseIdWWorkspaceIdAtlasRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/florence': typeof EEnterpriseIdWWorkspaceIdFlorencerootRoute
  '/e/$enterpriseId/w/$workspaceId/supervise': typeof EEnterpriseIdWWorkspaceIdSuperviseRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/vault': typeof EEnterpriseIdWWorkspaceIdVaultRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/': typeof EEnterpriseIdWWorkspaceIdIndexRoute
  '/e/$enterpriseId/w/$workspaceId/supervise/agent': typeof EEnterpriseIdWWorkspaceIdSuperviseAgentRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/agents/': typeof EEnterpriseIdWWorkspaceIdAgentsIndexRoute
  '/e/$enterpriseId/w/$workspaceId/florence/': typeof EEnterpriseIdWWorkspaceIdFlorenceIndexRoute
  '/e/$enterpriseId/w/$workspaceId/supervise/': typeof EEnterpriseIdWWorkspaceIdSuperviseIndexRoute
  '/e/$enterpriseId/w/$workspaceId/vault/': typeof EEnterpriseIdWWorkspaceIdVaultIndexRoute
  '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add': typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddRoute
  '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId': typeof EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdRoute
  '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId': typeof EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdRoute
  '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline': typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineRoute
}

export interface FileRoutesByTo {
  '/': typeof IndexRoute
  '/e/$enterpriseId/w/$workspaceId/atlas': typeof EEnterpriseIdWWorkspaceIdAtlasRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId': typeof EEnterpriseIdWWorkspaceIdIndexRoute
  '/e/$enterpriseId/w/$workspaceId/florence': typeof EEnterpriseIdWWorkspaceIdFlorenceIndexRoute
  '/e/$enterpriseId/w/$workspaceId/supervise/agent': typeof EEnterpriseIdWWorkspaceIdSuperviseAgentRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/agents': typeof EEnterpriseIdWWorkspaceIdAgentsIndexRoute
  '/e/$enterpriseId/w/$workspaceId/supervise': typeof EEnterpriseIdWWorkspaceIdSuperviseIndexRoute
  '/e/$enterpriseId/w/$workspaceId/vault': typeof EEnterpriseIdWWorkspaceIdVaultIndexRoute
  '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add': typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddRoute
  '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId': typeof EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdRoute
  '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId': typeof EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdRoute
  '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline': typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineRoute
}

export interface FileRoutesById {
  __root__: typeof rootRoute
  '/': typeof IndexRoute
  '/e/$enterpriseId/w/$workspaceId': typeof EEnterpriseIdWWorkspaceIdRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/agents': typeof EEnterpriseIdWWorkspaceIdAgentsRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/atlas': typeof EEnterpriseIdWWorkspaceIdAtlasRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/florence': typeof EEnterpriseIdWWorkspaceIdFlorenceRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/supervise': typeof EEnterpriseIdWWorkspaceIdSuperviseRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/vault': typeof EEnterpriseIdWWorkspaceIdVaultRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/': typeof EEnterpriseIdWWorkspaceIdIndexRoute
  '/e/$enterpriseId/w/$workspaceId/florence/__root': typeof EEnterpriseIdWWorkspaceIdFlorencerootRoute
  '/e/$enterpriseId/w/$workspaceId/supervise/agent': typeof EEnterpriseIdWWorkspaceIdSuperviseAgentRouteWithChildren
  '/e/$enterpriseId/w/$workspaceId/agents/': typeof EEnterpriseIdWWorkspaceIdAgentsIndexRoute
  '/e/$enterpriseId/w/$workspaceId/florence/': typeof EEnterpriseIdWWorkspaceIdFlorenceIndexRoute
  '/e/$enterpriseId/w/$workspaceId/supervise/': typeof EEnterpriseIdWWorkspaceIdSuperviseIndexRoute
  '/e/$enterpriseId/w/$workspaceId/vault/': typeof EEnterpriseIdWWorkspaceIdVaultIndexRoute
  '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add': typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceAddRoute
  '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId': typeof EEnterpriseIdWWorkspaceIdFlorenceChatsStemIdRoute
  '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId': typeof EEnterpriseIdWWorkspaceIdSuperviseAgentAgentIdRoute
  '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline': typeof EEnterpriseIdWWorkspaceIdAtlasGuidelineIntelligenceGuidelineGuidelineRoute
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths:
    | '/'
    | '/e/$enterpriseId/w/$workspaceId'
    | '/e/$enterpriseId/w/$workspaceId/agents'
    | '/e/$enterpriseId/w/$workspaceId/atlas'
    | '/e/$enterpriseId/w/$workspaceId/florence'
    | '/e/$enterpriseId/w/$workspaceId/supervise'
    | '/e/$enterpriseId/w/$workspaceId/vault'
    | '/e/$enterpriseId/w/$workspaceId/'
    | '/e/$enterpriseId/w/$workspaceId/supervise/agent'
    | '/e/$enterpriseId/w/$workspaceId/agents/'
    | '/e/$enterpriseId/w/$workspaceId/florence/'
    | '/e/$enterpriseId/w/$workspaceId/supervise/'
    | '/e/$enterpriseId/w/$workspaceId/vault/'
    | '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add'
    | '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId'
    | '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId'
    | '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline'
  fileRoutesByTo: FileRoutesByTo
  to:
    | '/'
    | '/e/$enterpriseId/w/$workspaceId/atlas'
    | '/e/$enterpriseId/w/$workspaceId'
    | '/e/$enterpriseId/w/$workspaceId/florence'
    | '/e/$enterpriseId/w/$workspaceId/supervise/agent'
    | '/e/$enterpriseId/w/$workspaceId/agents'
    | '/e/$enterpriseId/w/$workspaceId/supervise'
    | '/e/$enterpriseId/w/$workspaceId/vault'
    | '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add'
    | '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId'
    | '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId'
    | '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline'
  id:
    | '__root__'
    | '/'
    | '/e/$enterpriseId/w/$workspaceId'
    | '/e/$enterpriseId/w/$workspaceId/agents'
    | '/e/$enterpriseId/w/$workspaceId/atlas'
    | '/e/$enterpriseId/w/$workspaceId/florence'
    | '/e/$enterpriseId/w/$workspaceId/supervise'
    | '/e/$enterpriseId/w/$workspaceId/vault'
    | '/e/$enterpriseId/w/$workspaceId/'
    | '/e/$enterpriseId/w/$workspaceId/florence/__root'
    | '/e/$enterpriseId/w/$workspaceId/supervise/agent'
    | '/e/$enterpriseId/w/$workspaceId/agents/'
    | '/e/$enterpriseId/w/$workspaceId/florence/'
    | '/e/$enterpriseId/w/$workspaceId/supervise/'
    | '/e/$enterpriseId/w/$workspaceId/vault/'
    | '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add'
    | '/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId'
    | '/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId'
    | '/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline'
  fileRoutesById: FileRoutesById
}

export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  EEnterpriseIdWWorkspaceIdRoute: typeof EEnterpriseIdWWorkspaceIdRouteWithChildren
}

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  EEnterpriseIdWWorkspaceIdRoute: EEnterpriseIdWWorkspaceIdRouteWithChildren,
}

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()

/* ROUTE_MANIFEST_START
{
  "routes": {
    "__root__": {
      "filePath": "__root.tsx",
      "children": [
        "/",
        "/e/$enterpriseId/w/$workspaceId"
      ]
    },
    "/": {
      "filePath": "index.tsx"
    },
    "/e/$enterpriseId/w/$workspaceId": {
      "filePath": "e.$enterpriseId.w.$workspaceId.tsx",
      "children": [
        "/e/$enterpriseId/w/$workspaceId/agents",
        "/e/$enterpriseId/w/$workspaceId/atlas",
        "/e/$enterpriseId/w/$workspaceId/florence",
        "/e/$enterpriseId/w/$workspaceId/supervise",
        "/e/$enterpriseId/w/$workspaceId/vault",
        "/e/$enterpriseId/w/$workspaceId/"
      ]
    },
    "/e/$enterpriseId/w/$workspaceId/agents": {
      "filePath": "e.$enterpriseId.w.$workspaceId/agents.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId",
      "children": [
        "/e/$enterpriseId/w/$workspaceId/agents/"
      ]
    },
    "/e/$enterpriseId/w/$workspaceId/atlas": {
      "filePath": "e.$enterpriseId.w.$workspaceId/atlas.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId",
      "children": [
        "/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add",
        "/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline"
      ]
    },
    "/e/$enterpriseId/w/$workspaceId/florence": {
      "filePath": "e.$enterpriseId.w.$workspaceId/florence.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId",
      "children": [
        "/e/$enterpriseId/w/$workspaceId/florence/__root",
        "/e/$enterpriseId/w/$workspaceId/florence/",
        "/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId"
      ]
    },
    "/e/$enterpriseId/w/$workspaceId/supervise": {
      "filePath": "e.$enterpriseId.w.$workspaceId/supervise.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId",
      "children": [
        "/e/$enterpriseId/w/$workspaceId/supervise/agent",
        "/e/$enterpriseId/w/$workspaceId/supervise/"
      ]
    },
    "/e/$enterpriseId/w/$workspaceId/vault": {
      "filePath": "e.$enterpriseId.w.$workspaceId/vault.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId",
      "children": [
        "/e/$enterpriseId/w/$workspaceId/vault/"
      ]
    },
    "/e/$enterpriseId/w/$workspaceId/": {
      "filePath": "e.$enterpriseId.w.$workspaceId/index.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId"
    },
    "/e/$enterpriseId/w/$workspaceId/florence/__root": {
      "filePath": "e.$enterpriseId.w.$workspaceId/florence/__root.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/florence"
    },
    "/e/$enterpriseId/w/$workspaceId/supervise/agent": {
      "filePath": "e.$enterpriseId.w.$workspaceId/supervise/agent.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/supervise",
      "children": [
        "/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId"
      ]
    },
    "/e/$enterpriseId/w/$workspaceId/agents/": {
      "filePath": "e.$enterpriseId.w.$workspaceId/agents/index.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/agents"
    },
    "/e/$enterpriseId/w/$workspaceId/florence/": {
      "filePath": "e.$enterpriseId.w.$workspaceId/florence/index.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/florence"
    },
    "/e/$enterpriseId/w/$workspaceId/supervise/": {
      "filePath": "e.$enterpriseId.w.$workspaceId/supervise/index.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/supervise"
    },
    "/e/$enterpriseId/w/$workspaceId/vault/": {
      "filePath": "e.$enterpriseId.w.$workspaceId/vault/index.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/vault"
    },
    "/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/add": {
      "filePath": "e.$enterpriseId.w.$workspaceId/atlas/guideline-intelligence/add.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/atlas"
    },
    "/e/$enterpriseId/w/$workspaceId/florence/chats/$stemId": {
      "filePath": "e.$enterpriseId.w.$workspaceId/florence/chats.$stemId.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/florence"
    },
    "/e/$enterpriseId/w/$workspaceId/supervise/agent/$agentId": {
      "filePath": "e.$enterpriseId.w.$workspaceId/supervise/agent.$agentId.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/supervise/agent"
    },
    "/e/$enterpriseId/w/$workspaceId/atlas/guideline-intelligence/guideline/$guideline": {
      "filePath": "e.$enterpriseId.w.$workspaceId/atlas/guideline-intelligence/guideline/$guideline.tsx",
      "parent": "/e/$enterpriseId/w/$workspaceId/atlas"
    }
  }
}
ROUTE_MANIFEST_END */
</file>

<file path="apps/ahip-super/package.json">
{
  "name": "@anterior-vibe/ahip",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "VITE_NOGGIN_HOST=http://localhost:20701 nx vite:serve",
    "build": "nx vite:build && tsc",
    "serve": "nx preview",
    "test": "vitest run"
  },
  "dependencies": {
    "@anterior-vibe/lib-shared": "file:../../lib/shared"
  }
}
</file>

<file path="apps/flopilot/package.json">
{
  "name": "@anterior-vibe/flopilot",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "VITE_NOGGIN_HOST=http://localhost:20701 nx vite:serve",
    "build": "nx vite:build && tsc",
    "serve": "nx preview",
    "test": "vitest run"
  },
  "dependencies": {
    "@anterior-vibe/lib-shared": "file:../../lib/shared"
  }
}
</file>

</files>
